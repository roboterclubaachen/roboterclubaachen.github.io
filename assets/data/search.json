[
  
   
      {
        "title"    : "Saisonrückblick 2022",
        "category" : "",
        "tags"     : " saison22",
        "url"      : "/blog/2022/saisonrueckblick-2022.html",
        "date"     : "September 11, 2022",
        "excerpt"  : "Nach zwei Jahren Corona-Pandemie wurde endlich im Roboterclub wieder ein Roboter entworfen, ausgelegt, konstruiert und gebaut.",
        "content"  : "<p>Nach zwei Jahren Corona-Pandemie wurde endlich im Roboterclub wieder ein Roboter entworfen, ausgelegt, konstruiert und gebaut.\nBis auf den letzten Schritt, das Aufbauen, sogar eigentlich zwei Roboter.</p>\n\n<p><img src=\"../../assets/img/blog/2022/2022-robot-1.jpg\" alt=\"Roboter _Wanda_, Eurobot-Saison 2022\" /></p>\n\n<p>Auch war diese Saison für viele Studierende die erste Gelegenheit einen Eurobot-Wettbewerb live zu erleben.</p>\n\n<p>Vielleicht kommt zum zweiten Roboter in der Zukunft noch ein weiterer Blog-Post.</p>\n\n<h3 id=\"mechnik-für-roboter-wanda\">Mechnik für Roboter <em>Wanda</em></h3>\n\n<p>Der Antrieb von Wanda besteht aus drei im Stern angeordneten bürstenlosen Motoren mit Planetengetriebe von Dunker. Diese treiben über ein zweistufiges Stirnradgetriebe die Antriebsräder an. Bei den Antriebsrädern handelt es sich um so genannte <em>Onmiwheels</em>, wodurch der Roboter zu jedem Zeitpunkt in jede beliebige Richtung fahren kann.</p>\n\n<p><img src=\"../../assets/img/blog/2022/2022-robot-2.jpg\" alt=\"Roboter _Wanda_, Eurobot-Saison 2022\" /></p>\n\n<p>Als Aktorik wurde ein drei-gelenkiger Greifarm entwickelt mit welchem die Spielelemente gegriffen und im Roboter verstaut werden sollten.\nDer Arm erwies sich allerdings als untermotorisiert und sehr komplex in der Ansteuerung aufgrund der hohen Anzahl an verbauten Motoren (insgesamt fünf).\nAuch aufgrund der engen personellen Lage im Team wurde der Arm nicht am Roboter verbaut sondern ein Stupser vorne am Roboter montiert, um trotzdem Interaktion mit den Spielelementen zu ermöglichen.\nIm Roboter sollte ein Greifer die Spielelemente wenden und in einer Vorrichtung ablegen. Der Greifer im Roboter und die Aufnahme für die Spielelemente sind im Roboter verbaut, wurden aufgrund des fehlenden Arms jedoch nicht benutzt.\nDie Erfahrungen aus der Entwicklung des Arms werden in zukünftige Greifaktoriken mit einfließen, wodurch man hoffentlich zukünftig eine Nachfolgeversion des Arms an einem der Roboter sehen kann.</p>\n\n<h3 id=\"elektronik\">Elektronik</h3>\n\n<p>Für die Elektronik musste leider auf viele alte Lösungen zurückgegriffen werden,\nda es neben den Supply-Chain-Problemen auch personell eng im Team war.</p>\n\n<p>Ein neues Power-Distribution-Board als Ersatz für das in die Jahre gekommene <em>BMS</em> ist in Arbeit, allerdings nicht fertig.\nDas neue Modul hat zwei Anschlüsse für 6S-LiFe-Akkus und zusätzlich einen Netzteil-Anschluss.\nDa die alte BMS-Platine nur einen Akku nutzen kann, wurde die im ungenutzten zweiten Akku-Slot untergebracht.</p>\n\n<p><img src=\"../../assets/img/blog/2022/2022-battery-bms-hack.jpg\" alt=\"Gepfuschte Anbringung der BMS Platine\" /></p>\n\n<p>Leider kamen auch die inzwischen in Version 2.1 vorhandenen <a href=\"https://github.com/roboterclubaachen/micro-motor\">Motor-Controller <em>Micro-Motor</em></a> noch nicht zu Einsatz,\nweil die Software noch nie zuvor getestet wurde und es genügend aufgebaute <a href=\"/projekt/alpha-motor.html\"><em>Alpha-Motor</em></a>-Platinen beziehungsweise hinreichend wenig Motoren im Roboter gab.</p>\n\n<h3 id=\"software\">Software</h3>\n\n<p>Entgegen des ursprünglichen Vorsatzes einen Linux-Computer in den Roboter zu integrieren und die Steuerung der Roboters in ROS2 zu implementieren, wurde zwei Wochen vor den Wettbewerben entschieden doch den alten und “bewährten” Software-Stack erneut zu verwenden.\nDieser Software-Stack nutzt das im RCA ursprünglich entwickelte Microcontroller-Framework <a href=\"https://modm.io/\"><em>modm</em></a> und das dazugehörige <a href=\"https://github.com/modm-io/lbuild\"><em>lbuild</em></a> und lässt alle Software auf einem Haupt-Microcontroller (STM32F407) laufen.\nDer Haupt-Microcontroller übernimmt neben der Spielstrategie, Fahrplanung und Motionplanning auch die Motorregelungen.\nDie Motoren sind über selbst entwickelte Motorcontroller (<a href=\"/projekt/alpha-motor.html\"><em>Alpha-Motor</em></a>) per CAN-Bus angeschlossen und bekommen darüber quasi Duty-Cycle-Werte zugeschickt und senden Encoder-Werte zurück.</p>\n\n<p>Schnell war eine Kopie der Software von 2019 im Gitlab angelegt.\nDas Anpassen an verschiedene, inzwischen drei Jahre weiter entwickelte Abhängigkeiten, wie das <a href=\"https://modm.io/\">modm Framework</a>, und beheben von Compiler- und Linker-Fehlern stellten sich als nervig heraus.</p>\n\n<p>Ein weiteres Problem trat beim Wettbewerb in der Schweiz zu Tage: Der Haupt-Microcontroller resettete sich reproduzierbar nach ein paar Sekunden, was sich nach einigem Debuggen als Speicherproblem herausstellte.\nEine Queue von CAN-Nachrichten wuchs schneller als diese geleert wurde, hatte keine Größenbegrenzung und belegt dann nach einigen Sekunden den gesamten SRAM des STM32.\nUrsächlich war hier die falsche Verteilung der vier Terminierungswiderstände für die zwei CAN-Busse im Roboter: Einer der Busse hatte drei, der andere nur einen Widerstand abbekommen.</p>\n\n<h3 id=\"wettbewerbe\">Wettbewerbe</h3>\n\n<p>Der Roboterclub ist mit eher kleineren Gruppen zu den Wettbewerben nach Belgien, in die Schweiz und zum Internationalen Finale nach La Roche-sur-Yon gefahren.</p>\n\n<h4 id=\"belgien\">Belgien</h4>\n\n<p>Zum Wettbewerb in Belgien am 23.24. April 2022 war der Roboter leider noch nicht in einem Zustand um für den Wettbewerb zu homologieren,\njedoch konnten wertvolle Erfahrungen gesammelt werden und einige Tests mit den vollständig aufgebauten Wettbewerbsspielfeldern durchgeführt werden.\nAußerdem entstand ein Großteil der saisonspezifischen Software vor Ort, sodass das Wochenende insgesamt positiv aufgefasst wurde.</p>\n\n<h4 id=\"schweiz\">Schweiz</h4>\n\n<p>Etwa einen Monat später, am 12. Mai, ging es los in den Süden der Schweiz nach Yverdon-Les-Bains um vom 13. bis zum 14. Mai am dortigen Wettbewerb teilzunehmen.\nDer Roboter homologierte hier nach kleineren Problem, die jedoch einfach zu lösen waren, etwas verspätet und konnte an den Spielen teilgenommen werden.\nMit wenigen Ausnahmen wurde auch eine stattliche Anzahl an Punkte erreicht.</p>\n\n<p><img src=\"../../assets/img/blog/2022/2022-swisseurobot-playground-robot-team.jpg\" alt=\"Ein Teil des RCA-Teams beim Eurobot-Wettbewerb in der Schweiz\" /></p>\n\n<p>Während des Wettbewerbes wurde außerdem eine <em>Inertiale Messeinheit</em> (IMU) nachgerüstet und in die Software eingebunden um die schlechte Qualität der Orientierungs-Information den Encodern des <a href=\"/projekt/fahrplattform-little.html\">Omniwheel-Antriebs</a> und des <a href=\"/projekt/ultraschall-baken.html\">Ultraschall-Baken</a> zu verbessern.\nLeider ist die vollständige Integration in unseren Software-Stack erst nach dem Wettbewerb fertig geworden.</p>\n\n<p>Auf dem Rückweg aus der Schweiz nach Aachen wurde auf dem Weg noch ein Zwischenstopp eingelegt beim <em>Creux du Van</em> und die beeindruckende Felsformation umwandert.</p>\n\n<p><img src=\"../../assets/img/blog/2022/2022-rueckweg-wanderung.jpg\" alt=\"Creux du Van\" /></p>\n\n<h4 id=\"internationales-finale-in-frankreich\">Internationales Finale in Frankreich</h4>\n\n<p>Auch nach Frankreich ist am 25. Mai eine kleine Vertretung des Roboterclubs gefahren.\nDa nach wie vor der aufwendige Greifarm nicht verbaut war, wurde die Integration der IMU im Wettkampf getestet.\nEine einfache Kombination aus der Position der Ultraschall-Baken](/projekt/ultraschall-baken.html)\nund die Orientierung der IMU führte zu einer deutlichen Verbesserung der Fahrweise des Roboters als zuvor.\nDadurch konnten einfache Aufgaben in fast Wettbewerbsspielen erledigt, sodass auch die Punkteschätzung der Roboterstrategie korrekt war.</p>\n\n<h4 id=\"deutschland\">Deutschland</h4>\n\n<p>Weil aus Deutschland nur drei Teams bereit waren, war kein nationaler Vorentscheid nötig.\nDa bei den Teams jedoch trotzdem Bedarf nach einem Zusammentreffen bestand wurde entschieden einen Wettbewerb im späten Sommer (8./9. Oktober 2022) in Aachen auszurichten.\nDazu gibt es <a href=\"/eurobot-2022/\">hier mehr Informationen</a>.</p>\n"
      },
   
      {
        "title"    : "The Rules for Eurobot 2022 are published",
        "category" : "",
        "tags"     : " eurobot, saison22",
        "url"      : "/blog/2021/rules-eurobot-2022.html",
        "date"     : "September 18, 2021",
        "excerpt"  : "<p>The new theme for Eurobot 2022 is “Age of Bots”. There are many actions for the Robots to do and many parts to move.\nWe are already brainstorming and looking forward to exiting games.</p>\n",
        "content"  : "<p>The new theme for Eurobot 2022 is “Age of Bots”. There are many actions for the Robots to do and many parts to move.\nWe are already brainstorming and looking forward to exiting games.</p>\n\n<p>The rules are published on the <a href=\"https://www.eurobot.org/\">website of eurobot.org</a>.</p>\n\n<p><img src=\"/assets/img/blog/2016/phobos_in_castle.jpg\" alt=\"Phobos in castle\" /></p>\n"
      },
   
      {
        "title"    : "µMotor 2 - Teil 4: Strom- und Spannungsmessung mit ADC",
        "category" : "",
        "tags"     : " elektronik, saison20",
        "url"      : "/blog/2020/micro-motor-2-teil-4.html",
        "date"     : "January 31, 2020",
        "excerpt"  : "<p>Over the past few weeks, a circuit diagram for the Micro-moto version 2 has been created from the previous considerations.\nAfter some productive reviews and discussions about the schematic and the incorporation of various improvements and changes, a board layout was drawn in KiCad.</p>\n",
        "content"  : "<p>Over the past few weeks, a circuit diagram for the Micro-moto version 2 has been created from the previous considerations.\nAfter some productive reviews and discussions about the schematic and the incorporation of various improvements and changes, a board layout was drawn in KiCad.</p>\n\n<p>The production of the board was sponsored by Aisler and after only about a week of waiting the boards and all components arrived in our lab.</p>\n\n<p>Quickly two boards were assembled and except for one single solder bridge successfully soldered in the reflow oven.\nOnly the (optional) vertical Micro-USB connector had been forgotten when ordering the components, but this was no problem, since programming via SWD is more convenient for testing due to its debugger interface.</p>\n\n<p>Step by step, power supply, STM32 microcontroller, status LEDs and gate drivers including MOSFET power stage were tested successfully. Everything worked on the first try, for once.</p>\n\n<p>The development process of the micro-motor can be followed up <a href=\"/blog/2019/micro-motor-2-teil-3.html\">in</a> <a href=\"/blog/2019/micro-motor-2-teil-2.html\">several</a> <a href=\"/blog/2019/micro-motor-2-teil-1.html\">older</a> <a href=\"/blog/2018/micro-motor-debugging-inbetriebnahme.html\">blog posts</a>.</p>\n\n<p>The next step is to bring the current and voltage measurement into operation.\nFor this purpose we document in this blog post the requirements and development of the implementation with the analog-to-digital converter of the STM32G4 microcontroller.</p>\n\n<h2 id=\"requirements\">Requirements</h2>\n\n<ul>\n  <li>ADC sampling synchronous to PWM of motor (approx. 100kHz)</li>\n  <li>Sampling on every PWM cycle</li>\n  <li>For all phases either current or voltage are measured: current on both “switched” phases, voltage on the “high-impedance” phase</li>\n  <li>Measure current in both phases simultaneously</li>\n  <li>Additional ADC measurements at low priority and with low frequency\n    <ul>\n      <li>Motor supply voltage</li>\n      <li>3.3V supply voltage (Vbat)</li>\n      <li>NTC temperature sensor</li>\n      <li>Internal temperature</li>\n    </ul>\n  </li>\n</ul>\n\n<h3 id=\"adc-channel-usage-on-the-micro-motor\">ADC channel usage on the micro-motor</h3>\n\n<table>\n  <thead>\n    <tr>\n      <th>Measurement</th>\n      <th>Possible ADC channels</th>\n      <th>Gpio pin</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>Current U</td>\n      <td>Adc1Ch1, Adc2Ch1</td>\n      <td>GpioA0</td>\n    </tr>\n    <tr>\n      <td>Current V</td>\n      <td>Adc1Ch2, Adc2Ch2</td>\n      <td>GpioA1</td>\n    </tr>\n    <tr>\n      <td>Current W</td>\n      <td>Adc1Ch4</td>\n      <td>GpioA3</td>\n    </tr>\n    <tr>\n      <td>Voltage U</td>\n      <td>Adc1Ch15, Adc3Ch12</td>\n      <td>GpioB0</td>\n    </tr>\n    <tr>\n      <td>Voltage V</td>\n      <td>Adc2Ch4</td>\n      <td>GpioA7</td>\n    </tr>\n    <tr>\n      <td>Voltage W</td>\n      <td>Adc2Ch3</td>\n      <td>GpioA6</td>\n    </tr>\n    <tr>\n      <td>Motor supply voltage</td>\n      <td>Adc2Ch12</td>\n      <td>GpioB2</td>\n    </tr>\n    <tr>\n      <td>3.3V supply voltage</td>\n      <td>Adc1Ch17, Adc3Ch17</td>\n      <td>N/A</td>\n    </tr>\n    <tr>\n      <td>NTC temperature sensor</td>\n      <td>Adc1Ch12, Adc3Ch1</td>\n      <td>GpioB1</td>\n    </tr>\n    <tr>\n      <td>Internal temperature</td>\n      <td>Adc1Ch16, Adc5Ch4</td>\n      <td>N/A</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"implementation\">Implementation</h2>\n\n<p>The three critical measurements will be sequenced as “Injected Conversions” and triggered by a event generated from the timer which generates the Motor-PWM.</p>\n\n<p>In an “Injected conversions sequence” (sequence length is limited to 4) each conversion has its own output data register.\nThus all conversion results can be easily read one after the other in the time until the next PWM cycle and no interrupts are needed.</p>\n\n<p>For every of the six valid commutation steps that define the state of the three MOSFET half bridges, a mapping to the ADC channels is predefined and applied during the commutation.</p>\n\n<p>Low-Priority measurements are sequenced in the ADCs “normal-mode” sequence and are triggered at a lower frequency (by another timer or manually from code).</p>\n"
      },
   
      {
        "title"    : "Umzug gemeistert",
        "category" : "",
        "tags"     : " saison20",
        "url"      : "/blog/2019/umzug.html",
        "date"     : "November 1, 2019",
        "excerpt"  : "<p>Für uns hieß einmal wieder: “Es ist Zeit, etwas Neues zu beginnen”.\nDarum haben wir unsere Sachen gepackt und sind umgezogen.\nIhr findet uns nun in der Melatener Straße 25 im zweiten Stock beim IHF.</p>\n",
        "content"  : "<p>Für uns hieß einmal wieder: “Es ist Zeit, etwas Neues zu beginnen”.\nDarum haben wir unsere Sachen gepackt und sind umgezogen.\nIhr findet uns nun in der Melatener Straße 25 im zweiten Stock beim IHF.</p>\n\n<p><img src=\"../../assets/img/raum-2021.jpg\" alt=\"Der neue Raum\" /></p>\n\n<p>Wir danken sehr herzlich dem Institut für Theoretische Informationstechnik unter der Leitung von Prof. Mathar\nund der langjährigen Herberge unter seinem Dach.</p>\n\n<h3 id=\"weitere-information-unter-kontakt\">Weitere Information unter: <a href=\"/kontakt/\">Kontakt</a></h3>\n"
      },
   
      {
        "title"    : "µMotor 2 - Teil 3: Microcontroller &amp; Stromversorgung",
        "category" : "",
        "tags"     : " elektronik, saison20",
        "url"      : "/blog/2019/micro-motor-2-teil-3.html",
        "date"     : "September 2, 2019",
        "excerpt"  : "<p>Als Teil der Entwicklung der zweiten Version des Micro-Motors findet nun die Auswahl des Microcontrollers statt.\nAußerdem geht es in diesem Blogpost um Komparatoren und die Stromversorgung.</p>\n",
        "content"  : "<p>Als Teil der Entwicklung der zweiten Version des Micro-Motors findet nun die Auswahl des Microcontrollers statt.\nAußerdem geht es in diesem Blogpost um Komparatoren und die Stromversorgung.</p>\n\n<p>Die bisherige Entwicklung des Motorcontrollers kann in <a href=\"/blog/2019/micro-motor-2-teil-2.html\">mehreren</a> <a href=\"/blog/2019/micro-motor-2-teil-1.html\">älteren</a> <a href=\"/blog/2018/micro-motor-debugging-inbetriebnahme.html\">Blogposts</a> nachgelesen werden.</p>\n\n<p>Die vorläufige Auswahl der Shuntverstärker ist fast abgeschlossen, siehe <a href=\"/blog/2019/micro-motor-2-teil-2.html\">Teil 2</a>.\nEbenso ist der Gatetreiber (<em>DRV832x</em>) gesetzt in der Version ohne Strommessverstärker und mit SPI-Interface (<em>DRV8320S</em> oder <em>DRV8350S</em> in Gehäuse <em>WQFN32</em>, 5x5mm²).\nAlso MOSFET soll der in Micro-Motor Version 1 bewährte N-Channel Dual-FET <em>FDMD8260L</em> (60V, 5.8mΩ) verwendet werden.</p>\n\n<p>Als nächste wichtige Komponente wird der Microcontroller ausgewählt.</p>\n\n<h3 id=\"microcontroller\">Microcontroller</h3>\n\n<p>Eher zufällig wurden wir auf die neue Microcontroller-Serie <em>STM32G4</em> von ST Microelectronics aufmerksam.\nIn <a href=\"/blog/2019/micro-motor-2-teil-1.html\">Teil 1</a> wurde der <em>STM32L432CC</em> als präferierter Microcontroller genannt, jedoch bietet die neue <em>STM32G4</em>-Serie, speziell der <em>STM32G474</em> (oder <em>STM32G473</em>, ohne High-Resolution-Timer) einige Vorteile:</p>\n\n<ul>\n  <li>Taktfreqenz bis zu 170MHz für Cortex-M4F und <strong>alle</strong> Peripherals (max. 80MHz bei <em>STM32L4</em>)</li>\n  <li>High-Performance Analog Peripherals\n    <ul>\n      <li>7x Komparator (<em>COMP</em>), 17ns Propagation delay, einstellbare Hysterese</li>\n      <li>5x ADC 12bit, 4MSPS, differenzielle Inputs verfügbar)</li>\n      <li>4x DAC 12bit, 1MSPS</li>\n      <li>6x Opamp mit GBP (Gain Bandwidth Product) von 13MHz (<em>OPAMP</em>)</li>\n    </ul>\n  </li>\n  <li>DSP (Rechenbeschleuniger) Funktionen für Trigonometrie und Filter (<em>CORDIC</em>, <em>FMAC</em>)</li>\n  <li>High-Resolution-Timer (<em>HRTIM</em>) mit 184ps Zeitauslösung</li>\n  <li>3x Advanced Motor Control Timer (<em>TIM1</em>, <em>TIM8</em>, <em>TIM20</em>)</li>\n</ul>\n\n<p>Die folgenden Bilder zeigen die für den Micro-Motor relevanten Features der <em>STM32G4</em>-Serie und stammen aus STs Präsentation “STM32G4 Mainstream MCUs Product Overview”.</p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/microcontrollers_STM32G4_series_product_overview__p10.png\" alt=\"Microcontrollers_STM32G4_series_product_overview.pdf, Seite 10\" /></p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/microcontrollers_STM32G4_series_product_overview__p11.png\" alt=\"Microcontrollers_STM32G4_series_product_overview.pdf, Seite 11\" /></p>\n\n<p><small>Quelle: <a href=\"https://www.st.com/resource/en/product_presentation/microcontrollers_stm32g4_series_product_overview.pdf\">https://www.st.com/resource/en/product_presentation/microcontrollers_stm32g4_series_product_overview.pdf</a></small></p>\n\n<p>Stand 2019/08 sind nur einige wenige Chips aus der <em>STM32G4</em>-Serie verfügbar, für den Micro-Motor kommen <a href=\"https://octopart.com/search?q=STM32G474CET6\"><em>STM32G474CET6</em></a> und <a href=\"https://octopart.com/search?q=STM32G473CET6\"><em>STM32G473CET6</em></a> im <em>LQFP48</em> Gehäuse in Frage.\nIm vom <em>STM32L433CCU</em> bekannten Gehäuse <em>UFQFPN48</em> stehen noch keine Chips zu Verfügung.\nDas Gehäuse <em>LQFP48</em> benötigt zwar mehr Platinenoberfläche als der <em>UFQFPN48</em>, allerdings sind bei letztem Gehäuse durch das Exposed Pad keine Durchkontaktierungen und Leiterbahnen unterhalb des Chips möglich, was den Platzvorteil unter Umständen aufwiegt.</p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/CubeMX_screenshot_STM32G474CE_201909.png\" alt=\"Mögliches Pinout des Microcontrollers STMG474CE, Screenshot aus ST CubeMX Software\" /></p>\n<center><small>Mögliches Pinout des Microcontrollers <i>STM32G474CE</i>, Screenshot aus ST CubeMX Software.</small></center>\n<p><br /></p>\n\n<p>Erfreulicherweise können die ADC- und Komparator-Eingänge zeitgleich genutzt werden, sodass hier keine unnötigen Pins verschwendet werden müssen.</p>\n\n<h3 id=\"komparator\">Komparator</h3>\n\n<p>Da der Komparator im Microcontroller integriert ist, werden keine dedizierten Komparatoren benötigt.\nDas spart viel Platz und reduziert die Komplexität des Platinenlayouts.</p>\n\n<h3 id=\"systemüberblick\">Systemüberblick</h3>\n\n<p>Durch die geänderte Auswahl des Microcontrollers ändert sich das Blockschaltbild geringfügig.</p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/Micro-Motor-V2-Block-diagram_201909.svg\" alt=\"Micro-Motor V2 Blockdiagram, aktualisiert 2019/09\" /></p>\n\n<h3 id=\"stromversorgung\">Stromversorgung</h3>\n\n<p>Die Logik, bzw. alle Komponenten außer den MOSFET-Halb-Brücken und dem Motor, werden über eine separate Spannungsschiene im Roboter mit 6V bis 7V versorgt.\nAus diesen 6V bis 7V müssen lokal 3.3V für den Microcontroller und weitere Elektronik, sowie 5V für Hall-Sensoren und Encoder erzeugt werden.\nDie Logik-Versorgungsspannung bleibt im Gegensatz zu Versorgungsspannung für den Motor bei einem Not-Aus bestehen.</p>\n\n<p>Um alle Komponenten auch ungünstigsten Situationen stabil mit Strom zu versorgen sind sowohl für 3.3V als auch für 5V Spannungsregler mit eine Ausgangsstrom von mindestens 200mA nötig.\nBeispielsweise der CAN-Transceiver <em>TCAN332</em> kann bei einem Bus Fault bis zu 180mA benötigen, auch in diesem Fall muss der Betrieb des Micro-Motors aufrecht erhalten werden.</p>\n\n<p>Der Gatetreiber <em>DRV832x</em>/<em>DRV835x</em> ist mit dem Suffix <em>R</em> erhaltlich, wo ein Schaltregler galvanisch getrennt ins das Gehäuse integriert ist.\nBeim <em>DRV832x</em> handelt es sich um den Buck-Regulator <a href=\"http://www.ti.com/product/LMR16006\">LMR16006X</a>, welcher bei Eingangsspannugen zwischen 4V und 60V ein Spannung zwischen 0,8V bis 60V bei 600mA bereitstellen kann.\nDer in den <em>DRV835x</em> integrierte Buck-Regler <a href=\"http://www.ti.com/product/LM5008A\">LM5008A</a> liefert 2.5V bis 75V bei 350mA bei Eingangsspannugen zwischen 6V und 95V.\nStatt im <em>WQFN32</em> (5x5mm²) Gehäuse kommt der Gatetreiber dann im <em>WQFN40</em> (6x6mm²) Gehäuse, benötigt also 11mm² mehr Platinenfläche zuzüglich der externen Spule, Kondensatoren und Widerständen.</p>\n\n<p>Das hochintegrierte Schaltwandler-Modul <a href=\"http://www.ti.com/product/TPS82150\">TPS82150</a> hat eine integrierte Spule und benötigt im <em>μSiL8</em> Gehäuse lediglich 8.4mm² Platinenfläche.\nZudem kann ein besseres Platinenlayout durch die flexible Platzierung ermöglicht werden.</p>\n\n<p>Für die Versorgung der empfindlichen analogen Elektronik könnte ein dedizierter LDO-Wandler hinter dem 5V Schaltwandler eingesetzt werden, fall ein LC-Filter eine ausreichend rauschfreie Spannungsversorgung ermöglicht.</p>\n\n<h4 id=\"rekuperation\">Rekuperation</h4>\n\n<p>Mit Hilfe von Rekuperation kann sowohl die Wärmeentwicklung im Micro-Motor, als auch die Batterie-Laufzeit des gesamten Roboters verbessert werden.\nEine Begrenzung der Rekuperationsleistung im Micro-Motor ist nicht vorgesehen, da dies zentral im BMS besser lösbar ist.</p>\n\n<h4 id=\"überspannungsschutz\">Überspannungsschutz</h4>\n\n<p>TVS-Dioden an dem Logik- und Motor-Versorgungsspannungen müssen so ausgelegt werden, dass die auf Micro-Motor vorhandenen Spannungsregler bzw. andere direkt verbundenen Bauteile nicht beschädigt werden können.\nUm Rekuperation mit hoher Effizienz zu ermöglichen sollte die Clamping Voltage so hoch wie möglich gewählt werden.</p>\n"
      },
   
      {
        "title"    : "µMotor 2 - Teil 2: Strommessung",
        "category" : "",
        "tags"     : " elektronik, saison20",
        "url"      : "/blog/2019/micro-motor-2-teil-2.html",
        "date"     : "August 30, 2019",
        "excerpt"  : "<p>In diesem Blogpost geht es um die Weiterentwicklung des Motorcontrollers “Micro-Motor” zur Version 2.\nDie bisherige Entwicklung des Motorcontrollers kann in <a href=\"/blog/2019/micro-motor-2-teil-1.html\">mehreren</a> <a href=\"/blog/2018/micro-motor-debugging-inbetriebnahme.html\">älteren</a> <a href=\"/blog/2018/micro-motor-motorcontroller.html\">Blogposts</a> nachgelesen werden.</p>\n",
        "content"  : "<p>In diesem Blogpost geht es um die Weiterentwicklung des Motorcontrollers “Micro-Motor” zur Version 2.\nDie bisherige Entwicklung des Motorcontrollers kann in <a href=\"/blog/2019/micro-motor-2-teil-1.html\">mehreren</a> <a href=\"/blog/2018/micro-motor-debugging-inbetriebnahme.html\">älteren</a> <a href=\"/blog/2018/micro-motor-motorcontroller.html\">Blogposts</a> nachgelesen werden.</p>\n\n<p>Von den im <a href=\"/blog/2019/micro-motor-2-teil-1.html\">vorherigen Blog-Post</a> aufgelisteten Shuntverstärkern sind die beiden Bauteile von Analog Devices (ehem. Linear Technologie) und Texas Instruments in die nähere Auswahl gekommen.\nEs wurden von TIs INA240 Muster bestellt mit Gain 50 und 200, sowie Gain 20 und 50 beim LT1999, da bei diesem keine Variante mit Gain über 50 verfügbar ist.</p>\n\n<p>Als Shunt dient ein 5mΩ 1W 1% SMD-Widerstand in Baugröße 0805 (<a href=\"https://octopart.com/tlr2attd5l00f-koa+speer-27701192\">KOA Speer TLR2ATTD5L00F</a>).\nDurch die kleine Bauform ist ein kompakter Aufbau gewährleistet, wie in den Datenblättern empfohlen (<a href=\"https://www.analog.com/media/en/technical-documentation/data-sheets/1999fd.pdf\">LT1999</a> Seite 16 bzw. <a href=\"http://www.ti.com/lit/ds/symlink/ina240.pdf\">INA240</a> Seite 27).</p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/Versuchsaufbau-LT1999.jpg\" alt=\"Shuntverstärker Versuchsaufbau\" /></p>\n\n<p>Der weitere Messaufbau besteht aus einem <a href=\"/blog/2019/alpha-motor-description.html\">Motor-Controller</a> über welchen Frequenz und Duty-Cycle eingestellt werden können.\nAls Last dient ein 2kW Lastwiderstand mit 9,4Ω nach Ground, wodurch ein Strom von maximal 2,1A bei 20V durch den Shunt fließen.\nDie Induktivität des Aufbaus ist leider nicht bekannt, das keine geeigenten Messgeräte zur Verfügung standen.</p>\n\n<p>An den folgenden Messungen ist leicht zu erkennen, dass der LT1999 in unserem Fall ungeeignet zur Strommessung In-Phase ist.\nDer durch die Common-Mode-Spannungsänderung erzeugte Spike am Ausgang ist größer als das erwartete Mess-Signal,\ngerade bei kleinen Duty-Cycles (&lt;10%) verschwindet der Messwert hier vollständig.</p>\n\n<p>Der Shuntverstärker INA240 eignet zur Strommessung In-Phase, hier ist kein störender Einfluss der Common-Mode-PWM-Signals auf den Ausgang zu beobachten.\nDie Variante INA240A4 mit Gain 200 kann mit einem 5mΩ Shuntwiderstand nur etwa 2A messen, der Messbereich von 10A beim INA240A2 (Gain 50) ist für den Motorcontroller besser geeignet.\nDenkbar wäre es natürlich auch einen kleineren Shuntwiderstand zu wählen, jedoch würde dies aufgrund von stärkeren Einkoppplungen wahrscheinlich schlechtere Ergebnisse liefern.</p>\n\n<p>Auf den Osziloskop-Bildern ist in Gelb der Ausgang des Shuntverstärkers zu sehen.\nAuf Kanal 2 (Blau) ist die Spannung an der Motor-Phase beziehungsweise über dem Last-Widerstand dargestellt.</p>\n\n<h2 id=\"duty-cycle-30\">Duty-Cycle 30%</h2>\n\n<h3 id=\"in-phase\">In-Phase</h3>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/LT1999-20_In-Phase_160kHz_0uH.jpg\" alt=\"Shuntverstärker Messung: LT1999, Gain 20, In-Phase, 160kHz, 0µH\" /></p>\n<center>LT1999, Gain 20, In-Phase, 160kHz, 0µH</center>\n<p><br /></p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/LT1999-50_In-Phase_160kHz_0uH.jpg\" alt=\"Shuntverstärker Messung: LT1999, Gain 50, In-Phase, 160kHz, 0µH\" /></p>\n<center>LT1999, Gain 50, In-Phase, 160kHz, 0µH</center>\n<p><br /></p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/INA240-A2_In-Phase_160kHz-30.bmp\" alt=\"INA240A2, Gain 50, In-Phase, 160kHz, 30%, (negativer Ausschlag, 20V)\" /></p>\n<center>INA240A2, Gain 50, In-Phase, 160kHz, 30%, (negativer Ausschlag, 20V)</center>\n<p><br /></p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/INA240-A2_In-Phase_160kHz-30_12V.bmp\" alt=\"INA240A2, Gain 50, In-Phase, 160kHz, 30%, (negativer Ausschlag, 12V -&gt; 1A)\" /></p>\n<center>INA240A2, Gain 50, In-Phase, 160kHz, 30%, (negativer Ausschlag, 12V -&gt; 1A)</center>\n<p><br /></p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/INA240-A4_In-Phase_160kHz-30_12V.bmp\" alt=\"INA240A4, Gain 200, In-Phase, 160kHz (negativer Ausschlag, 12V -&gt; 1A)\" /></p>\n<center>INA240A4, Gain 200, In-Phase, 160kHz (negativer Ausschlag, 12V -&gt; 1A)</center>\n<p><br /></p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/INA240-A4_In-Phase_160kHz-30.bmp\" alt=\"INA240A4, Gain 200, In-Phase, 160kHz (negativer Ausschlag)\" /></p>\n<center>INA240A4, Gain 200, In-Phase, 160kHz (negativer Ausschlag)</center>\n<p><br /></p>\n\n<!--\n![Shuntverstärker Messung: LT1999, Gain 50, In-Phase, 160kHz, 0µH](../../assets/img/blog/micro-motor/shuntverstaerker-messungen/LT1999-50_In-Phase_160kHz.jpg)\n<center>LT1999, Gain 50, In-Phase, 160kHz, 0µH</center><br />\n\n![Shuntverstärker Messung: LT1999, Gain 50, In-Phase, 80kHz, 0µH](../../assets/img/blog/micro-motor/shuntverstaerker-messungen/LT1999-50_In-Phase_80kHz.jpg)\n<center>LT1999, Gain 50, In-Phase, 80kHz, 0µH</center><br />\n-->\n\n<h3 id=\"low-side\">Low-Side</h3>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/LT1999-20_Low-Side_160kHz_0uH.jpg\" alt=\"Shuntverstärker Messung: LT1999, Gain 20, Low-Side, 160kHz, 0µH\" /></p>\n<center>LT1999, Gain 20, Low-Side, 160kHz, 0µH</center>\n<p><br /></p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/LT1999-50_Low-Side_160kHz.jpg\" alt=\"Shuntverstärker Messung: LT1999, Gain 50, Low-Side, 160kHz, 0µH\" /></p>\n<center>LT1999, Gain 50, Low-Side, 160kHz, 0µH</center>\n<p><br /></p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/INA240-A2_Low-Side_160kHz-30.bmp\" alt=\"INA240A2, Gain 50, Low-Side, 160kHz, 30%, (positiver Ausschlag, 20V)\" /></p>\n<center>INA240A2, Gain 50, Low-Side, 160kHz, 30%, (positiver Ausschlag, 20V)</center>\n<p><br /></p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/INA240-A2_Low-Side_160kHz-30_12V.bmp\" alt=\"INA240A2, Gain 50, Low-Side, 160kHz, 30%, (positiver Ausschlag, 12V -&gt; 1A)\" /></p>\n<center>INA240A2, Gain 50, Low-Side, 160kHz, 30%, (positiver Ausschlag, 12V -&gt; 1A)</center>\n<p><br /></p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/INA240-A4_Low-Side_160kHz-30_12V.bmp\" alt=\"INA240A4, Gain 200, Low-Side, 160kHz (positiver Ausschlag, 12V -&gt; 1A)\" /></p>\n<center>INA240A4, Gain 200, Low-Side, 160kHz (positiver Ausschlag, 12V -&gt; 1A)</center>\n<p><br /></p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/INA240-A4_Low-Side_160kHz-30.bmp\" alt=\"INA240A4, Gain 200, Low-Side, 160kHz (positiver Ausschlag)\" /></p>\n<center>INA240A4, Gain 200, Low-Side, 160kHz (positiver Ausschlag)</center>\n<p><br /></p>\n\n<!--\n![Shuntverstärker Messung: LT1999, Gain 50, Low-Side, 160kHz, 10µH](../../assets/img/blog/micro-motor/shuntverstaerker-messungen/LT1999-50_Low-Side_160kHz_10uH.jpg)\n<center>LT1999, Gain 50, Low-Side, 160kHz, 10µH</center><br />\n\n![Shuntverstärker Messung: LT1999, Gain 50, In-Phase, 160kHz, 10µH](../../assets/img/blog/micro-motor/shuntverstaerker-messungen/LT1999-50_In-Phase_160kHz_10uH.jpg)\n<center>LT1999, Gain 50, In-Phase, 160kHz, 10µH</center><br />\n-->\n\n<h2 id=\"duty-cycle-5\">Duty-Cycle 5%</h2>\n\n<h3 id=\"in-phase-1\">In-Phase</h3>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/LT1999-20_In-Phase_160kHz-5.bmp\" alt=\"LT1999, Gain 20, In-Phase\" /></p>\n<center>LT1999, Gain 20, In-Phase</center>\n<p><br /></p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/LT1999-50_In-Phase_160kHz-5.bmp\" alt=\"LT1999, Gain 50, In-Phase\" /></p>\n<center>LT1999, Gain 50, In-Phase</center>\n<p><br /></p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/INA240-A2_In-Phase_160kHz-5.bmp\" alt=\"INA240A2, Gain 50, In-Phase\" /></p>\n<center>INA240A2, Gain 50, In-Phase</center>\n<p><br /></p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/INA240-A4_In-Phase_160kHz-5.bmp\" alt=\"INA240A4, Gain 200, In-Phase\" /></p>\n<center>INA240A4, Gain 200, In-Phase</center>\n<p><br /></p>\n\n<h3 id=\"low-side-1\">Low-Side</h3>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/LT1999-20_Low-Side_160kHz-5.bmp\" alt=\"LT1999, Gain 20, Low-Side\" /></p>\n<center>LT1999, Gain 20, Low-Side</center>\n<p><br /></p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/LT1999-50_Low-Side_160kHz-5.bmp\" alt=\"LT1999, Gain 50, Low-Side\" /></p>\n<center>LT1999, Gain 50, Low-Side</center>\n<p><br /></p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/INA240-A2_Low-Side_160kHz-5.bmp\" alt=\"INA240A2, Gain 50, Low-Side\" /></p>\n<center>INA240A2, Gain 50, Low-Side</center>\n<p><br /></p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/INA240-A4_Low-Side_160kHz-5.bmp\" alt=\"INA240A4, Gain 200, Low-Side\" /></p>\n<center>INA240A4, Gain 200, Low-Side</center>\n<p><br /></p>\n"
      },
   
      {
        "title"    : "µMotor 2 - Teil 1: Konzept",
        "category" : "",
        "tags"     : " elektronik, saison20",
        "url"      : "/blog/2019/micro-motor-2-teil-1.html",
        "date"     : "August 18, 2019",
        "excerpt"  : "<p>In diesem Blogpost geht es um die Weiterentwicklung des Motorcontrollers “Micro-Motor” zur Version 2.\nDie bisherige Entwicklung des Motorcontrollers kann in <a href=\"/blog/2019/alpha-motor-description.html\">mehreren</a> <a href=\"/blog/2018/micro-motor-debugging-inbetriebnahme.html\">älteren</a> <a href=\"/blog/2018/micro-motor-motorcontroller.html\">Blogposts</a> nachgelesen werden.</p>\n",
        "content"  : "<p>In diesem Blogpost geht es um die Weiterentwicklung des Motorcontrollers “Micro-Motor” zur Version 2.\nDie bisherige Entwicklung des Motorcontrollers kann in <a href=\"/blog/2019/alpha-motor-description.html\">mehreren</a> <a href=\"/blog/2018/micro-motor-debugging-inbetriebnahme.html\">älteren</a> <a href=\"/blog/2018/micro-motor-motorcontroller.html\">Blogposts</a> nachgelesen werden.</p>\n\n<p><img src=\"../../assets/img/blog/2018/micro-motor-faedeldraht.jpg\" alt=\"Makro-Aufnahme Micro-Motor Fädeldraht\" /></p>\n\n<p>Nachdem der einzige aufgebaute Prototyp des Micro-Motors beim Testen durch einen von einer Oszi-Probe verursachten Kurzschluss am Gatetreiber defekt war, wurde eine minimal modifizierte Schaltung als “Macro-Motor” auf einer größeren Platine aufgebaut um bequemer verschiedene Messungen durchführen zu können.</p>\n\n<p>Auch die Macro-Motor-Platine war leider nicht fehlerfrei. Unter anderem war leider der Footprint des neuen Spannungsreglers im WLCSP-6 (Wafer Level Chip Scale Package; 1x1,6mm²) spiegelverkehrt.\nEbenso war einer der beiden aufgebauten Prototypen nach dem Reflow-Löten nicht funktionsfähig, was auf durch von Hersteller zusätzlich verkleinerte Ausschnitte im Stencil verursachte zu geringe Menge an Lötpaste zurückzuführen war.\nBeim Versuch die nicht verlöteten Pins des Gatetreiber-ICs von Hand nachzulöten ist dieser leider zerstört worden.</p>\n\n<p>Unabhängig von den bisher aufgetretenen Problemen sind neue Wünsche entstanden.\nFür eine <a href=\"/projekt/motor-commutation.html\">intelligente Motor-Kommutierung</a> statt der bisher verwendeten stupiden Block-Kommutierung ist es teilweise nötig die Ström in den Phasen sowie auch die Spannung der Motorphasen zu messen.\nBessere Motor-Kommutierungen erlauben durch Sinus-förmige Ansteuerung mehr und gleichmäßigeres Drehmoment in sehr niedrigen Drehzahlbereichen zu erzeugen sowie auch Motoren ohne Hall-Sensoren anzusteuern.\nAußerdem wurde in der Saison eine präzise und zuverlässige Strommessung sehnlichst vermisst, sodass auch diese ein erklärtes Ziel ist.</p>\n\n<h3 id=\"systemüberblick\">Systemüberblick</h3>\n\n<p><img src=\"../../assets/img/blog/micro-motor/Micro-Motor-V2-Block-diagram_201907.svg\" alt=\"Micro-Motor V2 Blockdiagram\" /></p>\n\n<h3 id=\"komponentenauswahl\">Komponentenauswahl</h3>\n\n<p>Der Microcontroller wird nach bisheriger Planung ein STM32L433CCU im UFQFPN48 Gehäuse bleiben.</p>\n\n<p>Ebenso gibt es keinen Anlass den Gatetreiber <a href=\"http://www.ti.com/product/DRV8323\">DRV8323S</a> auszutauschen, da sich dieser durchgehend bewährt hat.\nEs wird jedoch die Variante ohne integrierte Shuntverstärker verwendet, da die Shuntverstärker ein zu geringes Gain-Bandbreiten-Produkt aufweisen und keine präzise Strommessung zulassen.</p>\n\n<p>Die Spannungswandler werden für 5V und 3,3V werden durch <a href=\"http://www.ti.com/product/TPS82150\">hochintegrierte Schaltwandler-Module</a> ersetzt,\nwelche sich schon beim <a href=\"/blog/2019/alpha-motor-description.html\">Alpha-Motor</a> bewährt haben und auch für leistungshungrige Encoder oder Endschalter genügend Strom liefern kann.</p>\n\n<p>Der bisher vorgesehene I²C-Temperatursensor <a href=\"http://www.ti.com/ww/eu/sensampbook/tmp006.pdf\">TMP006</a> (nicht mehr verfügbar)\nund die I²C-Anschlusspads für externe digitale Sensoren sollen durch einen analogen NTC-Temperatursensor ersetzt werden.\nEin NTC ist kompakter, günstiger, leichter am Motor zu befestigen und hat eine zur Überwachung der Motortemperatur ausreichende Genauigkeit.</p>\n\n<h4 id=\"shuntverstärker-und-komparator\">Shuntverstärker und Komparator</h4>\n\n<p>Neu auf der Liste der Bauteile sind dedizierte Shuntverstärker und Komparatoren.\nHier müssen die verfügbaren Bauteile noch analysiert und verglichen werden.\nEin gutes Rennen bei den Shuntverstärkern liefert aktuell der <a href=\"https://www.analog.com/en/products/lt1999.html\">LT1999</a> von Analog ab.</p>\n\n<p>Da die Strommessung “inline” in den Motorphasen stattfindet muss der Shuntverstärker eine sehr hohe Gleichtaktunterdrückung aufweisen.\nGleichzeitig ist eine hohe Bandbreite von etwa 500 kHz bis 1 MHz gefordert um bei einer PWM-Frequenz noch brauchbare Messwerte zu liefern.\nDie Gleichtaktspannung muss bis zu 24V betragen, außerdem ist neben einem hohen Gain, welcher die Verwendung von niederohmigen Shunt-Widerständen erlaubt, ein kleines Gehäuse gewünscht.</p>\n\n<p>Folgende Shuntverstärker stehen aktuell zur Auswahl:</p>\n\n<p><a href=\"https://www.analog.com/media/en/technical-documentation/data-sheets/1999fd.pdf\"><strong>LT1999</strong></a></p>\n<ul>\n  <li>Gain: Fixed 10, 20 or 50 V/V</li>\n  <li>CMRR: <strong>&gt;80dB @ 100kHz</strong> (V_CM=0V, 7VP-P, f=100kHz); &gt;96dB @ DC</li>\n  <li>Bandwidth: 2MHz</li>\n  <li>Package: MSOP-8</li>\n</ul>\n\n<p><a href=\"https://datasheets.maximintegrated.com/en/ds/MAX40056F-MAX40056U.pdf\"><strong>MAX40056</strong></a></p>\n<ul>\n  <li>Gain: Fixed 10, 20 or 50 V/V</li>\n  <li>CMRR: <strong>typ. 70dB @ 100kHz</strong> (100mV_AC Sine, f=100kHz); &gt;120dB @ DC</li>\n  <li>Bandwidth: 300kHz</li>\n  <li>Package: 2.02mm x 1.4mm WLP-8 and 8-pin μMAX</li>\n</ul>\n\n<p><a href=\"http://www.ti.com/lit/ds/symlink/ina240.pdf\"><strong>INA240</strong></a></p>\n<ul>\n  <li>Gain: Fixed 20, 50, 100 or 200 V/V</li>\n  <li>CMRR: <strong>typ. 93dB @ 50kHz</strong> (f=50kHz); &gt;120dB @ DC</li>\n  <li>Bandwidth: 400kHz</li>\n  <li>Package: TSSOP-8</li>\n</ul>\n\n<p>In den nächsten Wochen werden Samples dieser Chips unter den beim Micro-Motor herrschenden Umgebungsbedingungen getestet und dann ausgewählt.\nSollte sich keiner der verfügbaren Inline-Shuntverstärker als brauchbar erweisen, werden wir Low-Side-Shuntverstärker evaluieren.</p>\n\n<h3 id=\"formfaktor\">Formfaktor</h3>\n\n<p>Im Gegensatz zur Version 1 wird für die zweite Version ein anderer Ansatz gewählt.\nDer integrierte Magnet-Encoder fällt weg, stattdessen gibt es einen <del>gut lötbaren</del> steckbaren Anschluss für externe Encoder<del>, sowohl einfach als auch mit differenziellen Signalen</del>.\nDa durch die kleine Bauform des Micromotors keine langen Kabel zum Encoder nötig sind, wird auf differenzielle Signale verzichtet.\nSollte ein Motor keinen integrierten Encoder haben, kann ein <a href=\"https://github.com/roboterclubaachen/magnet-motor-encoder\">externer magnetischer Encoder</a> auch über dieses Interface angeschlossen werden.</p>\n\n<p>Die Platine bekommt eine rechteckige Form und soll seitlich an den Motoren befestigt werden.\nSo lässt sich der Micro-Motor flexibler an einer Vielzahl von verschiedenen Motoren nutzen.\nDie mechanischen Dimensionen werden sich kaum ändern, angepeilt ist eine Platinenfläche von weniger als 500mm², z.B. 15x25mm².\nDazu wird auch weiterhin eine beidseitige Bestückung notwendig sein.</p>\n\n<h3 id=\"stecker\">Stecker</h3>\n\n<p>Um einen einfach Austausch der Platinen zu ermöglichen sollen keine Kabel fest auf der Platine verlötet werden.\nEs werden sechs Steckverbindungen benötigt:</p>\n<ul>\n  <li>Motor-Anschluss (Phasen U, V, W), 3-polig, &gt;=5A</li>\n  <li>Stromversorgung (20V, 6V und GND), 3-polig, &gt;= 5A</li>\n  <li>CAN Kommunikation (CAN-H, CAN-L), 2- oder 3-polig</li>\n  <li>End-/Referenz-Schalter, 2- oder 3-polig</li>\n  <li>Hall-Sensor (Hall-Phasen U, V, W; GND und 5V/3.3V), 5-polig</li>\n  <li>Encoder (A, B, I; GND und 5/3.3V), 5-polig</li>\n</ul>\n\n<p>Für die leistungsführenden Steckverbinder soll 3-polige <a href=\"https://jst.de/product-family/show/184/xh\">JST XH</a> Stecker verwenden werden.\nDiese sind bis 5A nutzbar, bei höhreren Strömen müssen die Kabel fest verlötet werden und Stecker ins Kabel integriert werden.</p>\n\n<p>Die Signalstecker sollen als 2-/3-polige und 5-polige <a href=\"https://jst.de/product-family/show/89/gh\">JST GH</a> Stecker ausgeführt werden.\nEbenso wie die Leistungsstecker mit 2.5mm Pitch sind diese die Stecker auch in SMT-Bauform erhältlich und bei einem Pitch von 1.25mm deutlich kompakter.</p>\n\n<h3 id=\"weitere-entwicklung\">Weitere Entwicklung</h3>\n\n<p>Noch mehr Probleme und Verbesserungsvorschläge der ersten Revision sind im <a href=\"https://github.com/roboterclubaachen/micro-motor/issues\">Github Issue #1</a> aufgeführt.</p>\n\n<p><em>Der Blog-Post wurde ursprünglich am 27.7.2019 verfasst und zuletzt am 18.8.2019 aktualisiert.</em></p>\n"
      },
   
      {
        "title"    : "Review of Season 2019",
        "category" : "",
        "tags"     : " saison19",
        "url"      : "/blog/2019/Season-2019.html",
        "date"     : "July 25, 2019",
        "excerpt"  : "The preparations started in October 2018, with the publication of the new rules. This years Season were mainly characterized by electrical engineering and software. Due to a stronger generation change within our team, ...",
        "content"  : "<p>This year’s topic in the Eurobot, organized by Planete Sciences from France, was Atom Factory.\nIn short, it was about manipulating ice hockypuks, the so-called atoms.\nThe tasks ranged from simply moving the atoms to grabbing, weighing and sorting them.</p>\n\n<p><img src=\"../../assets/img/blog/2019/eurobot-competition-2019.jpg\" alt=\"Eurobot competition 2019\" /></p>\n\n<p>The preparations started in October 2018, with the publication of the new rules.\nThis years Season was mainly characterized by electrical engineering and software.\nDue to a stronger generation change within our team, there was an enormous loss of knowledge about the technology of the previous years.\nIn order to become competitive again, new members were acquired and trained.\nThe resulting projects were then to flow into this year’s robot.\nTogether for example a new motor driver, our so-called Alphamotor, was developed, optimized and used.\nThe hurdles to be taken here were often not possible without hours of troubleshooting and improvements, which, however, had to be followed by a deeper examination of the matter.\nFurthermore, a completely newly developed positioning system based on ultrasound was used for the first time.\nThis was developed together with a former member of the club and then integrated into our hardware abstraction and communication framework.\nMeanwhile some of our robots software structure got a bigger rework, which seems to be not done yet</p>\n\n<p>But a lot has also changed mechanically in this season.\nThus a complex cartesian working gripper mechanism was designed and built, which can move to all positions necessary for the game with only one arm.\nThe well-proven drive concept was also replaced by an Omiwheel drivetrain for technical and practical reasons.\nThis makes it possible to drive in any direction without changing the alignment of the robot.\nThe necessary mathematical transformations as well as the implementation of these were also done in a very short time.\nThe result at the time of the competitions was a completely new construction, build by members, who compensated the loss of knowledge driven by outgoing members with the learning process during the season.\nSo the club is competitive again.</p>\n\n<p><img src=\"../../assets/img/blog/2019/eurobot-team-in-giessen.jpg\" alt=\"RCA Team im Gießen\" /></p>\n\n<p>In the now following competitions we first went to Gießen from 02.05 to 04.05 this year, where the German preliminary decision for the international competition took place.\nThere, a total of 7 teams from all over Germany competed to reach the first to third place, for which the international competition will continue.\nFortunately our robot homologated and was ready for the competition.\nMany sleepless nights and smoking heads should pay off, so our Team took the 2nd place behind TURAG from Dresden.\nThirdly, the Greenbirds team from Ludwigshafen managed to qualify for the international competition.\nAt the end of May we went from 29.05. to 01.06. to La Roche-Sur-Yon in France.\nThere the national and international competition with nearly 300 French teams took place.\nThe again best 3 teams from France were then also qualified for the international competition.\nA total of 33 teams competed in the international competition.\nIt started with five preliminary rounds in which the aim was to collect the most points.\nThe best 8 teams from these preliminary rounds were then ready to enter the final.\nUnfortunately, we had big problems with our new positioning system to reach defined points and even night-long improvements helped only little to change anything about it.\nTherefore it was only enough for us to finish as 29th Team this year. The Eurobot was won by Team PMG Robotics from Serbia.\nDespite the sobering result, the members are proud of what they achieved in the short time and motivated to give everything to win the Eurobot in the upcoming season.</p>\n\n<p><img src=\"../../assets/img/blog/2019/eurobot-team-in-france.jpg\" alt=\"RCA Team im La-Roche-sur-Yon\" /></p>\n"
      },
   
      {
        "title"    : "Alpha-Motor: Ein neues Motorboard",
        "category" : "",
        "tags"     : " elektronik, saison19",
        "url"      : "/blog/2019/alpha-motor-description.html",
        "date"     : "May 9, 2019",
        "excerpt"  : "In der Saison 2019 ist unsere Elektronik fast vollständig überarbeitet oder sogar neu entwickelt. Eine der Neuentwicklungen ist unser neues Motorcontrol-Board, genannt Alpha-Motor.",
        "content"  : "<p>In der Saison 2019 ist unsere Elektronik fast vollständig überarbeitet oder sogar neu entwickelt.\nEine der Neuentwicklungen ist unser neues Motorcontrol-Board, genannt Alpha-Motor.\nDer Name bricht mit dem Schema, das vorher verwendet wurde: Auf den <em>iMotor</em> folgte der <em>2Motor</em>, wiederum gefolgt vom <em>3Motor</em>.\nDer Alpha-Motor kann anders als sein direkter Vorgänger nur zwei DC- oder BLDC-Motoren antreiben.\nDafür wurden mehrere Features hinzugefügt, die den Roboter leistungsfähiger und besser kontrollierbar machen.\nDie wohl wichtigste Änderung betrifft die Ausgangsstufen.\nWo vorher vollintegrierte Chips verwendet wurden, sitzen nun simple Motortreiber-ICs (MIC4606), die Leistungstransistoren steuern.\nDie Leistungsabgabe kann mit diesem simpleren Design verdoppelt werden, da Abwärme besser abgestrahlt wird. Für ein proof-of-concept der neuen Bauelemente wurde ein Testboard entwickelt.</p>\n\n<p><img src=\"../../assets/img/blog/alpha-motor/AlphaMotor_Testboard.jpg\" alt=\"Alpha-Motor Testboard\" /></p>\n\n<p>Hier ist bereits zu sehen, dass die Ansteuerung nicht sehr komplex ist, da einfach ein Timer des Mikrocontrollers über drei komplementäre Ausgänge einen Motor steuern kann.\nDie Verwendung einer SPI-Verbindung oder ähnlichem um mit den Endstufen zu kommunizieren entfällt.\nEs ist jetzt noch leichter die Kontrolle zu behalten, da eine neue Strommessung für jeden Motor hinzugefügt wurde, die mit 1 MHz Abtastrate den Strom durch die Schaltbrücken begrenzen kann.\nDer Spannungsabfall über einen Shunt-Widerstand wird in einem Komparator mit der frei verstellbaren Vorgabe verglichen und das Ergebnis auf den asynchronen Break-Input des Mikrocontrollers gegeben.\nDas Ergebnis ist eine effektive Stromregelung.\nZusätzlich wird in jeweils zwei der drei Phasen die Stromstärke mit Hall-Sensoren gemessen, um eine sinusförmige Kommutierung statt einer einfacheren blöckförmigen zu ermöglichen.\nDie Hauptaufgabe der Schaltung wird jetzt also besser erfüllt, ohne auf Funktionalität verzichten zu müssen.</p>\n\n<p><img src=\"../../assets/img/blog/alpha-motor/AlphaMotor_Haupt.jpg\" alt=\"Alpha-Motor Platine\" /></p>\n\n<p>Neben der Steuerung von Motoren, ist der Alpha-Motor wie sein Vorgänger das Gehirn des Roboters.\nÜber zwei CAN-Busse werden die Befehle vom Master-Board zu den Slaves geschickt und eine serielle Schnittstelle und einen SWD-Port (Serial-Wire-Debug) kommuniziert mit unserem Debugger, über den nicht nur Events geloggt werden können, sondern der Roboter auch over-the-air neue Software erhält.\nDa weiterhin der gleiche Mikrocontroller verwendet wird, ist grundsätzlich die Verwendung zusammen mit älteren Boards möglich um im Notfall eine Ausweichmöglichkeit zu haben.</p>\n\n<p><img src=\"../../assets/img/blog/alpha-motor/AlphaMotor_Antrieb.jpg\" alt=\"Antrieb mit Alpha-Motor Platinen im Roboter &quot;Marie&quot;\" /></p>\n"
      },
   
      {
        "title"    : "µMotor: Inbetriebnahme und Debugging",
        "category" : "",
        "tags"     : " elektronik, saison19",
        "url"      : "/blog/2018/micro-motor-debugging-inbetriebnahme.html",
        "date"     : "October 6, 2018",
        "excerpt"  : "<p>Die Idee zur Entwicklung des <a href=\"/blog/2018/micro-motor-motorcontroller.html\">µMotors</a> ist schon älter.\nDamals, als die Auswahl der Komponenten noch geschah, wurde im RCA fast zeitgleich auch der größere Bruder des µMotors, der Alpha-Motor, entworfen.</p>\n",
        "content"  : "<p>Die Idee zur Entwicklung des <a href=\"/blog/2018/micro-motor-motorcontroller.html\">µMotors</a> ist schon älter.\nDamals, als die Auswahl der Komponenten noch geschah, wurde im RCA fast zeitgleich auch der größere Bruder des µMotors, der Alpha-Motor, entworfen.</p>\n\n<p>Beim Design der Leistungselektronik fiel die Wahl des MOSFET-Gatetreibers auf den <a href=\"http://ww1.microchip.com/downloads/en/DeviceDoc/20005604B.pdf\">MIC4606</a> in Kombination mit den <a href=\"https://www.vishay.com/docs/68550/sqjb40ep.pdf\">SQJB40EP</a> MOSFETs von Vishay.\n(Vielen Dank an dieser Stelle an Vishay für das unkomplizierte und schnell zur Verfügung stellen von Samples.)</p>\n\n<p>Um die Eignung der ausgewählten Komponenten zu verifizieren wurde eine Testplatine entworfen, welche außerdem eine schöne und lehrreiche Aufgabe für zwei neue, bisher nicht mit dem Platinendesign vertrauten Mitgliedern des Roboterclubs darstellte.\nDie Testplatine enthielt neben den MOSFET-Treibern und MOSFETs selbst nur Stecker, Testpunkte, die nötige passive Beschaltung aus Widerständen und Kondensatoren sowie die Spannungsversorgung.</p>\n\n<p><img src=\"../../assets/img/blog/2018/alpha-motor-testboard.jpg\" alt=\"Testplatine für MIC4606\" /></p>\n\n<p>In Kombination mit einem Entwicklungs-Board für Microcontroller, in unserem Fall das [STM32F4Discovery], wurde die Ansteuerung von DC und BLDC Motoren erfolgreich getestet.</p>\n\n<p>Dadurch wurde der MIC4606 Chip für den Alpha-Motor ausgewählt und war auch für den Micro-Motor vorgesehen.\nIm Laufe der weiteren Komponentenauswahl für den Micro-Motor stellten sich die mechanischen Dimensionen des Chips allerdings als zu groß heraus und der <a href=\"http://www.ti.com/lit/ds/symlink/drv8323.pdf\">DRV8323</a> Gate-Treiber bot einen insgesamt kleineren Footprint.\nDer Chip selbst ist größer (6x6mm² WQFN zu 4x4mm² QFN), allerdings wird deutlich weniger externe Beschaltung (u.A. keine Gate-Serienwiderstände, keine Bootstrap-Kondensatoren) benötigt und drei Strommessverstärker sind direkt integriert.</p>\n\n<p>Der DRV8323 ist zugleich auch wesentlich komplexer als des MIC4606, statt einer <a href=\"https://de.wikipedia.org/wiki/Bootstrapping_(Elektrotechnik)\">Bootstrap-Schaltung</a> zur Ansteuerung der High-Side-MOSFETs integriert der Chip eine <a href=\"https://de.wikipedia.org/wiki/Ladungspumpe\">Ladungspumpe</a> und viele Parameter wie Gate-Serienwiderstände, Überstom-Abschaltung und die integrierten Strommessverstärker lassen sich beim DRV8323 digital über ein SPI-Interface konfigurieren.</p>\n\n<p>Trotzdem wurde es nicht als nötig erachtet für den DRV8323 Chip eine simple Testplatine zu entwerfen, was sich im Verlauf als Fehlentscheidung herausstellte.</p>\n\n<p>Nervig wurde die Situation bereits beim Schreiben des <a href=\"https://github.com/modm-io/modm/pull/27\">modm.io-Treibers</a>.\nEs ist meist hilfreich mit einem Logic-Analyser oder Oszilloskop de SPI-Bus auf der Platine an Testpunkten abgreifen und beobachten zu können.\nLeider passten auf die Platine des Micro-Motors keine Testpunkte, manche der Leiterbahnen waren nicht einmal auf zugänglichen Außenlagen der Platine, sondern ausschließlich unter Chips und auf den Innenlagen geführt.\nSomit musste filigraner Fädeldraht an die kleinen Lötperlen an den Außenkanten der QFN/DFN-Pads des Chips anlöten werden um an diesem Fädeldraht dann die Signale mit Logic-Analyser und Oszilloskop ab zugreifen.</p>\n\n<p><img src=\"../../assets/img/blog/2018/micro-motor-faedeldraht.jpg\" alt=\"Makro-Aufnahme Micro-Motor Fädeldraht\" /></p>\n\n<p>Dabei wurde das erste Problem recht schnell deutlich: Die MISO-Leitung des DRV8323 ist ungewöhlicherweise als <a href=\"https://de.wikipedia.org/wiki/Open-Collector-Ausgang\">Open-Drain</a> und nicht wie üblich als <a href=\"https://de.wikipedia.org/wiki/Gegentaktendstufe\">Push-Pull-Stufe</a> ausgeführt, infolgedessen wird ein externer Pull-Up-Widerstand benötigt.\nUm diesen Widerstand einzusparen sollte der intern zuschaltbare <a href=\"https://de.wikipedia.org/wiki/Pull-up-Widerstand\">Pull-Up Widerstand</a> im STM32 Microcontroller genutzt werden.\nLeider ist der Widerstand dieses Pull-Ups (laut Datenblatt 30 Kiloohm bis 70 Kiloohm viel zu groß für die minimal konfigurierbare SPI-Frequenz (mehrere 100kHz) des STM32L433 Microcontrollers.\nFolglich musste neben dem Fädeldraht für die Messinstrumente noch ein 10 Kiloohm Pull-Up-Widerstand mit Fädeldraht nachgerüstet werden.\nDas Löten war schon fast zur Routine geworden, da sich der Fädeldraht in der Zwischenzeit mehrfach gelöst hatte.</p>\n\n<p><img src=\"../../assets/img/blog/2018/micro-motor-testaufbau.jpg\" alt=\"Micro-Motor Testaufbau mit zwei Oszilloskopen und zwei Netzteilen\" /></p>\n\n<p>In Endeffekt hat die vorhandene Hardware aber ihre Inbetriebnahme und die Software-Entwicklung unter Zusatzaufwand ermöglicht.</p>\n\n<p><img src=\"../../assets/img/blog/2018/qfn-dfn-pad.jpg\" alt=\"Makro-Aufnahme: Pad eines DFN/QFN-Chips\" /></p>\n\n<p>Bis letzte Woche ein merkwürdiges Verhalten der PWM-Waveform bei der Ansteuerung von BLDC-Motoren auftrat.\nZum lokalisieren des Fehlers wurden neben den Signalen an den Motorphasen auch die Signale der Gates vor und nach dem Gatetreiber betrachtet.\nAuch diese Signale sind nur an den seitlichen Pads von QFN-Chips ab zugreifen.\nDer Pad-Pitch beträgt hier 0,5 mm, also etwa gleich dem Durchmesser des Spitze der Oszilloskop-Probe.\nNatürlich rutschte die Spitze ab und verursachte einen Kurzschluss, welcher vom Gatetreiber mit erhöhten Stromverbrauch und Rauchentwicklung quittiert wurde.</p>\n\n<p>Schnell war die Entscheidung getroffen um weitere Zerstörung zu verhindern nun doch eine Testplatine für den DRV8323-Chip zu konstruieren.</p>\n\n<p>Da es für den verwendeten Microcontroller kein Entwicklungs-Board vom Hersteller gibt wurde dieser integriert, der Schaltplan ist daher fast identisch mit dem des Micro-Motors.\nDie Platinengröße wurde von einem Kreis mit Durchmesser von 20 mm auf ein Rechteck von 100 mm x 33 mm erweitert um Platz für die etwa 50 Testpunkte zu bieten.</p>\n\n<p><img src=\"../../assets/img/blog/2018/macro-motor-pcb.png\" alt=\"Macro-Motor Testplatine\" /></p>\n\n<p>Der Name ist entsprechend auch nicht weit von Micro-Motor entfernt gewählt: <em>Macro-Motor</em>.</p>\n\n<p>Dank der schnellen Platinenfertigung von Aisler reicht eine gute Woche Wartezeit aus, bis die neue Testplatine in unserer Werkstatt liegen wird.</p>\n"
      },
   
      {
        "title"    : "Saisonstart 2019",
        "category" : "",
        "tags"     : " eurobot, saison19",
        "url"      : "/blog/2018/saisonstart-2019.html",
        "date"     : "September 18, 2018",
        "excerpt"  : "<p>Am letzten Wochenende wurden die Regeln für die kommende Eurobot-Saison erstmals veröffentlicht.\nDas Regelwerk ist noch im Beta-Status, kann aber schon auf <a href=\"http://www.eurobot.org/eurobot/eurobot-2019/eurobot-2019-rules\">eurobot.org</a> gelesen werden.</p>\n",
        "content"  : "<p>Am letzten Wochenende wurden die Regeln für die kommende Eurobot-Saison erstmals veröffentlicht.\nDas Regelwerk ist noch im Beta-Status, kann aber schon auf <a href=\"http://www.eurobot.org/eurobot/eurobot-2019/eurobot-2019-rules\">eurobot.org</a> gelesen werden.</p>\n\n<p><img src=\"/assets/img/blog/2018/eurobot-2019-field.png\" alt=\"\" /></p>\n\n<p>Wir freuen uns schon auf die kreative Phase in den kommenden Wochen, wenn wir die Konzepte entwickeln und Anfangen Roboter zu konstruieren.</p>\n\n<h2 id=\"mitmachen\">Mitmachen</h2>\n\n<p>Die nächste Zeit ist ideal zum Einstieg für Interessenten.\nWir haben eine Menge <a href=\"http://www.roboterclub.rwth-aachen.de/mach-mit/\">Projekte</a> für die wir motivierte Studenten suchen, egal in welchem Semester oder Studiengang.</p>\n\n<p>Wenn wir dein Interesse geweckt haben, komme Dienstag abends bei unserem <a href=\"http://www.roboterclub.rwth-aachen.de/kontakt/\">wöchentlichen Meeting</a> vorbei und lerne uns kennen.</p>\n"
      },
   
      {
        "title"    : "µMotor",
        "category" : "",
        "tags"     : " elektronik, informatik, saison19",
        "url"      : "/blog/2018/micro-motor-motorcontroller.html",
        "date"     : "May 5, 2018",
        "excerpt"  : "Die Idee ist schon älter, aber nun haben wir uns an die Umsetzung gewagt:  Ein miniaturisierter Motorcontroller, welche dezentral direkt an jeden Motor verbaut wird...",
        "content"  : "<h2 id=\"idee\">Idee</h2>\n\n<p>Die Idee ist schon älter, aber nun haben wir uns an die Umsetzung gewagt:<br />\nEin miniaturisierter Motorcontroller, welche dezentral direkt an jeden Motor verbaut wird\nund nur an Strom und CAN-Bus angeschlossen werden muss.</p>\n\n<h2 id=\"anforderungen\">Anforderungen</h2>\n\n<p>Die Anforderungen haben wir in den letzten Jahren gesammelt:</p>\n<ul>\n  <li><del>2 Phasen (nur DC Motoren) oder</del> 3 Phasen (DC und BLDC Motoren)</li>\n  <li>ca. 10A pro Phase</li>\n  <li>20V Betriebsspannung (Akku) -&gt; 40V oder 60V Auslegung</li>\n  <li>Anschluss für Encoder mit AB(I)-Interface</li>\n  <li>optional Magnetencoder auf dem PCB</li>\n  <li>Anschluss für Hall-Sensor</li>\n  <li>Temperatursensor (kontaktlos auf dem PCB verlötet oder I²C)</li>\n  <li>Strommessung</li>\n  <li>LEDs für Software-Status &amp; Encoderstatus</li>\n  <li>Konfigurierbare ID (ggf. STM32-Hardware-ID)</li>\n  <li>Einfach lötbar und aufbaubar</li>\n  <li>Abmessungen: Rund, Grund-Ø 20mm (Namiki-Motoren: Ø 22mm)</li>\n</ul>\n\n<h2 id=\"komponentenauswahl\">Komponentenauswahl</h2>\n\n<p><img src=\"/assets/img/blog/micro-motor/umotor-pcb.jpg\" alt=\"Er ist uns beim Waschen leider etwas eingegangen. Funktioniert aber trotzdem noch.\" /></p>\n\n<p>Als nächsten Schritt mussten wir die Komponenten auswählen.\nDie Wahl des Mikrocontrollers fiel schnell und wenig überraschen auf einen STM32, konkret einen <a href=\"http://www.st.com/en/microcontrollers/stm32l433cc.html\">STM32L433CCU</a> im 7x7mm²-UFQFPN48 Gehäuse.\nGeeignete MOSFETs und MOSFET-Treiber auszuwählen gestaltete sich als deutlich komplizierter.\nEine große Herausforderung ist die kleine Baugröße von nur Ø 20mm.\nRecht schnell war klar, dass dies nur realisierbar ist mit Komponenten welche Reflow-Löten erfordern,\nsomit waren DFN-Gehäuse nicht mehr wie bei früheren Projekten im RCA unerwünscht.</p>\n\n<p>Das Anschluss ist ein 5-poliger Stecker mit CAN-Bus (2 Pins), Versorgungsspannung (12-40V), Logikspannung zu Versorgung des Controllers und natürlich Ground (GND).\nDie Logikspannung ist von der Versorgungsspannung getrennt, da letztere möglicherweise durch Not-Aus-Schaltkreise deaktiviert werden kann, wobei die Controller aktiv bleiben sollen.</p>\n\n<p>Schlussendlich haben wir nach wochenlanger Recherche den <a href=\"http://www.ti.com/product/drv8323\">DRV8323S</a> von Texas Intruments als MOSFET-Treiber ausgewählt.\nDie entscheidenden Merkmale neben dem kompakten 6x6mm²-40WQFN Gehäuse die geringe Anzahl der benötigten externen Widerstände und Kondensatoren sowie das SPI-Interface über welches alle Parameter konfiguriert werden können.\nEines der Parameter ist der Gate-Drive-Strom, dadurch können Widerstände in den Gate-Leitungen zu den MOSFETs entfallen.\nEin weiterer Vorteil ist die Ladungspumpe zur Ansteuerung der High-Side-MOSFETs welche 100% PWM-Dutycycle erlaubt in Kontrast zu Bootstrap-Schaltungen bei Alternativkomponenten.\nMit Shunt-Widerstände in zwei der drei Motor-Phasen, einem Shunt-Widerstand welche den Gesamtstrom misst und den drei integrierten Strom-Messverstärkern des Gatetreibers wird die Strommesssung und eine Cycle-by-Cycle Strombegrenzung realisiert.</p>\n\n<p>Die Wahl der MOSFETs fiel auf den Typ <a href=\"http://www.onsemi.com/PowerSolutions/product.do?id=FDMD8260L\">FDMD8260L</a>:</p>\n<ul>\n  <li>Zwei n-Channel MOSFETs im 3.3x5mm²-DFN12 Gehäuse</li>\n  <li>V_DS 60V, R_DSon 5.8 mΩ</li>\n  <li>I_D 40A (continuous max.)</li>\n</ul>\n\n<p>Aus der Rückseite befindet sich der Magnetencoder <a href=\"https://ams.com/AS5045\">AS5045B</a> von AMS,\nden wir vorher schon alleinstehend verwendet haben.\nFalls der Motor einen Encoder mitbringt kann dieser Chip nicht bestückt werden und stattdessen der Motorencoder über Lötpads unterhalb des Magnetencoder-Footprints angelötet werden.\nFür externe Motorencoder wurde zus#tzlich ein ansonsten nicht benötigter 5V-Spannungsregler vorgesehen.</p>\n\n<p>Daneben sind auf der Platine nur ein CAN-Bus-Transceiver (<a href=\"http://www.ti.com/product/tcan332\">TCAN332</a>) und Spannungsregler verbaut,\nwelche aufgrund der kleinen Bauform ausgewählt wurden.</p>\n\n<h2 id=\"schaltplan-und-layout\">Schaltplan und Layout</h2>\n\n<p><img src=\"/assets/img/blog/micro-motor/schematic-overview-screenshot.jpg\" alt=\"Schaltplanübersicht micro-motor (µMotor) in KiCad\" />\n<img src=\"/assets/img/blog/micro-motor/pcb-layout-screenshot.jpg\" alt=\"PCB Layout micro-motor (µMotor) in KiCad\" /></p>\n\n<p>Aus den Anforderungen und Überlegungen sind in den vergangenen Monaten Schaltpläne und ein kompaktes Platinenlayout entstanden.\nDas Platinenlayout ist 4-lagig ausgeführt, anders wäre die geforderte Bauform nicht umsetzbar gewesen.</p>\n\n<h2 id=\"aufbau-und-inbetriebnahme\">Aufbau und Inbetriebnahme</h2>\n\n<p>Der erste Aufbau mit Reflow-Ofen und die Inbetriebnahme gestalten sich als nicht trivial,\nweil es auf der winzigen Platine kaum möglich ist elektrische oder Software- Probleme mit Multimeter, Oszilloskop oder Logicanalyser zu debuggen.\nEinige Leitungen sind nur unter Bauteilen und auf den inneren Lagen geführt.</p>\n\n<p><img src=\"/assets/img/blog/micro-motor/pcb-assembled-before-reflow-onecent.jpg\" alt=\"micro-motor (µMotor) vor dem Reflow-Löten. Ein-Cent-Münze zum Größenvergleich.\" />\n<img src=\"/assets/img/blog/micro-motor/reflow-ofen.jpg\" alt=\"micro-motor (µMotor) im Reflow Ofen\" /></p>\n\n<p>Der erste und einzige aufgebaute Prototyp funktioniert weitgehend.\nder bisher einzige Hardwarefehler konnte mit Hilfe von Fädeldraht und einem zusätzlichen Widerstand behoben werden.</p>\n\n<h2 id=\"software\">Software</h2>\n\n<p>Die Software auf dem Mikrocontroller wird mit <a href=\"http://modm.io/\">modm</a> entwickelt.\nBisher sind die Hardware-Abstraktion (Board-Support-Package) und einige Testprogramme für die Inbetriebnahme der Hardware fertiggestellt.</p>\n\n<p>Die Hauptsoftware fehlt noch.</p>\n\n<p>Auf dem Microcontroller sollen frei konfigurierbare Pid-Regler und ggf. auch “Motor-mit-Endschalter”-Komponenten,\nwelche den Aktor parametrierbar initialisieren und verfahren können, das Interface nach außen bilden.</p>\n\n<p>Programiert werden muss der Micro-Motor über den 3D-gedruckten Programieradapter mit Federkontaktstiften.\nDer Adapter verfügt außerdem über eine Pin zum abgreifen der UART-Ausgabe zu Debug-Zwecken.</p>\n\n<p><img src=\"/assets/img/blog/micro-motor/swd-adapter.jpg\" alt=\"Programieradapter für den micro-motor (µMotor)\" /></p>\n\n<h2 id=\"ausblick\">Ausblick</h2>\n\n<p>In den nächsten Wochen werden wir die Hardware vollstandig testen, Software implementieren, Messungen vornehmen und Dokumentation schreiben.</p>\n\n<p>Zeitnah werden wir den Quellcode, Schaltplan, Platinenlayout und mechanische CAD-Modelle unter einer OpenSource Lizenz veröffentlichen.</p>\n\n<p>To be continued…</p>\n"
      },
   
      {
        "title"    : "Saisonstart 2018",
        "category" : "",
        "tags"     : " eurobot, saison18",
        "url"      : "/blog/2017/saisonstart-2018.html",
        "date"     : "October 23, 2017",
        "excerpt"  : "<p>Die Entwicklungsphase für die Saison 2018 ist gestartet.\nDieses Jahr steht der Eurobot unter dem Motto “Robot Cities”.</p>\n",
        "content"  : "<p>Die Entwicklungsphase für die Saison 2018 ist gestartet.\nDieses Jahr steht der Eurobot unter dem Motto “Robot Cities”.</p>\n\n<p><img src=\"/assets/img/blog/robo_antrieb.jpg\" alt=\"\" /></p>\n\n<p>Wir haben schonmal einen neuen Allradantrieb konstruiert, hilf uns mit ihn zu bauen.</p>\n"
      },
   
      {
        "title"    : "We are German champion 2017",
        "category" : "",
        "tags"     : " eurobot, saison17",
        "url"      : "/blog/2017/we-are-german-champion-2017.html",
        "date"     : "May 1, 2017",
        "excerpt"  : "<p>We are qualified for the international contest in France!</p>\n",
        "content"  : "<p>We are qualified for the international contest in France!</p>\n\n<p><img src=\"/assets/img/blog/2017/PR_Eurobot2017_Siegerfoto_Dresden.jpg\" alt=\"Eurobot 2017 Siegerfoto Dresden\" /></p>\n\n<p>Our robots, Juri and Siggi, won nearly every game at the German Eurobot contest 2018 in Dresden.\nThe competition was well organized by TURAG. Thank you for the great time!</p>\n\n<p><img src=\"/assets/img/blog/2017/Juri_Siggi_Rooftop_Back.jpg\" alt=\"Juri Siggi Rooftop Back\" /></p>\n\n<p>We would like to thank our sponsors and supporters for their generous backing.</p>\n\n<p><img src=\"/assets/img/blog/2017/Juri_Siggi_Rooftop_Front.jpg\" alt=\"Juri Siggi Rooftop Front\" /></p>\n"
      },
   
      {
        "title"    : "We are German champion 2016",
        "category" : "",
        "tags"     : " eurobot, saison17",
        "url"      : "/blog/2016/we-are-german-champion-2016.html",
        "date"     : "May 3, 2016",
        "excerpt"  : "<p>We are qualified for the international contest in France!\nOur robots, Hassel and Hoff, won every game at the German Eurobot contest 2016 in Stuttgart.</p>\n",
        "content"  : "<p>We are qualified for the international contest in France!\nOur robots, Hassel and Hoff, won every game at the German Eurobot contest 2016 in Stuttgart.</p>\n\n<p>The competition was well organized by VtAS. Thank you for the great time!</p>\n\n<p>We would like to thank our sponsors for their generous support.</p>\n\n<p><img src=\"/assets/img/blog/2016/Foto2016StuttgartCropped.jpg\" alt=\"RCA in Stuttgart 2016\" /></p>\n\n<p><img src=\"/assets/img/blog/2016/2016HasselHoff.jpg\" alt=\"Roboter Hassel und Hoff\" /></p>\n"
      },
   
      {
        "title"    : "The Rules for Eurobot 2016 are published",
        "category" : "",
        "tags"     : " eurobot, saison16",
        "url"      : "/blog/2015/rules-eurobot-2016.html",
        "date"     : "October 20, 2015",
        "excerpt"  : "<p>The new theme for Eurobot 2016 is “The Beach Bots”. There are many actions for the Robots to do and many parts to move. We are already brainstorming and looking forward to exiting games.</p>\n",
        "content"  : "<p>The new theme for Eurobot 2016 is “The Beach Bots”. There are many actions for the Robots to do and many parts to move. We are already brainstorming and looking forward to exiting games.</p>\n\n<p><img src=\"/assets/img/blog/2016/phobos_in_castle.jpg\" alt=\"Phobos in castle\" /></p>\n"
      },
   
   
   
     {
       
          "title"    : "Projekt: 3D-Drucker Octoprint",
          "category" : "Projekt",
          "tags"     : " software, 3d-druck",
          "url"      : "/projekt/3d-drucker-octoprint.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Einrichten und konfigurieren der Software Octoprint zum Betrieb des 3D-Druckers.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Der 3D-Drucker soll an einen Raspberry Pi angeschlossen werden, welcher mit der Software Octoprint [1] als Server fungiert und darüber den 3D-Drucker steuern kann.</p>\n\n<p>Primär soll das Drucken von den CAD-Workstations mit wenigen Klicks zu starten sein, ebenfalls ist es wünschenswert von jedem beliebigen PC oder Laptop Druckaufträge zu erteilen und zu überwachen.</p>\n\n<p>Weitere optional umsetzbare Features sind ein Touch-Display direkt am Drucker, eine Kamera-Überwachung im Druckergehäuse sowie eine gut sichtbare LED-Statusanzeige am Drucker.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Raspberry Pi</li>\n  <li>Linux</li>\n  <li>3D-Druck</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: 3dDrive",
          "category" : "Projekt",
          "tags"     : " mechanik",
          "url"      : "/projekt/3d-drive.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "3dDrive ist neues Konzept für ein Roboterfahrwerk, das in beliebige Richtung mit optimaler Beschleunigung fahren kann.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Der Differentialantrieb [1] ist der etablierte Stand der Technik im Eurobot.</p>\n\n<p>Beim Differentialantrieb werden zwei Räder auf gleicher Achse mit zwei Motoren separat angetrieben. Das Steuerprinzip ähnelt dem eines Panzers.\nNeben einfacher Steuerung und stabilem Fahrverhalten zeichnet sich der Differentialantrieb durch eine kompakte (abgeschlossene) Bauweise und die Möglichkeit, Odometrie für die Lokalisierung zu benutzen, aus.</p>\n\n<p>Da wir zur Zeit ein globales Positionierungssystem entwickeln, können auch Konzepte für neuartige Fahrwerke erprobt werden, z.B. 3dDrive. Bei dieser Antriebsart soll der Roboter drei Räder haben, die (ähnlich wie bei einem Einkaufswagen) frei verdreht werden können und angetrieben sind. Dadurch werden eine hohe Antriebsleistung und Manövrierfähigkeit erreicht.</p>\n\n<p>In Rahmen dieses Projektes soll das Konzept verfeinert und erforscht werden. Es sollen mögliche Wirkprinzipien und Implementierungen bewertet werden. Ein Prototyp soll konstruiert und aufgebaut werden.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>3 Motoren (2 Lenkung, 1 Antrieb)</li>\n  <li>Beschleunigung über 1g und Geschwindigkeiten bis 2.5 m/s</li>\n  <li>Modulare Bauweise</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>CAD Entwicklung und Konstruktion</li>\n  <li>CAM</li>\n  <li>Auslegung mechanischer, elektrischer und evtl. pneumatischer Komponenten</li>\n  <li>Entwicklung getriebetechnischer Komponenten für die Lenkung mit 2 Motoren</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Aktorik für den Roboter",
          "category" : "Projekt",
          "tags"     : " mechanik, 3d-druck",
          "url"      : "/projekt/aktorik.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Entwicklung und Konstruktion des Aufnahme und Lagersystems des Roboters für die Saison 2023.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Im Eurobot-Wettbewerb müssen die Roboter regelmäßig verschiedene Objekte greifen, transportieren und nach bestimmten\nKriterien anordnen. Dazu sind kreative mechanische Lösungen notwendig, um die Aufgaben mit möglichst hoher\nGeschwindigkeit und Zuverlässigkeit innerhalb des eingeschränkten Bauraums der Roboter zu erledigen.</p>\n\n<p>Die Spielelemente waren in der Vergangenheit z.B. lackierte Holzbauklötze, Kunststoff-Zylinder, Bälle in verschiedenen\nGrößen und Materialien, Puks, CDs, Becher, Textilien, Flaschen  und ähnliches. Ähnlich zu industriellen\nAutomatisieungsaufgaben mussten diese innerhalb der 100 Sekunden eines Spiels oft an einer Stelle des Spielfeldes\neingesammelt und an einer  anderen wieder abgelegt werden und dabei z.B. nach Größe oder Farbe sortiert, geschossen\noder gestapelt werden. Dabei ist es oft erstrebenswert, möglichst viele der Elemente in den Roboter zu laden und\ngemeinsam zu transportieren. Zum Handling können z.B. aktive oder passive Greifer, Walzen, Bänder, Ketten- oder\nSchienensysteme, Gebläse, Saugnäpfe, usw. verbaut werden.</p>\n\n<p>Aufgabe ist es nun, einen Roboterarm für die Manipulation und Aufnahme der Spielelemente sowie das zugehörige Lagerungssystem zu konstruieren. Dabei werden die Komponenten unter Beachtung des Regelwerks im CAD konstruiert. Im Nachgang an die Konstruktion findet die Fertigung statt. \nDas Projekt sollte von 2-4 Personen durchgeführt werden.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Erfinden von kreativen mechanischen Konzepten</li>\n  <li>CAD-Konstruktion mit Autodesk Inventor 2020</li>\n  <li>Fertigung von Aluminium- (mit CNC-Fräse) oder 3D-Druck-Teilen</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Aktuatorik Planung in ROS2 MoveIt",
          "category" : "Projekt",
          "tags"     : " mechanik, software, ROS2",
          "url"      : "/projekt/aktuatorik_planung_in_ros2_moveit.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Nutzen von MoveIt um die Aktuatorik im Roboter zu steuern und Greifoperationen zu standardisieren",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Die Aktuatorik im Roboter für die kommende Saison (greifen, sortieren, lagern, ablegen von Bechern) erfordert stets wiederkehrende Bewegungsabläufe.\nHinzu kommt die kollisionsfreie 3-DOF Planung für den SCARA Arm.</p>\n\n<p>Für die Planung und Überwachung dieser Bewegungsabläufe bietet sich das ROS package MoveIt an.\nMoveIt kann automatisch kollisionsfreie Trajektorien (inverse Kinematik) generieren.\nMit MoveIt können wiederkehrende Greifsequenzen für unterschiedliche Objekte/Positionen an die Trajektorien angefügt werden.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>C++ / Python Programmierung</li>\n  <li>Einarbeitung in das MoveIt Framework</li>\n  <li>Erstellung eines kinematischen Modells des Roboters</li>\n  <li>Erstellung des Robotermodells und Einteilung in sinnvolle Move Groups</li>\n  <li>Einbindung der Aktuatorikplanung in die weitere Robotersteuerung</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Alpha-Motor (V2)",
          "category" : "Projekt",
          "tags"     : " elektronik, pcb",
          "url"      : "/projekt/alpha-motor.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Alpha-Motor ist eine Platine zur Ansteuerung von zwei Antriebsmotoren. Die neue Version 2 soll vor allem eine präzisere Strombegrenzung und die Nutzung von Encodern mit differenziellen Ausgangssignalen ermöglichen",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Eines der wichtigsten Elemente in unserem Roboter nennen wir ganz bescheiden den Alpha-Motor. Der Alpha-Motor ist eine Platine die in erster Linie zwei Funktionen erfüllt: Ansteuerung und Regelung von ein bis zwei Motoren und das Auslesen von Encodern für die Odometrie.</p>\n\n<p>Jede Platine verfügt dazu über ein Setup, das sowohl DC-Motoren als auch dreiphasige Brushless-DC Motoren oder einen Mix der beiden unterstützt.\nVerbaut sind dementsprechend sechs Halb-Brücken aus jeweils zwei Leistungstransistoren, die von drei Brückentreibern kontrolliert werden.\nDas Herzstück ist dann der Mikrocontroller.\nDieser steuert nicht nur die genannten Brückentreiber, sondern liest auch die Motorencoder aus und kommuniziert über verschiedene Schnittstellen (vor allem CAN) mit dem Rest des Roboters, wobei ein paar GPIOs und Debug-LEDs natürlich auch nicht fehlen dürfen.\nZusätzlich wird durch den Mikrocontroller der Strom in den Motoren überwacht, was allerdings in Version 1 nur für sehr große Ströme funktionierte. Um in Zukunft auch kleine Ströme einstellen zu können, wie es zum Beispiel für eine akkurate Kraftregelung notwendig wäre, wurde für diese Version die Strommessung von Hall-Sensoren auf Instrumentenverstärker umgestellt. Das Problem war, dass die Gleichtaktunterdrückung nicht ausreichte, um schnell genug auf Änderungen im Spannungslevel zu regieren.</p>\n\n<h2 id=\"aufgabenstellung\">Aufgabenstellung</h2>\n\n<p>Der Schaltplan für den Alpha-Motor V2 ist bereits abgeschlossen, es fehlt allerdings noch alles, was aus diesem Plan eine echte Platine macht. Konkret sind folgende Aufgaben zu erledigen:</p>\n<ul>\n  <li>Layout einer 4-Layer Platine in KiCAD, Herausforderungen dabei sind die Anforderungen an Größe, Stromfestigkeit, Signalintegrität und EM-Verträglichkeit</li>\n  <li>Aufbau der gefertigten Platine, das heißt bestücken und anschließendes Reflow-Löten in unserem Ofen</li>\n  <li>Anpassen der bestehenden Software (C++) an den neuen Microcontroller, vor allem Änderungen in der Peripherie des verwendeten STM32</li>\n  <li>Und selbstverständlich testen, testen, testen</li>\n</ul>\n\n<p>Vorkenntnisse im PCB-Design oder Löten von Platinen sind natürlich von großem Vorteil, unbedingt erforderlich um diese Aufgaben zu erfüllen sind aber nur Grundkenntnisse in der Programmierung mit C++ und Grundkenntnisse der Schaltungstechnik.</p>\n\n<h2 id=\"technische-daten-alpha-motor-v2\">Technische Daten Alpha-Motor V2</h2>\n<ul>\n  <li>3 Phasen (DC und Brushless-DC Motoren)</li>\n  <li>ca. 20A pro Phase in der Spitze</li>\n  <li>20V Betriebsspannung (Akku) -&gt; 40V Auslegung</li>\n  <li>Mikrocontroller STM32G474 (vorher: STM32F407)</li>\n  <li>2x CAN-Bus mit 4 Steckern, 1 UART, (vorher:zusätzlich 1 SPI/I2C)</li>\n  <li>Anschlüsse für zwei (vorher: vier) AB-Encoder (vorher: inklusive UART 1-Wire)</li>\n  <li>Anschlüsse für 2 Hall-Sensoren</li>\n  <li>Strommessung und Strombegrenzung</li>\n  <li>LEDs für Software-Status &amp; Encoderstatus</li>\n  <li>Einfach lötbar und aufbaubar</li>\n  <li>Abmessungen: ca 50 x 80 mm²</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Aruco marker",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/aruco-marker.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Optische Aruco Tags sollen genutzt werden um unsere eigenen Roboter sowie gegnerische Roboter zu lokalisieren.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Die Position und Orientierung der Roboter auf dem Eurobot-Spielfeld soll mittels Bilderkennung und Aruco Markern bestimmt werden.</p>\n\n<p>Aufgrund der Anforderungen des Eurobot-Wettbewerbs wurden die Aruco-Tags hierzu ausgewählt, die vom Schiedsrichter jedem Roboter aufgesetzt werden.\nVerschiedene Tags können durch spezielle Muster, bei denen einzelne Felder ausgefüllt, codiert werden.</p>\n\n<p>Das Central Tracking Device kann dazu genutzt werden mit einer Kamera das Spielfeld zu überwachen.\nDieses kann auf eine erhöte Plattform am Spielfeld angebracht werden.\nDie Auswertung des Kamera-Bilds soll mittels OpenCV geschehen und die erkannten Positionen als ROS2-Topic bereit gestellt werden.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>Lokalisierung von eigenem und gegnerischem Roboter</li>\n  <li>Orientierung vor allen des eigenen Roboters</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Entwurf des (regelkonformen) Central Tracking Device</li>\n  <li>Software für eine Embeddedplattform oder mobile Computerplattform</li>\n  <li>Bildererkennung (OpenCV)</li>\n  <li>ROS2</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Automotive Ethernet",
          "category" : "Projekt",
          "tags"     : " elektronik, software, pcb",
          "url"      : "/projekt/automotive-ethernet.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "In den letzten Jahren ist Automotive Ethernet (100Base-T1) verfügbar geworden. Möglicherweise ist ein Einsatz als leistungsfähiger Ersatz für CAN in Robotern möglich.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Aus der von Broadcom vor mehreren Jahren entwickelten <em>BroadR-Reach</em>-Technologie ist inzwischen der Standard <em>100Base-T1</em> (IEEE 802.3bw [1]) geworden.\nÜber ein ungeschirmtes einfaches Twisted-Pair-Kabel können 100 MBit/s im Voll-duplex-Modus übertragen werden. Es werden keine großen induktiven Übertrager wie bei herkömmlichen 1000Base-T Ethernet benötigt, sodass Baugröße und Komplexität in Vergleich zum CAN-Bus nicht ändern.</p>\n\n<p>Eine höhere Datenübertragungsrate zwischen Hauptsteuerung und Motorreglern und Sensoren wird in Robotern für bessere Regelungen und bequemeres Analysieren und Debuggen benötigt.\nMöglicherweise ist <em>100Base-T1</em> Ethernet hier die Lösung.</p>\n\n<p>Inzwischen (2019) sind PHYs [2] von mehreren Herstellern kommerziell verfügbar, ebenso wie einzelne Switching-ICs.</p>\n\n<p>Nach einer eingehenden Studie der Literatur, Erstellung und Bewertung eines Kommunikationssystems basierend auf <em>100Base-T1</em> könnte ein Prototypenaufbau erfolgen, sowie später eine Integration in die bestehenden und neuen Elektronik-Komponenten.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>Ethernet mit 100Mbit/s (Vollduplex)</li>\n  <li>Netzwerk-Struktur: Stern, Point-to-Point oder Bus</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Marktrecherche</li>\n  <li>Konzeptionierung des Kommunikationssystems</li>\n  <li>Netzwerkdesign und Auslegung</li>\n  <li>Prototypenaufbau</li>\n  <li>Softwareintegration</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Biegebank",
          "category" : "Projekt",
          "tags"     : " mechanik, werkzeug",
          "url"      : "/projekt/biegebank.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Konstruktion und Fertigung einer Biegebank.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Der Roboterclub befindet sich im Besitz einer gut ausgerüsteten Werkstatt, um mechanische Teile für die Roboter zu fertigen. Dazu gehören z.B. eine CNC-Fräse und ein 3D-Drucker.</p>\n\n<p>Jedoch müssen gebogene bzw. gekantete Bleche, die eine hervorragende Stabilität, Freiformbarkeit und ein geringes Gewicht besitzen, mit Schraubstock, Hammer, Holz und anderen improvisierten Werkzeugen gefertigt werden. Dabei sind die Biegewinkel und die Kantenlängen stark begrenzt.</p>\n\n<p>Um die Fertigung gebogener Teile zu ermöglichen, soll eine Biegebank konstruiert und aufgebaut werden.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>Maximale Breite der Teile: 350mm</li>\n  <li>Mobil, z.B. durch eine einfache Klemmung am Tisch oder im Schraubstock</li>\n  <li>Ggf. verstellbare Blechdicke und Biegeradius</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>CAD-Konstruktion mit SolidWorks</li>\n  <li>Ggf. Rapid Prototyping mit 3D Drucker</li>\n  <li>Fertigung von Aluminium mit CNC-Fräse</li>\n  <li>Ggf. werkstofftechnische Auslegung.</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: CAN to X",
          "category" : "Projekt",
          "tags"     : " elektronik, pcb",
          "url"      : "/projekt/can-to-X.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Eine universale Platine, mit der verschiedenste Sensoren an den CAN-Bus angebunden werden können.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Viele Sensoren, die wir in den verschiedenen Robotern benötigen können ohne größeren Aufwand nicht direkt an den Roboter-CAN-Bus angeschlossen werden. Die CAN-to-X-Platine soll eine Anbindung vereinfachen. Das Herz der Platine wird ein STM32F303-Microcontroller, gepaart mit einem CAN-Transceiver. Zahlreiche Steckverbinder ermöglichen den Anschluss von Sensoren und anderer Peripherie.</p>\n\n<p>Hauptsächlich muss bei diesem Projekt flexible Software für den Microcontroller geschrieben werden, um z.B. I2C- oder aber SPI-Sensoren einfach anzubinden. Auch soll die Funkkommunikation mittels NRF24L01-Chipsatz mit dieser Platine möglich sein.</p>\n\n<h3 id=\"technische-daten\">Technische Daten:</h3>\n<ul>\n  <li>SPI</li>\n  <li>I2C</li>\n  <li>UART</li>\n  <li>CAN (Roboterclub-CAN)</li>\n  <li>Endschalter</li>\n  <li>LEDs</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Schaltplan-Entwurf</li>\n  <li>Platinendesign in KiCAD, Eagle oder Altium</li>\n  <li>SMD-Löttechnik</li>\n  <li>Software in C++, basierend auf modm.io</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: CI für Roboter-Software mit ROS2",
          "category" : "Projekt",
          "tags"     : " software, webentwicklung, werkzeug",
          "url"      : "/projekt/continous-integration-ros2.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Konzipieren und Programmieren eines CI-Service in GitLab für unsere Softwareprojekte und Anzeige auf einem Dashboard.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Die zukünftige Roboter-Software wird mit ROS2 geschrieben.\nIn der Vergangenheit hat es sich immer wieder bewährt auf Continuous Integration um eine hohe Software-Qualität zu gewähren\nund Zusammenarbeit möglichst frustfrei zu gestalten.</p>\n\n<p>Dazu brauchen wir einen sinnvollen und einfach zu benutzenden Continous Integration Service,\nder unsere Projekte in GitLab mindestens kompiliert und Unittests auswertet.\nEs sollen Docker Images gebaut werden um in Gitlab Pipelines [1] verwendet zu werden.\nUnter Umständen kann es sinnvoll sein die bestehende Gitlab-Core Installation auf die Premium-Variante zu aktualisieren,\nda diese weiter für CI relevante Features bietet.</p>\n\n<p>Dies ist besonders wertvoll, wenn der gesamte Setup mobil sein kann,\nsodass wir eine kleine Version dieses CIs zu Wettkämpfen mitnehmen können,\nbei denen es kein (oder sehr langsames) Internet gibt.</p>\n\n<p>Optional wäre es schön, zusätzlich ein kleines Dashboard zu haben, was auf einen Blick anzeigt, wie der Zustand unserer Softwareprojekte ist.\nDieses Dashboard darf auch sehr gerne physikalisch sein (Ampel, LED Streifen oder so).</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n\n<ul>\n  <li>ROS2</li>\n  <li>Software-Testing</li>\n  <li>GitLab CI Pipelines</li>\n  <li>Dashboard Programmierung</li>\n  <li>Docker Images</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: CI für unsere eingebettete Software",
          "category" : "Projekt",
          "tags"     : " software, webentwicklung, werkzeug",
          "url"      : "/projekt/continous-integration.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Konzipieren und Programmieren eines CI-Service in GitLab für unsere Softwareprojekte und Anzeige auf einem Dashboard.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Der Roboterclub hat viele eingebettete Softwareprojekte, deren Qualitäts-Zustand wir gerne im Blick behalten möchten.\nDazu brauchen wir einen sinnvollen und einfach zu benutzenden Continous Integration Service, der unsere Projekte in GitLab\nmindestens kompiliert und optional Unittests auswertet.\nEs sollen Docker Images gebaut werden um in GitLab Pipelines [1] verwendet zu werden.</p>\n\n<p>Dies ist besonders wertvoll, wenn der gesamte Setup mobil sein kann, sodass wir eine kleine Version dieses CIs zu Wettkämpfen \nmitnehmen können, bei denen es evtl. kein (oder sehr langsames) Internet gibt (*<em>hust</em>* in Frankreich *<em>hust</em>*).</p>\n\n<p>Es wäre schön, zusätzlich ein kleines Dashboard zu haben, was auf einen Blick anzeigt, wie der Zustand unserer Softwareprojekte ist.\nDieses Dashboard darf auch sehr gerne physikalisch sein (Ampel, LED Streifen oder so).</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n\n<ul>\n  <li>GitLab CI Pipelines</li>\n  <li>Dashboard Programmierung</li>\n  <li>Docker Images</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: CNC Fräse Aufarbeiten",
          "category" : "Projekt",
          "tags"     : " werkzeug, mechanik",
          "url"      : "/projekt/fraese-aufarbeiten.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Die CNC-Fräse wird samt Umhausung und Kühlschmiermittelkreislauf überholt.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Der Roboterclub ist im Besitz einer CNC-Fräse vom Typ Haase Cut 2500M [1] aus dem Jahr 2008.\nHiermit fräsen wir den Großteil der Bauteile für unsere Roboter aus Aluminium, Kunststoffen oder selten auch Holz.</p>\n\n<p>Die Umhausung der Fräse weist einige Probleme auf, welche behoben werden sollen, um in Zukunft bequemes und sicheres Fräsen mit hochqualitativen Ergebnissen zu ermöglichen.</p>\n\n<p>Desweiteren gibt es viele kleine Aufgaben:</p>\n<ul>\n  <li>Die Elektrik der Fräse soll in einen bereitliegenden Schaltschrank eingebaut werden</li>\n  <li>Für die Fräse liegt eine Werkzeuglängensensor bereit, welcher eingebaut und in der Software passend konfiguriert werden muss.</li>\n  <li>Der Filter im Kühlschmiermittelkreislauf ist schwer zugänglich, daher schwer zu leeren und zu klein. Daher soll der Kühlschmiermittelkreislauf konzeptionell überarbeitet werden und neu aufgebaut werden, wobei der Kühlschmiermittel-Durchfluss erhöht wird.</li>\n  <li>Ein Spritzschutz um den Fräser herum soll konstruiert und gebaut werden.</li>\n  <li>Das Gehäuse soll von innen vollständig mit 2K-EP-Harz abgedichtet werden.</li>\n  <li>Der Endschalter der X-Achse ist defekt und muss ersetzt werden.</li>\n  <li>Verbesserung der Aufspannvorrichtung für Platten.</li>\n  <li>Beschaffung oder Konstruktion und Bau eines Schraubstocks für kleine Bauteile.</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Holz- und Metallbearbeitung</li>\n  <li>LinuxCNC</li>\n  <li>Einweisung zur Bedienung der Fräse</li>\n  <li>Schaltschrank aufbauen</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Debugserver – Hardware",
          "category" : "Projekt",
          "tags"     : " elektronik, pcb",
          "url"      : "/projekt/debugserver-hardware.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Der Debugserver ist ein integrierter Raspberry Pi, um darüber kabellos die Roboter zu programmieren, zu debuggen, fernzusteuern und die Log-Ausgaben zu betrachten.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Ein den speziellen Anforderungen (s.u.) gerechtes Erweiterungsboard für einen RaspberryPi (“Pi HAT”) oder mit einem RaspberryPi Compute Module (CM3) [1] soll entworfen, geplant und aufgebaut werden.</p>\n\n<p>Der primäre Einsatzzweck ist der Debugserver, allerdings ist es auch denkbar, dass die Hardware für die Hauptsteuerung des Roboters genutzt wird.\nIn beiden Fällen ist absolute Zuverlässigkeit unerlässlich.</p>\n\n<p>Da die Anforderungen an mögliche Interfaces sich schnell ändern kann, wenn z.B. in Zukunft ein Laserscanner oder eine Kamera genutzt werden soll, sind viele universelle Anschlüsse am Board wünschenswert.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant):</h3>\n<ul>\n  <li>Raspberry Pi\n    <ul>\n      <li>Compute Module (CM3), Model 3 B+, Zero oder Zero W [2]</li>\n    </ul>\n  </li>\n  <li>WLAN 2.4GHz und 5GHz\n    <ul>\n      <li>Zwischen Client- und AccessPoint-Modus umschaltbar</li>\n    </ul>\n  </li>\n  <li>STM32-Microcontroller über SWD programmieren (z.B. per openOCD)</li>\n  <li>CAN-Interface (2x) mit MCP2515 (Linux Treiber)</li>\n  <li>UART-Interface (min. 1x; RX only) zum Empfangen der Logs vom Mikrocontroller</li>\n  <li>Echtzeituhr (RTC) für Linux-Systemzeit</li>\n  <li>Batterie-Backup\n    <ul>\n      <li>Verzögertes, kontrolliertes Herunterfahren</li>\n      <li>LiFe-Akku</li>\n      <li>Automatisches Akku-Laden über Roboter-Spannungsversorgung</li>\n    </ul>\n  </li>\n  <li>Minimales, intuitives Userinterface (LEDs, Schalter/Taster)</li>\n  <li>Kleine Baugröße</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>PCB Design (mit KiCAD)\n    <ul>\n      <li>EMV-gerechtes Design</li>\n    </ul>\n  </li>\n  <li>Recherche und Auslegung LiFe-Charger</li>\n  <li>Raspberry Pi und BCM2837</li>\n  <li>Reflow-Löten</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Debugserver – Softwarestack",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/debugserver-softwarestack.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Aufsetzten des Betriebssystems für den Raspberry Pi.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Der Debugserver (siehe Projekt “Debugserver Hardware”) basiert auf einem Raspberry Pi.\nAuf dem Raspberry Pi läuft ein Debian-basiertes Linux-System, dieses soll mittels <code class=\"language-plaintext highlighter-rouge\">debootstrap</code> [1],\nähnlich des Image-Builders [2] aufgesetzt werden um Reproduzierbarkeit zu gewährleisten.\nWeitere Alternativen: [3] und [4].</p>\n\n<p>Zusätzlich werden diverse Dienste auf dem Debugserver benötigt,\neine CAN-to-Network Brücke oder die Überwachung des Roboterzustandes anhand welcher der Debugserver ggf. heruntergefahren wird.\nJe nach Einsatz der zentralen Hardwareplattform wird ggf.  OpenOCD zum Programmieren des Mikrocontrollers benötigt.\nDiese Dienste müssen konfiguriert, beim Hochfahren automatisch gestartet und teilweise zuvor noch implementiert werden.\nEbenso muss die Netzwerkkonfiguaration mit der Möglichkeit zum Umschalten zwischen Client- und Accesspoint- Betrieb zuverlässig eingerichtet werden.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant):</h3>\n<ul>\n  <li>Debian Stretch (10) oder Fedora\n    <ul>\n      <li>ARMv7 (<em>armhf</em>) oder ARMv8 (<em>aarch64</em>)</li>\n    </ul>\n  </li>\n  <li>Reproduzierbarkeit der Betriebssystem-Images durch Nutzung von Debootstrap und Skripten zur Installation und Konfiguration der Software</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Linux: Debian (oder Fedora?)</li>\n  <li>Systemd</li>\n  <li>Debootstrap</li>\n  <li>Systemadministration</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Debugserver – Webmonitor",
          "category" : "Projekt",
          "tags"     : " software, webentwicklung",
          "url"      : "/projekt/debugserver-webmonitor.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Entwicklung einer Web-Oberfläche zur aufbereiteten Anzeige des Debug-Logs des Roboters.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Zum einfachen Debugging unserer Roboter-Software können im Programmcode der Microcontroller Log-Nachrichten erzeugt\nwerden, die per UART (serieller Schnittstelle) ausgegeben werden. Damit diese auch bei Testspielen ohne nervige Kabel\nzum Roboter verfolgt werden können, befindet sich auf den Robotern ein RaspberryPi Pi (der „Debugserver“), der unter\nanderem mit dem UART der Hauptplatine verbunden ist. Über eine Web-Anwendung soll der Log per WLAN anderen Computern mit\nWebbrowser zugänglich gemacht werden, wobei die Nachrichten in Echtzeit angezeigt und dabei grafisch aufbereitet\nwerden sollen.</p>\n\n<h3 id=\"geplante-features\">Geplante Features:</h3>\n<ul>\n  <li>Echtzeit-Anzeige der Log-Nachrichten (per Websocket oder AJAX-Polling)</li>\n  <li>Grafische Aufbereitung der Log-Nachrichten nach bestimmten Mustern (z.B. angegebene Softwarekomponente)</li>\n  <li>Modulare und dokumentierte Software zur einfachen Wartung und Erweiterung</li>\n  <li>Ggf. Filtern des Logs nach bestimmten Mustern (z.B. Zeitpunkt, Softwarekomponente, RegEx)</li>\n  <li>Aufzeichnung des Logs in eine Datei und Abruf alter Logs aus bestehenden Dateien</li>\n  <li>Ggf. Framework zur inhaltlichen Interpretation und übersichtlichen Darstellung bestimmter Nachrichtenformate,\nz.B. Übergänge in Zustandsautomaten, Plots von aufgezeichneten Werten, …</li>\n  <li>Ggf. Überwachung des Verbindungsstatus Browser → Debugserver, Debugserver → Microcontroller</li>\n  <li>Ggf. Funktionen wie Neustart, Programmieren des Microcontroller</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Dynamische Web-Entwicklung mit einfachem Server in Python oder Ruby oder NodeJS</li>\n  <li>Entwicklung einer komplexen Singlepage-Anwendung in Javascript/ECMA-Script</li>\n  <li>Kommunikation per SocketIO-Library o.ä.</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Driver",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/driver.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Entwicklung einer Softwarekomponente zur geregelten Ausführung von Fahrmanövern.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Damit sich unsere Roboter kontrolliert auf dem Spielfeld bewegen können, sind Software-Routinen nötig, die verschiedene\nFahrmanöver ausführen und regeln können. Daher soll es eine Software-Komponente geben, die solche Routinen enthält und\nvon anderen Komponenten über eine definierte Schnittstelle mit Fahrmanövern beauftragt werden kann. Dabei kann es\nsich um die Rotation auf einen bestimmten Winkel, des Verfolgens einer Gerade oder eines Kreisbogens, die\ngeradlinige Anfahrt auf einen definierten Punkt, usw. handeln. Je nach Bewegungsart sind dazu unterschiedliche\ngeometrische Berechnungen, Regelungskonzepte und Sicherheitsfunktionen nötig.</p>\n\n<h3 id=\"geplante-features\">Geplante Features:</h3>\n<ul>\n  <li>Einheitliches Interface für verschiedene Fahrmanöver und Rückmeldung über Status und Fehler</li>\n  <li>Einfaches Interface zum Abfahren von Routen (Sequenzen von Fahrmanövern)</li>\n  <li>Einfache Fahrmanöver: Punkt anfahren, Gerade folgen, Kreisbogen folgen, Rotation</li>\n  <li>Komplexere Fahrmanöver: Nach Abstandssensor fahren, …</li>\n  <li>Modulare Software (DRY – Don’t Repeat Yourself), Dokumentation der Konzepte und Schnittstellen</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Entwurf eines Software-Interfaces (in Abstimmung mit Entwicklern anderer Komponenten)</li>\n  <li>Entwicklung von Geometrieberechnungen und Positionsreglern</li>\n  <li>Softwareentwicklung in C++ oder Python mit ROS2</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Eurobot Score Estimation",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/eurobot-point-estimation.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Estimate the total scored point during a Eurobot match",
          "content"  : "<h2 id=\"summary\">Summary</h2>\n\n<p>The rules of the Eurobot contest define an opportunity to score up to 20% additional points after the match:\nThe robot has to estimate the number of points picked up during the game time.</p>\n\n<p>In the first step the actions completed by other components must be evaluated and the points aggregated.\nIn the next step, probabilities of possible failures can also be included and/or even the images from different cameras can be used for additional analysis.\nIn this way, points “stolen” by the opposing robot can be detected.</p>\n\n<h2 id=\"technologies\">Technologies</h2>\n<ul>\n  <li>ROS2 (Robot Operation System 2)</li>\n  <li>Software development in C++ or Python</li>\n  <li>Optional: OpenCV</li>\n  <li>Optional: “Big Data” analysis of past matches</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Eurobot Spielstrategie",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/eurobot-strategy.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Entwicklung und Implementierung einer Strategie-Komponente für den Eurobot-Wettbewerb",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Während eines Eurobot-Spiels müssen die Roboter verschiedene Aufgaben erledigen mit dem Ziel maximal viele Punkte zu erlangen.\nIm Rahmen diese Projekts sollen mehrere Komponenten entwickelt und implementiert werden, welche sowohl auf Level eines einzelnen Roboters, als auch global die Entscheidungen herbeiführen zu welchem Zeitpunkt welche Aufgaben von den Robotern erledigt werden sollen.\nHierbei müssen neben statischen Kriterien (beispielsweise: Punkteanzahl und Erfolgschance) auch sich dynamisch ändernde Kriterien beachtet werden, wenn eine Aktion etwa durch den gegnerischen Roboter mechanisch blockiert ist.</p>\n\n<p>Beide Roboter des eigenen Teams könnten sich gegenseitig blockieren und einige Aufgaben können nur kooperativ erledigt werden, sodass eine Koordination zwingend erforderlich ist.\nAußerdem beeinflussen Aktionen der gegnerischen Roboter den Spielverlauf, sodass hieraus auch reagiert muss kann um die spielentscheidenden Punkte zu erlangen.</p>\n\n<p>Weiterführend können Optimierungen z.B. durch verschiedene manuell vor Spielbeginn selektierbare Strategie-Optionen oder automatische Analyse vergangener Eurobot-Spiele (AI) ergänzt werden.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Modulare Software (DRY – Don’t Repeat Yourself), Dokumentation der Konzepte und Schnittstellen</li>\n  <li>Softwareentwicklung in C++ oder Python</li>\n  <li>ROS2 (Robot Operation System 2)</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Eurobot Wettbewerb gewinnen",
          "category" : "Projekt",
          "tags"     : " eurobot",
          "url"      : "/projekt/win-the-eurobot.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Selbstverständlich ist das oberste Ziel natürlich den Eurobot sowohl in Deutschland, mindestens einem weiteren Land als Gast und auf dem internationalen Finale in Frankreich zu gewinnen.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Einfach™ alles™ richtig™ machen™.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>Platzierung: 1. Platz</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Gewinnen</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Eurobot Wettbewerbsspielfeld aufbauen",
          "category" : "Projekt",
          "tags"     : " eurobot, mechanik",
          "url"      : "/projekt/spielfeld.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Um unserem eigene Roboter zu testen benötigen wir das Eurobot Spielfeld.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Das Spielfeld muss gemäß der Eurobot-Regeln aufgebaut werden, die Spielelemente müssen beschafft und angepasst werden.\nÜberwiegend muss sich dabei mir der Holzbearbeitung und Lackierung beschaftigt werden.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Holzbearbeitung</li>\n  <li>Konstruktion</li>\n  <li>Lackieren</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: FPGA Controller",
          "category" : "Projekt",
          "tags"     : " software, hardware, elektronik",
          "url"      : "/projekt/fpgas.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Eigene Implementierung von Logik-Peripherie im FPGA z.B. für Motor-Steuerung",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>FPGAs bieten die Möglichkeit Logik-Komponenten z.B. zur Ansteuerung von Motoren diskret und nach den eigenen Ansprüchen zu entwerfen und zu implementieren.</p>\n\n<p>Es gibt z.B. unter [1] bereits einige implementierte Komponenten, die zum Einstieg verwendet werden können.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>zunächst Möglichkeiten evaluieren\n    <ul>\n      <li>CAN Controller integrieren, der einen begrenzten Satz an Nachrichten verarbeiten kann\n        <ul>\n          <li>Motor-PWM setzen</li>\n          <li>Encoder zurückschicken</li>\n          <li>ggf. innersten Regler hier implementieren</li>\n          <li>Strommessung</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>Komplexere PWM-Generierung implementieren, testen\n    <ul>\n      <li>PWM Dithering (Erhöhung der PWM-Ausflösung)</li>\n      <li>Spread Spectrum PWM (geringe EMV-Störung)</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Implementierung von diskreter Logik in VHDL oder Verilog</li>\n  <li>Integration, Verifikation fertiger offener Implementierungen</li>\n  <li>Aufbauen von Test-Setups für Kommunikations-Interfaces, Tests mit Motor-Treiber</li>\n  <li>PCB-Design neuer Motor-Treiber</li>\n  <li>Beschaffen weiterer Eval-Boards</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Fahrplanung in ROS2",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/Fahrplanung_in_ROS2.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Da wir in den kommenden Jahren ROS2 verwenden, muss eine neue Fahrplanung geschrieben werden. Diese Fahrplanung kann z.B. auf den ROS2 Navigation Stack aufgebaut werden. ",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Da wir in den kommenden Jahren ROS2 verwenden, muss eine neue Fahrplanung geschrieben werden.\nDiese Fahrplanung kann z.B. auf den ROS2 Navigation Stack aufgebaut werden.</p>\n\n<p>Der ROS2 Navigation Stack kann automatisch Maps z.B. aus RVIZ einbinden und darin eine Trajektorie für einen Roboter generieren.\nDie Routenplanung sollte eine aktuelle Karte mit statischen und dynamischen Hindernissen berücksichtigen.\nUm aktuelle Hinderniskarten nutzen zu können sollten der Map Server aus dem Navigation Stack verwendet werden.</p>\n\n<p>https://github.com/ros-planning/navigation2</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>C++ / Python Programmierung</li>\n  <li>Einarbeitung in den ROS2 Navigation Stack</li>\n  <li>Arbeiten mit dem Map Server des Navigation Stack</li>\n  <li>Kollisionsfreie Routenplanung</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Fahrplattform Little",
          "category" : "Projekt",
          "tags"     : " mechanik",
          "url"      : "/projekt/fahrplattform-little.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Konstruktion und Fertigung der Fahrplattform des kleinen Roboters für die neue Saison (2019).",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Für unsere neuen Roboter für den Eurobot-Wettbewerb 2019 müssen Grundstruktur und Antrieb konstruiert und gefertigt\nwerden. Der kleine Roboter („Little“) soll mit einem Omnidrive-Antrieb [1] ausgerüstet werden. Durch diesen kann der\nRoboter sich in alle Richtungen bewegen. Die Grundkonstruktion wird aus einer gefrästen Aluminium-Bodenplatte bestehen,\nauf der die Lagerung der drei Omniwheels, die drei Antriebsmotoren, sowie der Aufbau des Roboters montiert werden.</p>\n\n<p>Im Gegensatz zu anderen Fahrplattformen sind keine Odometrieräder zur Positionsbestimmung vorgesehen. Stattdessen sollen\nUltraschall-Baken und ggf. eine IMU [2] zur Orientierung verwendet werden.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>Geschwindigkeit 2 m/s</li>\n  <li>Kraft 50 N</li>\n  <li>Leistung 100 Watt</li>\n  <li>Motoren: 3x Maxon EC-max 30, Getriebe: 1:4,8</li>\n  <li>soll über Kanten von 3 mm fahren können</li>\n  <li>Räder Ø 50 mm</li>\n  <li>Bodenplatte Dicke ca. 10 mm\n    <ul>\n      <li>Motoren darin teilweise versenkt</li>\n    </ul>\n  </li>\n  <li>Umfang (nach Regeln 2018)\n    <ul>\n      <li>Startumfang        850 mm</li>\n      <li>Dynamischer Umfang 1050 mm</li>\n    </ul>\n  </li>\n  <li>Omnidrive (3 Räder)</li>\n  <li>IMU (inertial measurement unit) / Beschleunigungs- und Lagesensor [2]</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>CAD-Konstruktion mit SolidWorks</li>\n  <li>3D-Druck zum Prototyping</li>\n  <li>Fertigung von Aluminium mit CNC-Fräse</li>\n  <li>Simulation der Fahrdynamik (z.B. mit Matlab Simulink)</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Fernsteuerungs-GUI",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/python-gui.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Entwicklung einer Python/Qt-GUI-Anwendung zur Fernsteuerung und Diagnose unserer Roboter.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Zum Testen der Software- und Hardware-Komponenten unserer Roboter soll eine GUI-Anwendung für den Computer entwickelt\nwerden, die über Netzwerk und CAN-Bus mit der Steuerung der Roboter kommuniziert und einzelne Funktionalitäten gezielt\naufrufen kann. Ebenso soll sie verschiedene Zustände und Signale des Roboters zur Überwachung anzeigen und grafisch\naufbereiten.</p>\n\n<p>Dazu muss zunächst eine Python-Anbindung an unser Roboter-internes Kommunikations-Protokoll XPCC implementiert und die\nstrukturierte Beschreibung der Nachrichtenformate auf ein Python-Typensystem abgebildet werden. Dann können\nGUI-Anwendungen geschrieben werden: einerseits solche, die unabhängig von konkreten Problemstellungen dynamisch aus\nder strukturierten Beschreibung der Software-Komponenten erzeugt werden. Diese dienen dazu, ohne weiteren Aufwand neue\nFunktionalitäten der Robotersoftware zu testen und können auch bei anderen XPCC-basierten Projekten eingesetzt werden.</p>\n\n<p>Andererseits soll es Anwendungen mit auf bestimmte Aufgaben spezialisierten Userinterfaces geben, z.B. zur Fernsteuerung\ndes Roboterantriebs und anderer Motoren, zur Anzeige von gemessenen Sensorwerten, zum Konfigurieren der Strategie und\nStarten von Spielen, zur grafischen Anzeige der gemessenen Positionen eigener und gegnerischer Roboter auf dem\nSpielfeld, usw.</p>\n\n<h3 id=\"technische-datenfeatures\">Technische Daten/Features:</h3>\n<ul>\n  <li>Software in (pure) Python 3.x ohne Codegenerierung oder eigene native Bibliotheken</li>\n  <li>Modulare Struktur und gute Dokumentation zur einfachen Entwicklung von Fernsteueranwendungen oder anderen\nSoftware-Komponenten</li>\n  <li>Kommunikation mit den Robotern über XPCC-Protokoll via ZeroMQ</li>\n  <li>Dynamische erzeugte generische Benutzeroberfläche zur Steuerung und Diagnose beliebiger Software-Komponenten mit\nbeliebigen Parameter-/Datentypen</li>\n  <li>Komfortable Editoren für bestimmte Nachrichtenformate, z.B. Positionen auf dem Spielfeld</li>\n  <li>Framework zum einfachen Anlegen Saison-/Aufgabenspezifischer Oberflächen</li>\n  <li>Grafische Oberfläche zur Fernsteuerung der Roboterantriebe und zusätzlicher Motoren</li>\n  <li>Grafische Oberfläche zum Start des Roboters und zur Überwachung des Spielverlaufs</li>\n  <li>Grafische Oberfläche zum Debuggen und Kalibrieren der Odometrie</li>\n  <li>Grafischer Busmonitor zum Anzeigen aller oder bestimmter Bus-Nachrichten, als Rohdaten und interpretierte Werte\n(Vorbild: Wireshark)</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Anwendungs-Entwicklung in Python 3.x</li>\n  <li>Entwicklung Grafischer Userinterfaces mit PyQt/Qt5</li>\n  <li>Auseinandersetzung mit den Software-Komponenten und der Kommunikation des Roboters</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Fiducial marker: RUNE",
          "category" : "Projekt",
          "tags"     : " pcb, software",
          "url"      : "/projekt/rune-tags.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Optische RUNE Tags sollen genutzt werden um unsere eigenen Roboter sowie gegnerische Roboter zu lokalisieren.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Die Position und Orientierung der Roboter auf dem Eurobot-Spielfeld soll mittels Bilderkennung und Fiducial Markern bestimmt werden.</p>\n\n<p>Aufgrund der Anforderungen des Eurobot-Wettbewerbs wurden die RUNE-Tags hierzu ausgewählt deren Detektion vergleichweise wenig Rechenaufwand bedeutet.\nDie RUNE-Tags bestehen aus 129 in drei konzentrischen Kreisen angeordneten Punkten.\nVerschiedene Tags können durch spezielle Muster, bei denen einzelne Punkte fehlen, codiert werden.</p>\n\n<p>Um eine bessere Störfestigkeit zu erreichen sollen die Punkte der RUNE-Tags mit LEDs realisiert werden.\nDurch Synchronisation mit dem Kamera-System mittels Gold-Code moduliertem Infrarot-Licht können die LEDs synchron zum Kamera-Shutter leuchten.\nDies führt zu weniger Blendung der Zuschauer und spart Energie.</p>\n\n<p>Die Auswertung des Kamera-Bilds soll mittels OpenCV geschehen und die erkannten Positionen als ROS2-Topic bereit gestellt werden.</p>\n\n<p>Bonus: Auf den 129 LEDs pro RUNE-Tag kann man auch noch weitere Informationen darstellen.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>Millimetergenaue Lokalisierung von eigenem und gegnerischem Roboter</li>\n  <li>Robuste Funktion auch bei schwierigen Lichverhältnissen</li>\n  <li>Synchronisation mit Kamera-System</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Bildererkennung (OpenCV)</li>\n  <li>ROS2</li>\n  <li>Schaltungs- &amp; PCB- Design (erster Prototyp vorhanden)\n    <ul>\n      <li>Software für Microcontroller mit modm.io</li>\n    </ul>\n  </li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Funk-Kommunikation XPCC-Backend",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/funk-komm-xpcc-backend.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Allgemeines und Standartisiertes XPCC-Backend über eine Funk-Schnittstelle.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Für die grundlegende Kommunikation innerhalb der RCA-Roboter wird ein CAN-Bus verwendet.\nUm weitere Komponenten –\nwie etwa einen zweiten Roboter oder Positionierungsbaken des Gegners –\neinzubinden, muss eine Funk-Schnittstelle verwendet werden.\nEine bestehende Lösung ist bislang beschränkt auf zwei Roboter als Kommunikations-Teilnehmer, die darüber nur grundlegende Informationen für ihre Spielstrategie austauschen.</p>\n\n<p>In diesem Projekt soll das XPCC-Protokoll, das zur CAN-Kommunikation verwendet wird,\num ein allgemeines Backend für eine Funk-Schnittstelle erweitert werden.\nDamit sollen beliebige externe Komponenten (zweiter Roboter, Gegnerbaken, externe Bildverarbeitung, etc.) eingebunden werden und ohne Mehraufwand komplexe Anwendungsdaten übertragen können.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Implementation der Funk-Kommunikation\n    <ul>\n      <li>Phy-Layer: NRF24L01</li>\n      <li>Data-Link-Layer: MAC-Layer mit R2MAC (teil von XPCC)</li>\n    </ul>\n  </li>\n  <li>Softwareentwicklung in C++ mit modm.io und XPCC für Microcontroller</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Funkkommunikation",
          "category" : "Projekt",
          "tags"     : " elektronik, pcb",
          "url"      : "/projekt/funkkommunikation.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Da in der kommenden Saison das erste mal ein Rechner die Steuerungsplattform werden soll muss eine alternative Funkkommunikation auf ggf. WLAN standards entwickelt werden.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Es soll eine Funkkommunikation für unsere Linux-Platform entwickelt werden. Hierbei kommt erschwerend dazu, dass der identische noch zu wählende Standard auch auf unseren kleineren STM32 basierten Boards\nzum Einsatz kommen soll. Hier sollen passende ICs gefunden werden, Kompatibilität mit kaufbaren USB-Adaptern untersucht werden und am Ende eine funktionierende Lösung stehen.</p>\n\n<h3 id=\"technische-daten\">Technische Daten:</h3>\n<ul>\n  <li>müssen noch definiert werden</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Systementwicklung</li>\n  <li>Funkkommunikation</li>\n  <li>Linux</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: High-Resolution Kamera",
          "category" : "Projekt",
          "tags"     : " pcb, software",
          "url"      : "/projekt/high-resolution-camera.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Nutzung von hochauflösenden Kamera-Modulen aus Smartphones an Raspberry Pi",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Es gibt viele Kamera-Module aus Smartphones günstig als Ersatzteil verfügbar, beispeisweise mit Sonys IMX576 Sensor mit 24 Megapixeln oder IMX686 mit 48 Megapixel.\nDiese Sensoren haben ein CSI-2 Interface mit 4 Lanes, über welches diese an Raspberry Pi (Compute Module, †) angeschlossen werden können.</p>\n\n<p>Seit 2020 gibt es auf der Raspberry Pi Plattform mit dem <em>bcm2835-unicam</em> Treiber und der dazugehörigen Dokumentation die Möglichkeit eigene Kamera-Sensor-Treiber zu schreiben.\nDies soll für den IMX576-Sensor passieren, da hier durch zwischenzeitlich öffentlich zugängliche Datenblätter und akzeptabel zu reverse-engineerbare Android-Treiber auch über den Sensor genügend Informationen verfügbar sind.</p>\n\n<p>†: Die CPU des Raspberry Pi hat 2 CSI-2 Interfaces mit 4 bzw. 2 Lanes, jedoch ist am Kamera-Stecker nur 1 Lane herausgeführt. Das Raspberry Pi CM4 macht alle Lanes zugänglich.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>Hochaulösendes Kamera-System aus einer oder mehreren Kameras</li>\n  <li>Gesamtauflösung &gt;100 Megapixel auf das Eurobot-Spielfeld (2x3 m² aus 1 m Entfernung)</li>\n  <li>Synchronisation mit Beleuchtung und RUNE-Tags</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Linux-Treiber schreiben (C)</li>\n  <li>Markt- und Datenblatt-Recherche</li>\n  <li>Schaltungs- &amp; PCB-Design</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Intelligente Motor-Kommutierung",
          "category" : "Projekt",
          "tags"     : " elektronik, software",
          "url"      : "/projekt/motor-commutation.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Entwicklung einer intelligenten Kommutierungsmethode für Bürstenlose Gleichstrommotoren.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Bei den zumeist verwendeten Elektromotoren handelt es sich um Bürstenlose Gleichstrommotoren (BLDC),\nwelche von einem externen Steuergerät angesteuert werden müssen.</p>\n\n<p>Dieses Steuergerät enthält neben der Leistungselektronik auch noch Logik welche das vom Motor benötigte rotierende Magnetfeld erzeugt.\nIm RCA werden dafür zur Zeit Alpha-Motoren der ersten Generation eingesetzt, die aber nicht über eine präzise Strommessung verfügen.\nDie neu-entwickelten Motortreiber der zweiten Generation (Alpha-Motor V2 und Micro-Motor V2) dagegen sollten neue Möglichkeiten bieten Motoren anzusteuern.</p>\n\n<p>Die einfachste und derzeit im RCA genutzte sogenannte Kommutierungsmethode ist die Block-Kommutierung.\nEs gibt Alternativen zur Block-Kommutierung, die u.a. Vorteile in den Punkten Kraft und Laufruhe bringen.\nZudem soll ein Ziel sein, auch Elektromotoren ohne Hall-Sensoren ansteuern zu können.\nDer Blog-Post [1] liefert hier ein erste Übersicht.</p>\n\n<p>Ziel diese Projektes ist die Evaluierung der Möglichkeiten sowie die Erstellung einer an die Bedürfnisse des RCA angepasste Simulation\nund idealerweise anschließende reale Implementation einer intelligenten Kommutierungslogik.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Software mit Echtzeit-Anforderung (Microcontroller)</li>\n  <li>STM32-Peripherie: Timer</li>\n  <li>Recherche und Dokumentation</li>\n  <li>Simulation mit geeigneter Toolchain</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Laserscanner-Positionierung",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/laserscanner-positioning.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Entwicklung einer Software-Komponente zur Bestimmung der Roboterposition mit einem SICK-Laserscanner.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Wir besitzen einen SICK TIM 551 Laserscanner, der mittels eines Infrarotlasers radial Distanzen misst. In der richtigen\nHöhe in einen unserer Roboter eingebaut, wäre es damit prinzipiell möglich, die Roboterposition anhand der\nbeobachteten Entfernungen zum Spielfeldrand zu berechnen. Probleme machen dabei jedoch die Ausreißer durch im Lichtweg\nbefindliche Spielelemente, das Messrauschen, die zeitliche Latenz der Verarbeitung und die Verzerrung der Messungen bei\nBewegung des Roboters.</p>\n\n<p>Daher soll eine Software-Komponente entwickelt und in die Robotersoftware integriert werden, die die per Ethernet/UDP\nausgegebenen Daten des Laserscanners verarbeitet, daraus seine Position und Ausrichtung auf dem Spielfeld schätzt und\ndiese an die Robotersoftware übermittelt. Dort soll eine weitere Komponente die Positionsdaten entgegennehmen und unter\nbestimmten Voraussetzungen und Ausgleich der Zeitverzögerung die bekannte Roboterposition und -ausrichtung damit\nkorrigieren.</p>\n\n<p>Da für den Laserscanner bereits ein Treiber im Software-Framework ROS existiert, bietet es sich an, die Software zur\nPositionsberechnung ebenfalls in ROS zu entwickeln und die Daten anschließend über das XPCC-Protokoll an den\nMicrocontroller des Roboters zu senden.</p>\n\n<h3 id=\"geplante-features\">Geplante Features:</h3>\n<ul>\n  <li>Filterung der Messwerte (Tiefpass?)</li>\n  <li>Ausreißer-Elimination (z.B. RANSAC-Verfahren)</li>\n  <li>Überwachung der Roboterbewegung; Korrektur nur bei stehendem Roboter oder Entzerrung der Messung</li>\n  <li>Plausibilitätsprüfung der Positionen/Ausrichtungen vor Korrektur</li>\n  <li>Visualisierung der berechneten Daten zur Validierung des Verfahrens</li>\n  <li>Entwicklung als ROS-Node; zusätzliche Nodes zur Kommunikation mit dem Roboter</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Herleitung von Geometrische Berechnungen und Algorithmen</li>\n  <li>Entwicklung von Algorithmen zur Signalverarbeitung (Filterung, Ausreißeranalyse)</li>\n  <li>Software-Entwicklung für ROS in Python und/oder C++</li>\n  <li>Software für Microcontroller in C++ mit modm.io</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Lokalisierung (anhand Kamera, IMU und/oder Ultraschall)",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/locatisation-ultrasonic-and-imu.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Kooperative Lokalisierung durch Mustererkennung mit einer Kamera, mit Ultraschall und Inertial Measurement Unit (IMU) für kompetitive mobile Robotik.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Die Lokalisierung ist ein wichtiger Teil der Strategie, Wegeplanung und des Driver.\nDabei steht nicht nur der eigene Roboter im Fokus, sondern auch die des Gegners.\nDenn mit diesem darf man während der Fahrt nicht kollidieren, dazu kann es zur Entscheidungsfindung der Strategie beitragen.</p>\n\n<p>Dazu stehen verschiedene Datenquellen mit verschiedenen Eigenschaften zur Verfügung.\nZum einen kann am Spielfeldrand eine Kamera platziert werden, die am Roboter befindliche Aruco Marker erkennt und damit Position und Orientierung bestimmt.\nOder durch ein Ultraschallsystem wird die Position mittels Triangulation zu festen Referenzpunkten gemessen.\nDesweiteren bietet eine inertiale Messeinheit (Bewegungs-, Drehratensensor etc.) die Möglichkeit eine höhere Aktualisierungsrate durch die Messung relativer Bewegung zu erzielen.</p>\n\n<p>Konkret sind folgende Aufgaben zu erledigen:</p>\n\n<ul>\n  <li>Schnittstellen-Definition zu Datenquellen (IMU, Kamera, etc.)</li>\n  <li>Schnitsstellen-Definition zur Strategie (Lokalisierung: Postition, Orientierung)</li>\n  <li>Recherche, Implementierung und Auswertung von Algorithmen zur Datenfusion vorhandener Daten</li>\n  <li>Integration und Test am und im Roboter</li>\n</ul>\n\n<h3 id=\"geplante-features\">Geplante Features:</h3>\n<ul>\n  <li>Filterung der Messwerte</li>\n  <li>Ausreißer-Elimination (z.B. RANSAC-Verfahren)</li>\n  <li>Überwachung der Roboterbewegung; Präferenz für Systeme je nach Eignung in der jeweiligen Situation</li>\n  <li>Plausibilitätsprüfung der Positionen/Ausrichtungen vor Korrektur</li>\n  <li>Visualisierung der berechneten Daten zur Validierung des Verfahrens</li>\n  <li>Entwicklung als ROS2-Node</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Herleitung von Geometrische Berechnungen und Algorithmen</li>\n  <li>Entwicklung von Algorithmen zur Signalverarbeitung (Filterung, Ausreißeranalyse)</li>\n  <li>Software-Entwicklung für ROS2 in Python und/oder C++</li>\n  <li>Software für Microcontroller in C++ mit modm.io</li>\n</ul>\n\n<h3 id=\"requirements\">Requirements</h3>\n\n<ul>\n  <li>Verständnis von Signalverarbeitung</li>\n  <li>Erfahrung mit C++ oder Python Programmierung</li>\n  <li>Ggf. Erfahrung mit Mikrocontrollerprogrammierung (Embedded Software Entwicklung)</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Micro-Motor",
          "category" : "Projekt",
          "tags"     : " elektronik, pcb",
          "url"      : "/projekt/micro-motor.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Micro-Motor ist eine Platine zum Anschluss an CAN-Bus welche einen Motor ansteuern kann.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>In den Aktoren verbaute Motoren müssen angesteuert werden, dazu verfolgt der Micro-Motor das Konzept von verteilten Ansteuerungen.</p>\n\n<p>An jedem Motor wird unmittelbar eine kompakte Micro-Motor Platine montiert, welche gleichzeitig auch einen Magnet-Encoder optional beinhaltet.\nDiese Platine wird über einen einzigen Stecker mit Strom und CAN-Bus versorgt und kann eigenständig den Motor ansteuern.\nZusätzlich kann ein Endschalter ausgelesen werden und die Temperatur des Motors überwacht werden.</p>\n\n<p>Auf dem Microcontroller sollen frei konfigurierbare PID-Regler und ggf. auch “Motor-mit-Endschalter”-Komponenten, welche den Aktor parametrierbar initialisieren und verfahren können, das Interface nach außen bilden.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>3 Phasen (DC und BLDC Motoren)</li>\n  <li>ca. 10A pro Phase</li>\n  <li>20V Betriebsspannung (Akku) -&gt; 40V oder 60V Auslegung</li>\n  <li>Anschluss für AB-Encoder</li>\n  <li>optional Magnet-Encoder auf dem PCB</li>\n  <li>Anschluss für Hall-Sensor</li>\n  <li>Temperatursensor (kontaktlos auf dem PCB verlötet oder I²C)</li>\n  <li>Strommessung</li>\n  <li>LEDs für Software-Status &amp; Encoderstatus</li>\n  <li>Konfigurierbare ID (ggf. STM32-Hardware-ID)</li>\n  <li>Einfach lötbar und aufbaubar</li>\n  <li>Abmessungen: Rund, Grund-Ø 20mm (Namiki-Motoren: Ø 22mm)</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>PCB Design 4-Layer (mit KiCAD)\n    <ul>\n      <li>EMV-gerechtes Design</li>\n    </ul>\n  </li>\n  <li>STM32-Peripherie: Timer, ADC, DAC, Komparator</li>\n  <li>Recherche und Auslegung Leistungs-MOSFETs und MOSFET-Treiber</li>\n  <li>Software Low-Level Hardware-Ansteuerung</li>\n  <li>Software Hardwareabstraktion</li>\n  <li>Reflow-Löten</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Micro-Motor V3",
          "category" : "Projekt",
          "tags"     : " elektronik, pcb",
          "url"      : "/projekt/micro-motor-v3.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Miniturisierter Motorcontroller mit GaN-Technologie",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Im Roboter verbaute Motoren müssen angesteuert werden, dazu soll der Micro-Motor V3 als miniaturisiertes Motorsteuerungs-Modul direkt an den Motoren platziert werden.\nVerglichen mit dem <em>Micro-Motor</em> in den <a href=\"micro-motor.html\">vorherigen Versionen</a> soll diese Version mit Hilfe von GaN-FETs noch kompakter, effizienter udn gleichzeitig leistungsfähiger ausfallen.</p>\n\n<p>Auf dem CAN-Bus soll ein CANopen-kompatibles Interface zur Steuerung und Konfiguration implementiert werden.\nEin Großteil der Software existiert hierfür schon.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>4 Phasen (DC-, BLDC- und Stepper-Motoren)</li>\n  <li>Strombelastbarkeit &gt;10A</li>\n  <li>20V und 40V Betriebsspannung -&gt; 60V Auslegung</li>\n  <li>Anschluss für Encoder und Hall-Sensor</li>\n  <li>Anschluss für Temperatursensor</li>\n  <li>Zwei RGB-LEDs (SK6812 o.ä.) zur Diagnose</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>PCB Design 4- oder 6-Layer (mit KiCAD)</li>\n  <li>STM32-Peripherie: Timer, ADC, DAC, Komparator</li>\n  <li>Recherche und Auslegung Leistungs-MOSFETs und MOSFET-Treiber</li>\n  <li>Software Low-Level Hardware-Ansteuerung</li>\n  <li>Software Hardwareabstraktion</li>\n  <li>Platinen-Bestückung mittels Reflow-Löten</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Odometrie",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/odometrie.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Implementierung von odometrischer Positionsbestimmung und einer Kalibrierungs-Routine",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Die Roboter des Roboterclubs benutzen bislang Odometrie zur eigenen Lokalisierung auf dem Spielfeld. Dabei wird\nkontinuierlich aus der Drehbewegung zweier Räder die Robotergeschwindigkeit berechnet und damit die Position\nnachgeführt.</p>\n\n<p>In Rahmen dieses Projektes soll zunächst der Code für die Positionsbestimmung per Odometrie neu entworfen und\nprogrammiert werden und anschließend eine Routine zur einfachen Kalibrierung der Odometrie-Parameter entwickelt werden.\nDie neue Software-Struktur soll die Integration weiterer Positionierungsmethoden vorsehen, etwa die Ultraschall-basierte\nabsolute Positionierung (vgl. Projekt Ultraschall Lokalisierung) oder eine Inertiale Messeinheit (IMU).</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Einarbeitung in die Roboterkinematik</li>\n  <li>Entwurf von Algorithmen zur Positionierung und Kalibrierung</li>\n  <li>Programmierung für eingebettete Systeme in C++ mit XPCC/modm Framework</li>\n  <li>Programmierung einer grafischen Anwendung in Python3/PyQt5</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Odometrie mit optischer Sensorik",
          "category" : "Projekt",
          "tags"     : " elektronik, software, mechanik",
          "url"      : "/projekt/odometrie-maussensoren.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Entwicklung eines optische Odometriesystems [1] für Roboterantriebe.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Für den sich in Entwicklung befindenden Antrieb des kleinen Roboters – basierend auf einem Omnidrive-Antrieb (siehe separate Projektbeschreibung) – kann keine konventionelle Odometrie mit zwei zusätzlichen nicht angetriebenen Rädern zur Positionsbestimmung genutzt werden.</p>\n\n<p>Ein vielversprechendes Konzept ist die Nutzung von Sensoren aus optischen Mäusen.</p>\n\n<p>Es gab im RCA bereits Versuche mit dem – inzwischen abgekündigten und nur noch schwer erhältlichen – Sensor ADNS9800 [2] von Avago.</p>\n\n<p>Idealerweise werden im Rahmen diese Projekts ein oder mehrere geeigneter Nachfolger ausfindig gemacht, die nötige Hardware aufgebaut, Software geschrieben und die Zuverlässig unter den Bedingungen des Eurobot-Wettbewerbs erprobt.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>Latenz &lt;5ms</li>\n  <li>Auflösung X und Y: &lt;1mm</li>\n  <li>Auflösung Rotation: &lt;1° (ggf. mit mehreren Sensoren)</li>\n  <li>Kleine Bauform</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Recherche verfügbare Sensoren</li>\n  <li>Software</li>\n  <li>Testbench aufbauen</li>\n  <li>ggf. PCB Design</li>\n  <li>Datenanalyse und Aufbereitung</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Pick-and-Place-Maschine zur Platinenbestückung einrichten",
          "category" : "Projekt",
          "tags"     : " elektronik, pcb",
          "url"      : "/projekt/liteplacer.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Der Roboterclub hat als Dauerleihgabe einen Liteplacer Bestückungsautomaten zur Verfügung gestellt bekommen. Diesen für uns lauffähig zu bekommen ist hier die Hauptaufgabe.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n<p>Es soll ein uns zur Verfügung gestellter Liteplacer für die Bestückung von diversen Platinen eingesetzt werden.\nHier gilt es herauszufinden, ob die Maschine im Istzustand einsetzbar ist oder dafür noch modifiziert werden muss.\nDie Maschine muss noch bei unserem Sponsor abgeholt werden und bei uns wieder aufgebaut werden.\nDie vorhandene Hardware (Mechanik und Elektronik) muss gesichtet werden und die Software OpenPNP installiert und konfiguriert werden.\nJe nachdem wie zuverlässig die Maschine dann arbeiten wird, kann die Aufgabe z.B. um das Anfertigen von Automatikfeedern erweitert werden.</p>\n\n<h3 id=\"technische-daten\">Technische Daten:</h3>\n<ul>\n  <li>Liteplacer-Mechanik</li>\n  <li>3D-Druck Feeder für größere Mengen (Reels)</li>\n  <li>Full Vision-System für bessere Bauteilplatzierungen</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>3D Druck</li>\n  <li>OpenPNP Software</li>\n  <li>Platinen-Bestückung</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Power Distribution",
          "category" : "Projekt",
          "tags"     : " elektronik, pcb",
          "url"      : "/projekt/batterie-management-system.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Neuentwurf des Power Distribution Board für zwei Akkus, höhere Ströme und ggf. höhere Spannungen",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Der Roboter wird von bis zu drei möglich Stromquellen – einem externen Netzteil und ein oder zwei austauschbaren LiFe-Akkus mit 6 Zellen – versorgt.\nDie ausgewählte Stromquellen wird, geschaltet und konfigurierbar abgesichert für die Aktorik an mehreren Ausgängen zu Verfügung gestellt.\nAußerdem wird aus der Eingangsspannung die Logikversorgung (12V) für alle Steuerelektronik und Computer mittels Schaltregler erzeugt\nund an mehreren individuell abgesicherten Ausgängen zur Verfügung gestellt.\nFür die Aktorikversordung soll zudem eine Precharge-Schaltung implementiert werden.</p>\n\n<p>Als Features sollen ein Kurzschlussschutz und eine Spannungsüberwachung an allen Ausgängen implementiert werden.\nAuch die Batterie muss natürlich überwacht werden.\nHier soll eine State of Charge Abschätzung durchgeführt werden und Unterspannungen erkannt werden.\nWichtige Informationen aus dem Betrieb sollen auf dem CAN Bus ausgegeben werden.</p>\n\n<h2 id=\"aufgabenstellung\">Aufgabenstellung</h2>\n\n<p>Der Schaltplan für das Power-Distribution ist in Arbeit, danach steht das Layout an.\nKonkret sind folgende Aufgaben zu erledigen:</p>\n\n<ul>\n  <li>Layout einer 4-Layer Platine in Kicad, Herausforderungen dabei sind die Anforderungen an Größe, EM-Verträglichkeit und vor allem Stromfestigkeit</li>\n  <li>Aufbau der gefertigten Platine, inklusive Test unter Last</li>\n</ul>\n\n<p>Um die Aufgaben zu erfüllen sind Grundkenntnisse der Schaltungstechnik und Erfahrungen mit PCB-Design von großem Vorteil.\nDie Komplexität dieses Projekts ist allerdings nicht so hoch, dass nicht auch Anfänger eine Chance haben, es erfolgreich abzuschließen.</p>\n\n<h2 id=\"geplante-kenndaten\">Geplante Kenndaten</h2>\n<ul>\n  <li>Eingangspannung aus zwei Akkus (18.8V nominell) und/oder einem Netzteil</li>\n  <li>Option: höhere Eingangspannung (ca. 40V) aus zwei seriellen Akkus</li>\n  <li>Motorspannung mit 50A</li>\n  <li>12V Logikspannung mit 10A</li>\n  <li>Kurzschlussschutz</li>\n  <li>Über/Unterspannungsschutz</li>\n  <li>Akku Überwachung</li>\n  <li>CAN-Interface</li>\n  <li>Integration Not-Aus (mechanischer Schalter nicht im Strompfad)</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Robot State Estimation",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/robot-state.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Entwicklung eines Modells des Zustands des Roboters",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Der Zustand eines Roboters wird durch viele verschiedene Eigenschaften definiert, wie beispielsweise die Position der Roboters auf dem Spielfeld, die Stellung der Aktoren, Füllstand von z.B. Tanks.\nZiel dieses Projektes ist es ein Modell zu implementieren welches den Roboterzustand darstellt, sodass andere Komponenten wie Spielstrategie oder Aktorik-Module dies als Grundlage für Entscheidungen und Aktionen verwenden können.\nAndere Komponenten veröffentlichen Nachrichten mit ihren Aktionen oder Zuständen, welche in dieser Komponente ausgewertet und aggregiert werden sollen.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>ROS2 (Robot Operation System 2)</li>\n  <li>Softwareentwicklung in C++ oder Python</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Roboter-Caddy",
          "category" : "Projekt",
          "tags"     : " mechanik, elektronik, software",
          "url"      : "/projekt/roboter-caddy.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Um die Roboter mit Zubehör, Baken, etc. bei den Wettbewerben zum Spielfeld zu transportieren wollen wir einen coolen Roboter-Caddy bauen.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Bei Wettbewerben sind teils längere Distanzen zwischen Team-Bereich und Spielfeld mit dem Roboter und nötigem Zubehör zu überwinden. Ein Transportfahrzeug wäre als hilfreich.\nLangweilige Implementierungen dieser Idee kann man bei anderen Teams beobachten, wo die Roboter in Bollerwägen, Kisten oder Kinderwagen transportiert werden.</p>\n\n<p>Wir wollen das natürlich weniger langweilig haben, also mit einem Antrieb und Steuerung, welche den Roboter-Caddy im besten Fall autonom einer Person folgen lässt oder Fernsteuerung ermöglicht.</p>\n\n<h3 id=\"anforderungen\">Anforderungen</h3>\n<ul>\n  <li>Kompakte Bauform, leicht zu Wettbewerben zu transportieren\n    <ul>\n      <li>in Roboterkiste integriert</li>\n      <li>zusammenklappbar</li>\n      <li>o.ä.</li>\n    </ul>\n  </li>\n  <li>Robustes Fahrwerk für unebene Böden auf Wettbewerben</li>\n  <li>Leistungsstarker Antrieb</li>\n  <li>ggf. Fernsteuerung</li>\n  <li>ggf. Autonome Navigation</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Mechanik</li>\n  <li>Elektronik</li>\n  <li>Software</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Robotersoftware Besseres Dokumentationsformat",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/dokumentation_roboter_software_ros2.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Dokutool für neue Robotersoftware basierend auf ROS2",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>ROS2 ist relativ gut dokumentiert.\nDie Robotersoftware und die darunter liegenden Konzepte müssen jedoch weiterhin dokumentiert werden.\nDazu gilt es ein Konzept zu entwickeln, mit allen relevanten Stakeholdern zu testen und danach Vereinsweit zu deployen.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>ROS2</li>\n  <li>Python und C++</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Routing-Algorithmus",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/routing.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Entwicklung und Implementierung eines Routenfindungs-Algorithmus für die Roboter.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n<p>Zur Navigation unserer Roboter auf dem Spielfeld soll ein Routing-Algorithmus entwickelt werden, mit dem jeder Roboter\nautonom die optimale Route zu einem Zielpunkt auf dem Spielfeld berechnen kann. Dabei sollen Hindernisse auf dem\nSpielfeld und nach Möglichkeit die aktuellen Positionen der anderen Roboter auf dem Feld mit Bezug auf die bekannten\nAußenmaße des Roboters berücksichtigt werden. Weiterhin sollte der Algorithmus die Einschränkungen des Antriebssystems\n(Bewegungs-Freiheitsgrade, max. Beschleunigung, etc.) berücksichtigen.\nDer Algorithmus soll dann in das neu entstehende ROS System eingeglieder werden.</p>\n\n<h3 id=\"featuresideen\">Features/Ideen:</h3>\n<ul>\n  <li>A*-Algorithmus auf einem kartesischen Raster auf dem Spielfeld mit ca. 30mm Auflösung, je 8 Ausrichtungen,\n8 Bewegungsrichtungen pro Feld</li>\n  <li>Dynamischer Import von Informationen zu Hindernissen über das ROS System / aus Kameradaten</li>\n  <li>Einbezug der vorhanden Informationen zu Spielfeld und Roboterform</li>\n  <li>Automatische Optimierung (Postprocessing) der Route durch Kurven und Geraden in beliebigen Winkeln</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Entwicklung von Routing- und Geometrieverarbeitungs-Algorithmen</li>\n  <li>Ggf. Implementierung und Validierung von Algorithmus-Prototypen in Python o.ä.</li>\n  <li>Softwareentwicklung in C++</li>\n  <li>Einarbeitung in ROS</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: SCARA",
          "category" : "Projekt",
          "tags"     : " mechanik, elektronik, software",
          "url"      : "/projekt/scara.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Der SCARA ist ein Roboterarm, der sich besonders für planare Pick-And-Place-Handhabungen eignet",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Der SCARA ist während der Saison 2018 enstanden und sollte zum Aufsammeln und Stapeln von Bauklötzen eingesetzt werden. Für die Handhabung ist momentan ein Saugnapf montiert.</p>\n\n<p>Angetrieben wird der Arm über insgesamt vier Motoren. Die Z-Achse wird über eine Spindel verfahren, die restlichen Motoren sind direkt mit den jeweiligen Achsen verbunden. Mit den Motorencodern werden die aktuelle Positionen erfasst, dabei ist beim Einschalten eine Referenzfahrt nötig, um die Nullpunkte der Z-Achse und Armwinkel zu ermitteln.Die gewünschte Position wird vom Anwender in kartesischen Koordinaten vorgegeben. Innerhalb der Software werden daraus die einzelnen Sollwinkel errechnet und validiert. Die Positionregelung erfolgt bislang für jeden Motor durch einen einzelnen PID-Reglern. Bei Vorgabe eines Punkts fahren alle Motoren den jeweiligen gewünschte Winkel an, wobei der langsamste Motor die Zeitdauer bestimmt. Ebenso ist der abgefahrene Weg eine Kurve, die von Anfangs- Endposition und der SCARA-Kinematik abhängt. Eine kontrollierte Fahrt entlang einer Linie ist angedacht.\nDie Mechanik ist weitgehend Spielfrei und sehr robust konstruiert. Mit geeignetem Werkzeug kann man auch Bäume ausreißen.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Mechanik: CAD, Fräsen, Berechnung von Kinematik und Dynamik</li>\n  <li>Elektrik: Ansteuerung der Motoren, Auswertung der Encoder, Verkabelung</li>\n  <li>Software: Anwenderschnittstelle, Regelung und Berechnungen zur Positionierung</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Sensorfusion",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/sensorfusion.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Verbesserung der Roboter-Ortung durch Fusion mehrerer Systeme.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Die Präszision der Ortung unserer Roboter hat einen großen Einfluss auf die Performance im Wettbewerb.\nMomentan haben die eingesetzten Ultraschallbaken Probleme mit Rotationen und die Odometrie [2] wird über die Antriebsräder durchgeführt,\ndie aufgrund von (unregelmäßigem) Schlupf einen wahrnehmbaren Fehler erzeugen.</p>\n\n<p>Zwei Ansätze sind geplant, um dem Abhilfe zu schaffen:\nIMUs (Inertial measurement unit) auf Ultraschall-Baken und RUNE-Tags [3] auf den Robotern, die von einer Kamera erkannt werden.\nDamit tatsächlich eine Verbesserung der Ortung erreicht werden kann, reicht es nicht diese Systeme einzuführen und die alten zu ersetzen.\nIntelligente Software ist nötig, um die verschiedenen Ortungsdaten zu vereinen.\nDa unsere Software mit ROS2 geschrieben wird wird muss ein dazu kompatibles System in Python und/oder C++ entwickelt werden.</p>\n\n<h3 id=\"geplante-features\">Geplante Features:</h3>\n<ul>\n  <li>Filterung der Messwerte</li>\n  <li>Ausreißer-Elimination (z.B. RANSAC-Verfahren)</li>\n  <li>Überwachung der Roboterbewegung; Präferenz für Systeme je nach Eignung in der jeweiligen Situation</li>\n  <li>Plausibilitätsprüfung der Positionen/Ausrichtungen vor Korrektur</li>\n  <li>Visualisierung der berechneten Daten zur Validierung des Verfahrens</li>\n  <li>Entwicklung als ROS2-Node</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Herleitung von Geometrische Berechnungen und Algorithmen</li>\n  <li>Entwicklung von Algorithmen zur Signalverarbeitung (Filterung, Ausreißeranalyse)</li>\n  <li>Software-Entwicklung für ROS2 in Python und/oder C++</li>\n  <li>Software für Microcontroller in C++ mit modm.io</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Sensorik für Spielelemente",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/sensorik-spielelemente.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Entwicklung von Softwarekomponenten zur Erkennung von Spielelementen.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Bei jedem Eurobotwettbewerb sind auf dem Spielfeld verschiedene Komponenten wie Becher, Pucks, Fahnen etc. verteilt.\nUm Punkte zu holen müssen manche dieser Objekte eingesammelt und an einer anderen Position wider abgesetzt werden.\nMit anderen Komponenten hingegen muss interagiert werden wie z.B. eine Fahne um zu schubsen.\nDie Aufgabe besteht daher darin, eine Softwarekomponente zu schreiben, welche die einzelnen Objekte erkennt.</p>\n\n<p>Zur Verfügung stehen unter anderem:</p>\n<ul>\n  <li>Kamerabild eine auf der <em>Central Tracking Platform</em> zu installierenden Kamera (z.B. Raspberry Pi Camera)</li>\n  <li>Bilder mehrerer kleiner USB-Kameras am Roboter</li>\n  <li>Verschiedene Sensoren wie Taster, Distanzsensor oder Farbsensor an den einzelnen Aktuatoren</li>\n  <li>Feedback von den Aktuatoren (Position, Motorstrom, Kraft, …)</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Bilderkennung und Verarbeitung mit OpenCV</li>\n  <li>Softwareentwicklung in C++ oder Python</li>\n  <li>ROS2 (Robot Operation System 2)</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Sensorik zur Gewichtsmessung",
          "category" : "Projekt",
          "tags"     : " elektronik, pcb, software, mechanik",
          "url"      : "/projekt/gewichtsmessung.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Aufbau eines Prototypen zur Gewichtsmessung von Spielelementen mit Roboterarmen.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Bei der Ankündigung des Eurobot-Mottos für 2019 “Atom Factory” [1] wurde erwähnt, dass die Roboter Spielelemente wiegen sollen.\nAuch für einige andere Aktorik ist die Technologie hilfreich.</p>\n\n<p>Das Ziel des Projekts ist einen Prototyp einer Sensorik zur Gewichtsmessung für einen Roboterarm zu implementieren.</p>\n\n<p>Die verschiedenen möglichen Methoden zur Gewichtsmessung soll verglichen und für den Einsatz im Roboter bewertet werden.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>Mögliche Methoden\n    <ul>\n      <li>Strommessung Elektromotor</li>\n      <li>Dehnungsmessstreifen [2]</li>\n      <li>Mechanisch mit Feder und Taster</li>\n      <li>Weitere [3]</li>\n    </ul>\n  </li>\n  <li>Präzision je nach Anforderungen</li>\n  <li>Kraft/Gewicht je nach Anforderungen</li>\n  <li>Platine zum Anschluss an CAN</li>\n  <li>Kompakte Baugröße</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Analoges Schaltungsdesign</li>\n  <li>PCB Design</li>\n  <li>STM32</li>\n  <li>Software Mikrocontroller</li>\n  <li>Ggf. Mechanik</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Silikon-Räder",
          "category" : "Projekt",
          "tags"     : " mechanik, werkzeug",
          "url"      : "/projekt/silikon-raeder.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Silikon hat für die Antriebsräder sehr geeignete Eigenschaften.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Die Roboter des Roboterclubs werden von Motoren angetrieben welche ihre Kraft mit Hilfe von Rädern auf den Untergrund bringen.</p>\n\n<p>Dabei spielen die Räder eine entscheidenden Faktor wie präzise und schnell der Roboter fahren, beschleunigen und bremsen kann.\nJe größer die Haftung der Räder auf dem Untergrund ist, umso besser kann Kraft übertragen werden.</p>\n\n<p>Historisch wurden im RCA modifizierte Inline-Skater-Räder oder Modellbau-Räder verwendet, in letzter Zeit hat uns die Firma TYP AG / TGW GmbH mit nach unseren Vorgaben individuell angefertigten Rädern mit vulkanisiertem Gummi unterstützt.</p>\n\n<p>Für den kleiner Roboter der Saison 2016 wurden bereits Experimente mit Silikonrädern durchgeführt, der Ergebnis war ein voller Erfolg.</p>\n\n<p>Im Rahmen dieses Projektes soll die Technologie zum Gießen von Silikon im RCA erarbeitet und dokumentiert werden und in Folge dessen für mindestens einen der Roboter Antriebs-Räder aus Silikon hergestellt werden.</p>\n\n<p>Neben den Antriebsrädern gibt es noch viele weitere Anwendungen für gegossene Silikon-Teile, beispielsweise bei Greifern.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>CAD-Konstruktion mit SolidWorks</li>\n  <li>Fertigung von Formen mit CNC-Fräse und/oder 3D-Drucker</li>\n  <li>Ggf. Kooperation mit einem Institut bzw. Silikonhersteller</li>\n  <li>Gießen von Silikon</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Simulator",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/simulator.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Im Simulator können die Roboter virtuell getestet werden, dazu wird die Roboterhardware emuliert und das Spielfeld mit Spielelementen sowie Gegnerroboter simuliert.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Für das Testen von unserer Eurobot Spielstrategie wollen wir einen Simulator entwickeln,\nder den Roboter auf dem Spielfeld mit Spielelementen in 2 bis 2,5 Dimensionen simuliert,\nmit vereinfachten oder ideellen physikalischen Berechnungen.</p>\n\n<p>Dieser Simulator soll auch genutzt werden, um verschiedene Subsyteme des Roboters (zB. Regelungsschleifen, Sensorauswertungen mit Rauschen)\nwährend der Entwicklungsphase schnell zu testen, ohne auf einen funktionierenden Roboter angewiesen zu sein.\nInsbesondere zum Evaluieren unserer Spielstrategie ist es sinnvoll auch schneller als Echtzeit simulieren zu können.</p>\n\n<p>Desweiteren soll eine Anbindung an Matlab oder Numpy bereitstellt werden, sodass komplexere Simulationen von physikalischen \nEigenschaften als Plugin hinzugeschaltet werden können.\nDie Saison spezifischen Daten für das Spielfeld und Roboter können aus den Eurobot Shared Resources eingelesen werden [1].</p>\n\n<p>Der Zeitraum zwischen der Bekanntgabe der Eurobot-Regeln und den Wettbewerben ist mit einem halben Jahr recht kurz,\ndaher soll die Software-Entwicklung parallel zur Konstruktion und Bau der Mechanik erfolgen.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n\n<ul>\n  <li>Softwareentwicklung in Python oder C++ mit Qt5</li>\n  <li>Simulation von Robotern, Spielfeld und Spielelementen</li>\n  <li>Datenverarbeitung und Replay</li>\n  <li>Sensoren (Distanz, Laserscanner, Farbe, etc.)</li>\n  <li>Interface mit Matlab für Regelungen modellieren</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Software auf modm portieren",
          "category" : "Projekt",
          "tags"     : " software, werkzeug",
          "url"      : "/projekt/rca-projekte-auf-modm-portieren.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Erstellung einer Skripte-Sammlung, die das Portieren unserer Software Projekte vom xpcc.io Framework zur modm.io Library (halb-)automatisch ermöglicht.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Wir nutzen seit 2009 das xpcc.io Framework [1] als Basis für all unsere eingebettete Software.\nVon 2016 bis 2018 haben die zwei Hauptmaintainer Fabian und Niklas H. dieses generalüberholt\nund tiefgreifende Änderungen in der Code-Generierung und teilweise der Struktur/API gemacht,\num den Code modularer und insbesondere unabhängig vom Build System zu machen.</p>\n\n<p>Der Nachfolger von xpcc heißt jetzt modm [2]. \nxpcc wird noch bis Ende 2018 maintained und danach als deprecated markiert.\nBis dahin werden alle Änderungen von xpcc nach modm von Niklas H. portiert.</p>\n\n<p>Ein oder mehrere Skripte sollen entwickelt werden, die den Hauptteil der Änderungen\nvollautomatisch, oder zumindest mit wenigen manuellen Eingriffen, anwenden.\nZusätzlich soll ein Porting Guide von xpcc auf modm für die Webseite geschrieben,\nsodass auch externe Anwender auf modm upgraden können.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>C++17, Regex, Python3, SCons</li>\n  <li>Verständnis der Änderungen zwischen xpcc und modm</li>\n  <li>Code Generierung</li>\n  <li>Versionsverwaltung und CI</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Spielzeit Uhr",
          "category" : "Projekt",
          "tags"     : " software, elektronik",
          "url"      : "/projekt/eurobot-spielzeit-uhr.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Anzeige der Spielzeit eines 100s Eurobot Spiels.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Eurobot Spiele sind 100s lang, das passt gerade noch so in zwei 7-Segment Anzeigen.\nWir haben eine große LED-Anzeige ergattert, die 6x 7-Segment Anzeigen hat (2x blau, 4x rot)\nund gut hackbar ist. Die einzelnen LED Anzeigen werden jeweils via SPI mit einem\n16-bit Constant Current LED Driver (FD9802) gesteuert.</p>\n\n<p>Wir wollen den obskuren (8-bit?) Prozessor auf dem Board ersetzen durch einen\nSTM32 (Nucleo-32 passt gut) und das Board per Funk mittels NRF24 in unsere\nRoboterfunk Verbindung einbinden, sodass das Display den Spielstart automatisch\nmitbekommt, ohne speziell konfiguriert werden zu müssen.</p>\n\n<p>Auf dem Blauen LEDs sollen die verbleibende Spielzeit angezeigt werden, und auf den\nrestlichen Anzeigen evtl. die Punkte, die unser Roboter schätzt gemacht zu haben.\nCreative Animationen mit den wenigen LEDs sind gern gesehen.</p>\n\n<h3 id=\"anforderungen\">Anforderungen</h3>\n\n<ul>\n  <li>Neue Hardware ist klein genug um im original Gehäuse zu bleiben</li>\n  <li>Leicht zu Wettbewerben mitnehmbar</li>\n  <li>Stromsparend wenn nicht in Benutzung</li>\n  <li>Automatische Erkennung von Spielstart und Punkten via Funk</li>\n  <li>Animation für Spielende</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n\n<ul>\n  <li>PCB Reverse Engineering</li>\n  <li>Funkkommunikation mit NRF24L01</li>\n  <li>Eingebettete Software mit modm.io [1]</li>\n  <li>7-Segment LED Anzeigen</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: USB nach FD-CAN Adapter",
          "category" : "Projekt",
          "tags"     : " elektronik, pcb, software, werkzeug",
          "url"      : "/projekt/usb2canfd.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Ein simpler, kleiner USB-Adapter für den CAN-Bus mit Flexible-Datarate (FD-CAN) Support.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Die Aktoren und Sensoren im Roboter sind per CAN-Bus angebunden.\nDas Interface zum Steuerungscomputer (x86-PC mit ROS2) ist ein USB nach CAN Adapter.\nDa wir in der Zukunft für die Datenübertragung gerne die 10-mal höhere Bitrate durch FD-CAN nutzen wollen,\nbenötigen wir einen solchen Adapter mit FD-CAN Unterstützung.\nKommerziell verfügbare Produkte sind rar, teuer und haben eine zu große Bauform.</p>\n\n<p>Folglich entstand die Idee das Roboterclub-Projekt <em>USB2CAN</em> weiter zu entwickelt und FD-CAN-fähig zu machen.\nInwiefern die bestehende Hardware und Software genutzt werden kann, muss evaluiert werden.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>FD-CAN Support mit voller 8MBit/s Datenrate</li>\n  <li>SocketCAN Support (CAN Framework des Linux Kernels)</li>\n  <li>Kleine Bauform: USB-Stick</li>\n  <li>Optional: Galvanische Isolation</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>CAN-Bus</li>\n  <li>PCB Design (mit KiCAD)</li>\n  <li>Linux-Kernel-Treiber</li>\n  <li>C++ Software</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Ultraschall Lokalisierung (Baken)",
          "category" : "Projekt",
          "tags"     : " software, elektronik",
          "url"      : "/projekt/ultraschall-baken.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Unsere Roboter sollen sich mittels eines Ultraschall-Baken-Systems auf dem Spielfeld orientieren können.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Wir wollen beim kommenden Wettbewerb ein neues System zu Lokalisierung und unserer eigenen sowie der Gegner-Roboter einsetzen.</p>\n\n<p>Das technische Konzept das Ultraschall-Lokalisierung wurde in den letzten Jahren bereits entwickelt und getestet, eine gute Übersicht liefert die Veröffentlichung [1].</p>\n\n<p>Dieses System muss nun in unsere Roboter und Gegner-Baken integriert, angepasst und getestet werden.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>Drei feste Baken am Spielfeldrand</li>\n  <li>Mobile Baken in den eigenen Robotern und in den Gegnerbaken</li>\n  <li>Geringe Latenz &lt;10ms</li>\n  <li>Genauigkeit &lt;5mm</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Implementation der Funk-Kommunikation mit R2MAC/NRF24L01+</li>\n  <li>Software\n    <ul>\n      <li>Portieren der Software zum modm-Framework</li>\n    </ul>\n  </li>\n  <li>ggf. PCB Design</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: User Interface",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/ui.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Die Interaktion mit dem Roboter erfolgt in erster Linie über unseren Touchscreen.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Teil der Regeln im Eurobot ist, dass der Roboter in kurzer Zeit auf ein Spiel vorbereitet werden muss.\nDazu ist es sehr hilfreich, wenn der Roboter direkt bedient werden kann und auch Fehlernachrichten direkt angezeigt werden können, ohne erst eine (Funk-) Verbindung mit einem Laptop herstellen zu müssen.\nIn den vergangenen Jahren haben wir zu diesem Zweck einen Touchscreen eingesetzt, der zentral am Roboter angebracht war.</p>\n\n<p>Die Software für unseren Touchscreen muss jedes Jahr an den Roboter angepasst werden, da nicht nur das Spielfeld und damit die Auswahl an Strategien, sondern auch der Roboter selbst anders aussehen.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>UI/UX Entwicklung</li>\n  <li>LVGL Grafik-Framework</li>\n  <li>Softwareentwicklung in C++</li>\n  <li>Programmierung eines STM32 Microcontroller mit modm.io</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Vision-2-Win",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/camera-vision.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Das Vision System erkennt Spielelemente und ihre Position mithilfe von Kameras am Spielfeldrand und Roboter.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Mithilfe von Kameras an den stationären Barken um das Spielfeld sowie auf dem Roboter wollen wir in Zukunft Spielelemente und eigene und gegnerische Roboterposition erkennen.</p>\n\n<p>Eine Standard Library zur Bildverarbeitung, die wir dazu nutzen, ist OpenCV [1].\nZum Tracking der Roboterposition eigenen sich z.B. diverse Fiducial Marker Systeme [3,4,5].\nDiese können wir durch LED Marker etc. weiterentwickeln.</p>\n\n<p>Spielelemente können wir mithilfe diverser Matching und Detection Verfahren in OpenCV erkennen, oder sogar trainierte Object Detection Classifier [6] verwenden.\nEine weitere Möglichkeit der Positionserkennung von Spielelementen können in Zukunft Kameras unseres Sponsors Cognex sein, die auf dem Roboter montiert werden [7].</p>\n\n<h2 id=\"arbeitspakete-für-die-saison-2022\">Arbeitspakete für die Saison 2022</h2>\n\n<ol>\n  <li>Aufbau eines Kamerasystems und Hardware Plattform (z.B. Raspberry Pi &amp; Pi-Camera, USB/GigE Kameras, Intel NUC oder NVIDIA Jetson)</li>\n  <li>Kontinuierliche Erkennung der Roboterposition mithilfe von Markern</li>\n  <li>Erkennen von Spielelementen entsprechend neuem Regelwerk für 2022</li>\n  <li>Visualisierung der erkannten Spielelemente in RVIZ [8] oder GAZEBO [2]</li>\n</ol>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: librobots: Open Source Veröffentlichung",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/librobots-open-source.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Vervollständigung und Veröffentlichung unserer internen librobots Bibliothek auf GitHub.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Es existiert recht viel Code, der jede Saison weiter benutzt wird, aber nicht \ngenerisch genug ist um in modm.io zu landen.\nDeshalb wurde angedacht, diesen Code in librobots zu überführen und dort als\neigenständiges Projekt zu warten und somit duplizierten Code zu vermeiden.\nDieses Projekt soll den Kern unserer modularen Robotersoftware werden, ähnlich\nwie xpcc bzw. modm der Kern unserer eingebetteten Software ist.\nDemzufolge soll auch die entstehende Architektur dokumentiert werden.</p>\n\n<p>Dieses Projekt ist als “Ausbildung” zum Open Source Maintainer gedacht, und ist\nsomit als Langzeitprojekt konzipiert.\nDie librobot soll zunächst im internen GitLab für die Veröffentlichung vorbereitet\nwerden und dann unter der RCA GitHub Organisation [1] als Open Source Projekt \ngeführt werden.\nDie Prozesse (Issue Tracking, Code Review, CI, Dokumentation) sollen wenn möglich\nähnlich zu modm.io gehalten werden.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Open Source Library Maintenance</li>\n  <li>Issue Tracking and Code Review</li>\n  <li>Architecture Design</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: modm: Besseres Dokumentationsformat",
          "category" : "Projekt",
          "tags"     : " software, webentwicklung, werkzeug",
          "url"      : "/projekt/modm-dokumentation.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Programmieren eines Dokutools mit Doxygen und lbuild Anbindung und Automatisierung von Doku-Qualitätkontrollen.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Sowohl xpcc als auch modm [1] sind relativ gut <em>im Code</em> mittels Doxygen dokumentiert.\nFür xpcc haben wir somit einfach den generierten Doxygenoutput online gestellt [2].\nDoxygen eignet sich allerdings nicht besonders gut für Konzeptdokumentation und Beispielcode.</p>\n\n<p>Mit <code class=\"language-plaintext highlighter-rouge\">lbuild</code> [3] ist modm in mehrere Module aufgeteilt, die jeweils nur eine überschaubare Anzahl an Klassen verwalten.\nDiese Module können separat in Markdown dokumentiert werden und erlauben detailierte Konzeptdokumentation [4].\nDie Doxygendokumentation des Codes kann als XML ausgegeben und per Python3 eingelesen werden [5], momentan, werden\nallerdings nur die wichtigsten Objektnamen angezeigt [6].</p>\n\n<p>Es soll ein Konzept erarbeitet werden, wie am Besten die Doxygendokumentation in die Moduldokumentation eingebunden werden kann,\nsodass es einfach ist komplexe Dokumentation zu schreiben und mit der Implementation zu verlinken.\nDesweiteren sollen Beispiele in der Moduldokumentation kompilierbar sein, und wenn möglich weitere Überprüfungen (zB. valide Objektnamen im Fließtext) als Teil des CIs implementiert werden.\nDamit soll die Dokumentation synchron zur Implementierung gehalten werden.\nAbschließend soll diese Dokumentation visuell ansprechendend, durchsuchbar und gut navigierbar unter docs.modm.io automatisch\ndeployed werden.</p>\n\n<p>In Zukunft soll dieses Tool auch für librobots und evtl. andere RCA Projekte verwendet werden.\nAls Vorbild für Design und Vollständigkeit gilt die Qt5 Dokumentation [7].</p>\n\n<p><em>Es ist explizit nicht erforderlich, Dokumentation für modm zu schreiben!</em>\nEs geht hier um die automatische Erstellung und Pflege der Dokumentation, nicht unbedingt den Inhalt.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n\n<ul>\n  <li>Doxygen XML Auswertung für Assembly, C, C++</li>\n  <li>Python3 und Jinja2 für Datenumwandlung und Dokumentationsgeneration</li>\n  <li>Editieren Technischer Dokumentation</li>\n  <li>Automatische Compilierung von Beispielcode</li>\n  <li>Automatisches Deployment der Dokumentation</li>\n  <li>Webdevelopment und -design, evtl. mit vorhandener Doku-Engine</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: modm: Einheitensystem und Festkomma-Arithmetik",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/modm-units-and-fixed-point.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Implementation eines Einheitensystem mit user-defined literals und in Kombination mit Festkomma-Arithmetik für das open-source C++-Microcontroller-Framework modm.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Für alle physikalischen Berechnungen in unserer Robotersoftware wollen wir Einheiten nutzen können, dies sorgt für übersichtlicheren und besser selbst-dokumentierenden Code.</p>\n\n<p>Beispiel:</p>\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>using namespace modm::units;\nlength_t distance = 300_mm;\ntime_t   time     = 1500_ms;\nvelocity_t speed  = distance / time;\nfloat foo         = distance + time; // compiler error: Units are not compatible.\n</code></pre></div></div>\n\n<p>Da es auf Microcontrollern aus verschiedenen Gründen nicht erstrebenswert mit Gleitkommazahlen zu rechnen ist, bietet es sich an gleichzeitig Festkomma-Arithmetik [1] im modm [2] zu implementieren.</p>\n\n<h3 id=\"diskussion--features\">Diskussion &amp; Features</h3>\n<ul>\n  <li>Fehlerabschätzung Multiplikation und Division</li>\n  <li>Unittests</li>\n  <li>Portieren und Anpassen bestehender Klassen</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>C++</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: modm: Hardware Unittests",
          "category" : "Projekt",
          "tags"     : " software, webentwicklung, elektronik, werkzeug",
          "url"      : "/projekt/modm-hwut.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Automatisches Ausführen von Unit- und Integrationstests auf Arm Cortex-M Mikrocontrollern.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>modm [1] enthält eine große Anzahl an Unittests [2], die auch in unserem CI automatisch auf x86 ausgeführt werden.\nDiese Unittests können auch direkt auf dem Mikrocontroller ausgeführt werden, allerdings nur manuell und mit diversen Einschränkungen [3].\nDieser Prozess soll automatisiert werden, und die Ergebnisse als Teil des modm CIs für alle öffentlichen Pull Requests auf GitHub zur Verfügung gestellt werden.\nDazu stellen wir eine große Anzahl an diversen STM32 Discovery und Nucleo Development Boards.</p>\n\n<p>Da die modm Unittests recht begrenzt sind in ihrer Funktionalität, wäre es evtl. sinnvoll ein vollständigeres Unittest Framework wie Metal.Test zu nutzen [4].\nTracing und Performance könnte zusätzlich mit der Arm Cortex-M Debughardware erfasst werden [5].</p>\n\n<p>Zusätzlich zu in sich geschlossenen Unittests sollen auch Hardware Integrationstests erforscht werden.\nDazu gibt es Überlegungen, während eines Testes die Input/Output Werte des Mikrocontrollers mit Hilfe vom SigRok [6] zu erfassen und gegen diverse Eigenschaften und Testcases zu überprüfen.\nHier sollen verschiedene komplexe Tests gefahren und ausgewertet werden können [7], evtl. mit FPGA als IO-Multiplexer und Logikanalyzer.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n\n<ul>\n  <li>Testing mit Hardware-in-Loop</li>\n  <li>Anzeige als GitHub Continuous Integration Service</li>\n  <li>Debugging mit GDB auf Arm Cortex-M und RISC-V</li>\n  <li>Arm Cortex-M und RISC-V Debug-Hardware</li>\n  <li>Erstellen von Logikwaveformtests</li>\n  <li>Automatisierte Auswertung von Logikprotokollanalysen</li>\n  <li>PCB Design</li>\n  <li>Kommerzialisierung?</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: modm: Konzept und Umsetzung einer DMA Schnittstelle",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/modm-dma.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Erstellen eines Modells flexiblen und einfachen Nutzung von DMA (Direct Memory Access) in User-Code und anderen modm-Modulen.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Die meisten Mikrocontroller haben eine DMA-Einheit, welche unabhängig von der CPU auf Speicher zugreifen kann und Daten kopieren kann.\nDurch die Nutzung von DMA kann beispielsweise Peripherie wie SPI mit Daten zum senden versorgt und die empfangenen Daten gespeichert werden ohne dass die CPU hierbei belastet wird,\nwovon in modm [2] bisher kein Nutzen gemacht wird.</p>\n\n<p>Einige sehr zeitkritische Anwendungen können ohne DMA gar nicht implementiert werden,\nbeispielsweise eine Ansteuerung von WS2812-LEDs mit Bitmustern aus SPI.</p>\n\n<p>Im Rahmen dieses Projekts soll ein API für Abstraktion von DMA-Einheiten entwickelt werden welches sowohl flexibel im Bezug auf mögliche DMA-Einheiten ist,\nals auch universell in modm-Modulen wie Gerätetreibern und im User-Code einsetzbar ist.\nDie Abstraktion sollte mindestens für STM32 Mikrocontroller implementiert werden,\nweitere Implementierungen könnten später erfolgen.</p>\n\n<p>Anschließend können die vorhandene Treiber für STM32-Peripherie (SPI, UART, …) für DMA erweitert oder angepasst werden.</p>\n\n<p>Aus dem Vorgängerprojekt vom modm, xpcc, existiert eine DMA-API [1], die sich allerdings als suboptimal herausgestellt hat.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>C++17</li>\n  <li>STM32 Speicherarchitektur, sowie weitere mögliche weitere Architekturen</li>\n  <li>STM32 Peripherie: DMA, Timer, SPI, UART, …</li>\n  <li>Low-level Programming in modm.io</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: modm: Nebenläufigkeits Modelle erforschen (Concurrency)",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/modm-concurrency-modelle.html",
          "date"     : "October 9, 2022",
          "excerpt"  : "Erstellen eines Modells zur einfachen und sicheren Beschreibung von Nebenläufigkeiten (Concurrency) für eingebettete Systeme.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Um die Nebenläufigkeiten im Robotercode zu beschreiben nutzen wir Protothreads [1], Resumable Functions [2] und Activities [3].\nDiese basieren auf sog. stackless cooperative scheduling, die simpelste Form der Nebenläufigkeit.\nDesweiteren ist das XPCC Protokoll als Event-Loop implementiert und ruft die Empfänger mittels diesen\nMechanismen auf [4].</p>\n\n<p>Diese Architektur ist sehr speichereffizient und funktioniert somit auch noch auf sehr speicherlimitierten\nMikrocontrollern wie die AVRs. Für unsere Zwecke ist sie aber zu effizient, sodass es mühsam und teilweise \nunintuitiv ist, komplexere Nebenläufigkeiten abzubilden. Desweiteren nutzen wir keine AVRs mehr, sondern\nARM Cortex-M Systeme, die genügend Speicher mitbringen.</p>\n\n<p>Wir möchten mehrere Concurrency Modelle erforschen und bewerten, wie gut sie sich auf\nunser Problem anwenden lassen und wie man sie effizient auf AVR und ARM Cortex-M\nimplementiert.</p>\n\n<p>Das Resultat soll dann in modm.io [5] implementiert werden und der Prozess ordentlich\ndokumentiert werden, sodass es auch extern genutzt werden kann.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>C++17, C11, AVR/ARMv6/v7-M Assembly</li>\n  <li>Concurrency Modelle: Actors, Threading, Coroutines, Event-Loops</li>\n  <li>AVR und ARM Cortex-M Architektur</li>\n  <li>Low-level Programming in modm.io</li>\n</ul>\n"
       
     } 
   
  
]
