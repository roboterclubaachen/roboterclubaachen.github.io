[
  
   
      {
        "title"    : "! W A N T E D ! - Einsteiger",
        "category" : "",
        "tags"     : " saison20",
        "url"      : "/blog/2019/wanted-einsteiger.html",
        "date"     : "October 21, 2019",
        "excerpt"  : "<h2 id=\"du-willst-bei-uns-mitmachen-super\">Du willst bei uns mitmachen? Super!</h2>\n",
        "content"  : "<h2 id=\"du-willst-bei-uns-mitmachen-super\">Du willst bei uns mitmachen? Super!</h2>\n\n<p>Für die kommende Eurobot-Wettbewerbs-Saison gibt es viel zu tun im\nRoboterclub und wir freuen uns, wenn du dich in einem der folgenden\nBereichen engagieren möchtest:</p>\n\n<ul>\n  <li>Bildverarbeitung</li>\n  <li>Funk-Kommunikation</li>\n  <li>Mechanische Aktoren zum Greifen von Bechern</li>\n  <li>Antriebs-Plattform (Omnidrive)</li>\n  <li>Regelung und Fahrtplanung</li>\n  <li>Mechanische Fertigung (3D-Drucker und CNC-Fräse)</li>\n  <li>Batterie-Management</li>\n  <li>Motor-Controller</li>\n  <li>Autonome Roboter-Steuerung mit ROS2</li>\n  <li>Ultraschall-Indoor-Lokalisierung</li>\n  <li>…</li>\n</ul>\n\n<p>Um dir einen guten Einstieg zu ermöglichen findet am</p>\n\n<h4 id=\"dienstag-den-29102019-um-19h\">Dienstag, den 29.10.2019 um 19h</h4>\n\n<p>ein Einsteiger-Event statt.\nDort zeigen wir dir unser Roboter und Projekte, und vermitteln dir eine\nAufgabe oder ein Projekt im RCA.</p>\n\n<h3 id=\"weitere-information-unter-mach-mit\">Weitere Information unter: <a href=\"/mach-mit/\">Mach mit</a></h3>\n"
      },
   
      {
        "title"    : "µMotor 2 - Teil 3: Microcontroller &amp; Stromversorgung",
        "category" : "",
        "tags"     : " elektronik, saison20",
        "url"      : "/blog/2019/micro-motor-2-teil-3.html",
        "date"     : "September 2, 2019",
        "excerpt"  : "<p>Als Teil der Entwicklung der zweiten Version des Micro-Motors findet nun die Auswahl des Microcontrollers statt.\nAußerdem geht es in diesem Blogpost um Komparatoren und die Stromversorgung.</p>\n",
        "content"  : "<p>Als Teil der Entwicklung der zweiten Version des Micro-Motors findet nun die Auswahl des Microcontrollers statt.\nAußerdem geht es in diesem Blogpost um Komparatoren und die Stromversorgung.</p>\n\n<p>Die bisherige Entwicklung des Motorcontrollers kann in <a href=\"/blog/2019/micro-motor-2-teil-2.html\">mehreren</a> <a href=\"/blog/2019/micro-motor-2-teil-1.html\">älteren</a> <a href=\"/blog/2018/micro-motor-debugging-inbetriebnahme.html\">Blogposts</a> nachgelesen werden.</p>\n\n<p>Die vorläufige Auswahl der Shuntverstärker ist fast abgeschlossen, siehe <a href=\"/blog/2019/micro-motor-2-teil-2.html\">Teil 2</a>.\nEbenso ist der Gatetreiber (<em>DRV832x</em>) gesetzt in der Version ohne Strommessverstärker und mit SPI-Interface (<em>DRV8320S</em> oder <em>DRV8350S</em> in Gehäuse <em>WQFN32</em>, 5x5mm²).\nAlso MOSFET soll der in Micro-Motor Version 1 bewährte N-Channel Dual-FET <em>FDMD8260L</em> (60V, 5.8mΩ) verwendet werden.</p>\n\n<p>Als nächste wichtige Komponente wird der Microcontroller ausgewählt.</p>\n\n<h3 id=\"microcontroller\">Microcontroller</h3>\n\n<p>Eher zufällig wurden wir auf die neue Microcontroller-Serie <em>STM32G4</em> von ST Microelectronics aufmerksam.\nIn <a href=\"/blog/2019/micro-motor-2-teil-1.html\">Teil 1</a> wurde der <em>STM32L432CC</em> als präferierter Microcontroller genannt, jedoch bietet die neue <em>STM32G4</em>-Serie, speziell der <em>STM32G474</em> (oder <em>STM32G473</em>, ohne High-Resolution-Timer) einige Vorteile:</p>\n\n<ul>\n  <li>Taktfreqenz bis zu 170MHz für Cortex-M4F und <strong>alle</strong> Peripherals (max. 80MHz bei <em>STM32L4</em>)</li>\n  <li>High-Performance Analog Peripherals\n    <ul>\n      <li>7x Komparator (<em>COMP</em>), 17ns Propagation delay, einstellbare Hysterese</li>\n      <li>5x ADC 12bit, 4MSPS, differenzielle Inputs verfügbar)</li>\n      <li>4x DAC 12bit, 1MSPS</li>\n      <li>6x Opamp mit GBP (Gain Bandwidth Product) von 13MHz (<em>OPAMP</em>)</li>\n    </ul>\n  </li>\n  <li>DSP (Rechenbeschleuniger) Funktionen für Trigonometrie und Filter (<em>CORDIC</em>, <em>FMAC</em>)</li>\n  <li>High-Resolution-Timer (<em>HRTIM</em>) mit 184ps Zeitauslösung</li>\n  <li>3x Advanced Motor Control Timer (<em>TIM1</em>, <em>TIM8</em>, <em>TIM20</em>)</li>\n</ul>\n\n<p>Die folgenden Bilder zeigen die für den Micro-Motor relevanten Features der <em>STM32G4</em>-Serie und stammen aus STs Präsentation “STM32G4 Mainstream MCUs Product Overview”.</p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/microcontrollers_STM32G4_series_product_overview__p10.png\" alt=\"Microcontrollers_STM32G4_series_product_overview.pdf, Seite 10\" /></p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/microcontrollers_STM32G4_series_product_overview__p11.png\" alt=\"Microcontrollers_STM32G4_series_product_overview.pdf, Seite 11\" /></p>\n\n<p><small>Quelle: <a href=\"https://www.st.com/resource/en/product_presentation/microcontrollers_stm32g4_series_product_overview.pdf\">https://www.st.com/resource/en/product_presentation/microcontrollers_stm32g4_series_product_overview.pdf</a></small></p>\n\n<p>Stand 2019/08 sind nur einige wenige Chips aus der <em>STM32G4</em>-Serie verfügbar, für den Micro-Motor kommen <a href=\"https://octopart.com/search?q=STM32G474CET6\"><em>STM32G474CET6</em></a> und <a href=\"https://octopart.com/search?q=STM32G473CET6\"><em>STM32G473CET6</em></a> im <em>LQFP48</em> Gehäuse in Frage.\nIm vom <em>STM32L433CCU</em> bekannten Gehäuse <em>UFQFPN48</em> stehen noch keine Chips zu Verfügung.\nDas Gehäuse <em>LQFP48</em> benötigt zwar mehr Platinenoberfläche als der <em>UFQFPN48</em>, allerdings sind bei letztem Gehäuse durch das Exposed Pad keine Durchkontaktierungen und Leiterbahnen unterhalb des Chips möglich, was den Platzvorteil unter Umständen aufwiegt.</p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/CubeMX_screenshot_STM32G474CE_201909.png\" alt=\"Mögliches Pinout des Microcontrollers STMG474CE, Screenshot aus ST CubeMX Software\" /></p>\n<center><small>Mögliches Pinout des Microcontrollers <i>STM32G474CE</i>, Screenshot aus ST CubeMX Software.</small></center>\n<p><br /></p>\n\n<p>Erfreulicherweise können die ADC- und Komparator-Eingänge zeitgleich genutzt werden, sodass hier keine unnötigen Pins verschwendet werden müssen.</p>\n\n<h3 id=\"komparator\">Komparator</h3>\n\n<p>Da der Komparator im Microcontroller integriert ist, werden keine dedizierten Komparatoren benötigt.\nDas spart viel Platz und reduziert die Komplexität des Platinenlayouts.</p>\n\n<h3 id=\"systemüberblick\">Systemüberblick</h3>\n\n<p>Durch die geänderte Auswahl des Microcontrollers ändert sich das Blockschaltbild geringfügig.</p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/Micro-Motor-V2-Block-diagram_201909.svg\" alt=\"Micro-Motor V2 Blockdiagram, aktualisiert 2019/09\" /></p>\n\n<h3 id=\"stromversorgung\">Stromversorgung</h3>\n\n<p>Die Logik, bzw. alle Komponenten außer den MOSFET-Halb-Brücken und dem Motor, werden über eine separate Spannungsschiene im Roboter mit 6V bis 7V versorgt.\nAus diesen 6V bis 7V müssen lokal 3.3V für den Microcontroller und weitere Elektronik, sowie 5V für Hall-Sensoren und Encoder erzeugt werden.\nDie Logik-Versorgungsspannung bleibt im Gegensatz zu Versorgungsspannung für den Motor bei einem Not-Aus bestehen.</p>\n\n<p>Um alle Komponenten auch ungünstigsten Situationen stabil mit Strom zu versorgen sind sowohl für 3.3V als auch für 5V Spannungsregler mit eine Ausgangsstrom von mindestens 200mA nötig.\nBeispielsweise der CAN-Transceiver <em>TCAN332</em> kann bei einem Bus Fault bis zu 180mA benötigen, auch in diesem Fall muss der Betrieb des Micro-Motors aufrecht erhalten werden.</p>\n\n<p>Der Gatetreiber <em>DRV832x</em>/<em>DRV835x</em> ist mit dem Suffix <em>R</em> erhaltlich, wo ein Schaltregler galvanisch getrennt ins das Gehäuse integriert ist.\nBeim <em>DRV832x</em> handelt es sich um den Buck-Regulator <a href=\"http://www.ti.com/product/LMR16006\">LMR16006X</a>, welcher bei Eingangsspannugen zwischen 4V und 60V ein Spannung zwischen 0,8V bis 60V bei 600mA bereitstellen kann.\nDer in den <em>DRV835x</em> integrierte Buck-Regler <a href=\"http://www.ti.com/product/LM5008A\">LM5008A</a> liefert 2.5V bis 75V bei 350mA bei Eingangsspannugen zwischen 6V und 95V.\nStatt im <em>WQFN32</em> (5x5mm²) Gehäuse kommt der Gatetreiber dann im <em>WQFN40</em> (6x6mm²) Gehäuse, benötigt also 11mm² mehr Platinenfläche zuzüglich der externen Spule, Kondensatoren und Widerständen.</p>\n\n<p>Das hochintegrierte Schaltwandler-Modul <a href=\"http://www.ti.com/product/TPS82150\">TPS82150</a> hat eine integrierte Spule und benötigt im <em>μSiL8</em> Gehäuse lediglich 8.4mm² Platinenfläche.\nZudem kann ein besseres Platinenlayout durch die flexible Platzierung ermöglicht werden.</p>\n\n<p>Für die Versorgung der empfindlichen analogen Elektronik könnte ein dedizierter LDO-Wandler hinter dem 5V Schaltwandler eingesetzt werden, fall ein LC-Filter eine ausreichend rauschfreie Spannungsversorgung ermöglicht.</p>\n\n<h4 id=\"rekuperation\">Rekuperation</h4>\n\n<p>Mit Hilfe von Rekuperation kann sowohl die Wärmeentwicklung im Micro-Motor, als auch die Batterie-Laufzeit des gesamten Roboters verbessert werden.\nEine Begrenzung der Rekuperationsleistung im Micro-Motor ist nicht vorgesehen, da dies zentral im BMS besser lösbar ist.</p>\n\n<h4 id=\"überspannungsschutz\">Überspannungsschutz</h4>\n\n<p>TVS-Dioden an dem Logik- und Motor-Versorgungsspannungen müssen so ausgelegt werden, dass die auf Micro-Motor vorhandenen Spannungsregler bzw. andere direkt verbundenen Bauteile nicht beschädigt werden können.\nUm Rekuperation mit hoher Effizienz zu ermöglichen sollte die Clamping Voltage so hoch wie möglich gewählt werden.</p>\n"
      },
   
      {
        "title"    : "µMotor 2 - Teil 2: Strommessung",
        "category" : "",
        "tags"     : " elektronik, saison20",
        "url"      : "/blog/2019/micro-motor-2-teil-2.html",
        "date"     : "August 30, 2019",
        "excerpt"  : "<p>In diesem Blogpost geht es um die Weiterentwicklung des Motorcontrollers “Micro-Motor” zur Version 2.\nDie bisherige Entwicklung des Motorcontrollers kann in <a href=\"/blog/2019/micro-motor-2-teil-1.html\">mehreren</a> <a href=\"/blog/2018/micro-motor-debugging-inbetriebnahme.html\">älteren</a> <a href=\"/blog/2018/micro-motor-motorcontroller.html\">Blogposts</a> nachgelesen werden.</p>\n",
        "content"  : "<p>In diesem Blogpost geht es um die Weiterentwicklung des Motorcontrollers “Micro-Motor” zur Version 2.\nDie bisherige Entwicklung des Motorcontrollers kann in <a href=\"/blog/2019/micro-motor-2-teil-1.html\">mehreren</a> <a href=\"/blog/2018/micro-motor-debugging-inbetriebnahme.html\">älteren</a> <a href=\"/blog/2018/micro-motor-motorcontroller.html\">Blogposts</a> nachgelesen werden.</p>\n\n<p>Von den im <a href=\"/blog/2019/micro-motor-2-teil-1.html\">vorherigen Blog-Post</a> aufgelisteten Shuntverstärkern sind die beiden Bauteile von Analog Devices (ehem. Linear Technologie) und Texas Instruments in die nähere Auswahl gekommen.\nEs wurden von TIs INA240 Muster bestellt mit Gain 50 und 200, sowie Gain 20 und 50 beim LT1999, da bei diesem keine Variante mit Gain über 50 verfügbar ist.</p>\n\n<p>Als Shunt dient ein 5mΩ 1W 1% SMD-Widerstand in Baugröße 0805 (<a href=\"https://octopart.com/tlr2attd5l00f-koa+speer-27701192\">KOA Speer TLR2ATTD5L00F</a>).\nDurch die kleine Bauform ist ein kompakter Aufbau gewährleistet, wie in den Datenblättern empfohlen (<a href=\"https://www.analog.com/media/en/technical-documentation/data-sheets/1999fd.pdf\">LT1999</a> Seite 16 bzw. <a href=\"http://www.ti.com/lit/ds/symlink/ina240.pdf\">INA240</a> Seite 27).</p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/Versuchsaufbau-LT1999.jpg\" alt=\"Shuntverstärker Versuchsaufbau\" /></p>\n\n<p>Der weitere Messaufbau besteht aus einem <a href=\"/blog/2019/alpha-motor-description.html\">Motor-Controller</a> über welchen Frequenz und Duty-Cycle eingestellt werden können.\nAls Last dient ein 2kW Lastwiderstand mit 9,4Ω nach Ground, wodurch ein Strom von maximal 2,1A bei 20V durch den Shunt fließen.\nDie Induktivität des Aufbaus ist leider nicht bekannt, das keine geeigenten Messgeräte zur Verfügung standen.</p>\n\n<p>An den folgenden Messungen ist leicht zu erkennen, dass der LT1999 in unserem Fall ungeeignet zur Strommessung In-Phase ist.\nDer durch die Common-Mode-Spannungsänderung erzeugte Spike am Ausgang ist größer als das erwartete Mess-Signal,\ngerade bei kleinen Duty-Cycles (&lt;10%) verschwindet der Messwert hier vollständig.</p>\n\n<p>Der Shuntverstärker INA240 eignet zur Strommessung In-Phase, hier ist kein störender Einfluss der Common-Mode-PWM-Signals auf den Ausgang zu beobachten.\nDie Variante INA240A4 mit Gain 200 kann mit einem 5mΩ Shuntwiderstand nur etwa 2A messen, der Messbereich von 10A beim INA240A2 (Gain 50) ist für den Motorcontroller besser geeignet.\nDenkbar wäre es natürlich auch einen kleineren Shuntwiderstand zu wählen, jedoch würde dies aufgrund von stärkeren Einkoppplungen wahrscheinlich schlechtere Ergebnisse liefern.</p>\n\n<p>Auf den Osziloskop-Bildern ist in Gelb der Ausgang des Shuntverstärkers zu sehen.\nAuf Kanal 2 (Blau) ist die Spannung an der Motor-Phase beziehungsweise über dem Last-Widerstand dargestellt.</p>\n\n<h2 id=\"duty-cycle-30\">Duty-Cycle 30%</h2>\n\n<h3 id=\"in-phase\">In-Phase</h3>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/LT1999-20_In-Phase_160kHz_0uH.jpg\" alt=\"Shuntverstärker Messung: LT1999, Gain 20, In-Phase, 160kHz, 0µH\" /></p>\n<center>LT1999, Gain 20, In-Phase, 160kHz, 0µH</center>\n<p><br /></p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/LT1999-50_In-Phase_160kHz_0uH.jpg\" alt=\"Shuntverstärker Messung: LT1999, Gain 50, In-Phase, 160kHz, 0µH\" /></p>\n<center>LT1999, Gain 50, In-Phase, 160kHz, 0µH</center>\n<p><br /></p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/INA240-A2_In-Phase_160kHz-30.bmp\" alt=\"INA240A2, Gain 50, In-Phase, 160kHz, 30%, (negativer Ausschlag, 20V)\" /></p>\n<center>INA240A2, Gain 50, In-Phase, 160kHz, 30%, (negativer Ausschlag, 20V)</center>\n<p><br /></p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/INA240-A2_In-Phase_160kHz-30_12V.bmp\" alt=\"INA240A2, Gain 50, In-Phase, 160kHz, 30%, (negativer Ausschlag, 12V -&gt; 1A)\" /></p>\n<center>INA240A2, Gain 50, In-Phase, 160kHz, 30%, (negativer Ausschlag, 12V -&gt; 1A)</center>\n<p><br /></p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/INA240-A4_In-Phase_160kHz-30_12V.bmp\" alt=\"INA240A4, Gain 200, In-Phase, 160kHz (negativer Ausschlag, 12V -&gt; 1A)\" /></p>\n<center>INA240A4, Gain 200, In-Phase, 160kHz (negativer Ausschlag, 12V -&gt; 1A)</center>\n<p><br /></p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/INA240-A4_In-Phase_160kHz-30.bmp\" alt=\"INA240A4, Gain 200, In-Phase, 160kHz (negativer Ausschlag)\" /></p>\n<center>INA240A4, Gain 200, In-Phase, 160kHz (negativer Ausschlag)</center>\n<p><br /></p>\n\n<!--\n![Shuntverstärker Messung: LT1999, Gain 50, In-Phase, 160kHz, 0µH](../../assets/img/blog/micro-motor/shuntverstaerker-messungen/LT1999-50_In-Phase_160kHz.jpg)\n<center>LT1999, Gain 50, In-Phase, 160kHz, 0µH</center><br />\n\n![Shuntverstärker Messung: LT1999, Gain 50, In-Phase, 80kHz, 0µH](../../assets/img/blog/micro-motor/shuntverstaerker-messungen/LT1999-50_In-Phase_80kHz.jpg)\n<center>LT1999, Gain 50, In-Phase, 80kHz, 0µH</center><br />\n-->\n\n<h3 id=\"low-side\">Low-Side</h3>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/LT1999-20_Low-Side_160kHz_0uH.jpg\" alt=\"Shuntverstärker Messung: LT1999, Gain 20, Low-Side, 160kHz, 0µH\" /></p>\n<center>LT1999, Gain 20, Low-Side, 160kHz, 0µH</center>\n<p><br /></p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/LT1999-50_Low-Side_160kHz.jpg\" alt=\"Shuntverstärker Messung: LT1999, Gain 50, Low-Side, 160kHz, 0µH\" /></p>\n<center>LT1999, Gain 50, Low-Side, 160kHz, 0µH</center>\n<p><br /></p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/INA240-A2_Low-Side_160kHz-30.bmp\" alt=\"INA240A2, Gain 50, Low-Side, 160kHz, 30%, (positiver Ausschlag, 20V)\" /></p>\n<center>INA240A2, Gain 50, Low-Side, 160kHz, 30%, (positiver Ausschlag, 20V)</center>\n<p><br /></p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/INA240-A2_Low-Side_160kHz-30_12V.bmp\" alt=\"INA240A2, Gain 50, Low-Side, 160kHz, 30%, (positiver Ausschlag, 12V -&gt; 1A)\" /></p>\n<center>INA240A2, Gain 50, Low-Side, 160kHz, 30%, (positiver Ausschlag, 12V -&gt; 1A)</center>\n<p><br /></p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/INA240-A4_Low-Side_160kHz-30_12V.bmp\" alt=\"INA240A4, Gain 200, Low-Side, 160kHz (positiver Ausschlag, 12V -&gt; 1A)\" /></p>\n<center>INA240A4, Gain 200, Low-Side, 160kHz (positiver Ausschlag, 12V -&gt; 1A)</center>\n<p><br /></p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/INA240-A4_Low-Side_160kHz-30.bmp\" alt=\"INA240A4, Gain 200, Low-Side, 160kHz (positiver Ausschlag)\" /></p>\n<center>INA240A4, Gain 200, Low-Side, 160kHz (positiver Ausschlag)</center>\n<p><br /></p>\n\n<!--\n![Shuntverstärker Messung: LT1999, Gain 50, Low-Side, 160kHz, 10µH](../../assets/img/blog/micro-motor/shuntverstaerker-messungen/LT1999-50_Low-Side_160kHz_10uH.jpg)\n<center>LT1999, Gain 50, Low-Side, 160kHz, 10µH</center><br />\n\n![Shuntverstärker Messung: LT1999, Gain 50, In-Phase, 160kHz, 10µH](../../assets/img/blog/micro-motor/shuntverstaerker-messungen/LT1999-50_In-Phase_160kHz_10uH.jpg)\n<center>LT1999, Gain 50, In-Phase, 160kHz, 10µH</center><br />\n-->\n\n<h2 id=\"duty-cycle-5\">Duty-Cycle 5%</h2>\n\n<h3 id=\"in-phase-1\">In-Phase</h3>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/LT1999-20_In-Phase_160kHz-5.bmp\" alt=\"LT1999, Gain 20, In-Phase\" /></p>\n<center>LT1999, Gain 20, In-Phase</center>\n<p><br /></p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/LT1999-50_In-Phase_160kHz-5.bmp\" alt=\"LT1999, Gain 50, In-Phase\" /></p>\n<center>LT1999, Gain 50, In-Phase</center>\n<p><br /></p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/INA240-A2_In-Phase_160kHz-5.bmp\" alt=\"INA240A2, Gain 50, In-Phase\" /></p>\n<center>INA240A2, Gain 50, In-Phase</center>\n<p><br /></p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/INA240-A4_In-Phase_160kHz-5.bmp\" alt=\"INA240A4, Gain 200, In-Phase\" /></p>\n<center>INA240A4, Gain 200, In-Phase</center>\n<p><br /></p>\n\n<h3 id=\"low-side-1\">Low-Side</h3>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/LT1999-20_Low-Side_160kHz-5.bmp\" alt=\"LT1999, Gain 20, Low-Side\" /></p>\n<center>LT1999, Gain 20, Low-Side</center>\n<p><br /></p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/LT1999-50_Low-Side_160kHz-5.bmp\" alt=\"LT1999, Gain 50, Low-Side\" /></p>\n<center>LT1999, Gain 50, Low-Side</center>\n<p><br /></p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/INA240-A2_Low-Side_160kHz-5.bmp\" alt=\"INA240A2, Gain 50, Low-Side\" /></p>\n<center>INA240A2, Gain 50, Low-Side</center>\n<p><br /></p>\n\n<p><img src=\"../../assets/img/blog/micro-motor/shuntverstaerker-messungen/INA240-A4_Low-Side_160kHz-5.bmp\" alt=\"INA240A4, Gain 200, Low-Side\" /></p>\n<center>INA240A4, Gain 200, Low-Side</center>\n<p><br /></p>\n"
      },
   
      {
        "title"    : "µMotor 2 - Teil 1: Konzept",
        "category" : "",
        "tags"     : " elektronik, saison20",
        "url"      : "/blog/2019/micro-motor-2-teil-1.html",
        "date"     : "August 18, 2019",
        "excerpt"  : "<p>In diesem Blogpost geht es um die Weiterentwicklung des Motorcontrollers “Micro-Motor” zur Version 2.\nDie bisherige Entwicklung des Motorcontrollers kann in <a href=\"/blog/2019/alpha-motor-description.html\">mehreren</a> <a href=\"/blog/2018/micro-motor-debugging-inbetriebnahme.html\">älteren</a> <a href=\"/blog/2018/micro-motor-motorcontroller.html\">Blogposts</a> nachgelesen werden.</p>\n",
        "content"  : "<p>In diesem Blogpost geht es um die Weiterentwicklung des Motorcontrollers “Micro-Motor” zur Version 2.\nDie bisherige Entwicklung des Motorcontrollers kann in <a href=\"/blog/2019/alpha-motor-description.html\">mehreren</a> <a href=\"/blog/2018/micro-motor-debugging-inbetriebnahme.html\">älteren</a> <a href=\"/blog/2018/micro-motor-motorcontroller.html\">Blogposts</a> nachgelesen werden.</p>\n\n<p><img src=\"../../assets/img/blog/2018/micro-motor-faedeldraht.jpg\" alt=\"Makro-Aufnahme Micro-Motor Fädeldraht\" /></p>\n\n<p>Nachdem der einzige aufgebaute Prototyp des Micro-Motors beim Testen durch einen von einer Oszi-Probe verursachten Kurzschluss am Gatetreiber defekt war, wurde eine minimal modifizierte Schaltung als “Macro-Motor” auf einer größeren Platine aufgebaut um bequemer verschiedene Messungen durchführen zu können.</p>\n\n<p>Auch die Macro-Motor-Platine war leider nicht fehlerfrei. Unter anderem war leider der Footprint des neuen Spannungsreglers im WLCSP-6 (Wafer Level Chip Scale Package; 1x1,6mm²) spiegelverkehrt.\nEbenso war einer der beiden aufgebauten Prototypen nach dem Reflow-Löten nicht funktionsfähig, was auf durch von Hersteller zusätzlich verkleinerte Ausschnitte im Stencil verursachte zu geringe Menge an Lötpaste zurückzuführen war.\nBeim Versuch die nicht verlöteten Pins des Gatetreiber-ICs von Hand nachzulöten ist dieser leider zerstört worden.</p>\n\n<p>Unabhängig von den bisher aufgetretenen Problemen sind neue Wünsche entstanden.\nFür eine <a href=\"/projekt/motor-commutation.html\">intelligente Motor-Kommutierung</a> statt der bisher verwendeten stupiden Block-Kommutierung ist es teilweise nötig die Ström in den Phasen sowie auch die Spannung der Motorphasen zu messen.\nBessere Motor-Kommutierungen erlauben durch Sinus-förmige Ansteuerung mehr und gleichmäßigeres Drehmoment in sehr niedrigen Drehzahlbereichen zu erzeugen sowie auch Motoren ohne Hall-Sensoren anzusteuern.\nAußerdem wurde in der Saison eine präzise und zuverlässige Strommessung sehnlichst vermisst, sodass auch diese ein erklärtes Ziel ist.</p>\n\n<h3 id=\"systemüberblick\">Systemüberblick</h3>\n\n<p><img src=\"../../assets/img/blog/micro-motor/Micro-Motor-V2-Block-diagram_201907.svg\" alt=\"Micro-Motor V2 Blockdiagram\" /></p>\n\n<h3 id=\"komponentenauswahl\">Komponentenauswahl</h3>\n\n<p>Der Microcontroller wird nach bisheriger Planung ein STM32L433CCU im UFQFPN48 Gehäuse bleiben.</p>\n\n<p>Ebenso gibt es keinen Anlass den Gatetreiber <a href=\"http://www.ti.com/product/DRV8323\">DRV8323S</a> auszutauschen, da sich dieser durchgehend bewährt hat.\nEs wird jedoch die Variante ohne integrierte Shuntverstärker verwendet, da die Shuntverstärker ein zu geringes Gain-Bandbreiten-Produkt aufweisen und keine präzise Strommessung zulassen.</p>\n\n<p>Die Spannungswandler werden für 5V und 3,3V werden durch <a href=\"http://www.ti.com/product/TPS82150\">hochintegrierte Schaltwandler-Module</a> ersetzt,\nwelche sich schon beim <a href=\"/blog/2019/alpha-motor-description.html\">Alpha-Motor</a> bewährt haben und auch für leistungshungrige Encoder oder Endschalter genügend Strom liefern kann.</p>\n\n<p>Der bisher vorgesehene I²C-Temperatursensor <a href=\"http://www.ti.com/ww/eu/sensampbook/tmp006.pdf\">TMP006</a> (nicht mehr verfügbar)\nund die I²C-Anschlusspads für externe digitale Sensoren sollen durch einen analogen NTC-Temperatursensor ersetzt werden.\nEin NTC ist kompakter, günstiger, leichter am Motor zu befestigen und hat eine zur Überwachung der Motortemperatur ausreichende Genauigkeit.</p>\n\n<h4 id=\"shuntverstärker-und-komparator\">Shuntverstärker und Komparator</h4>\n\n<p>Neu auf der Liste der Bauteile sind dedizierte Shuntverstärker und Komparatoren.\nHier müssen die verfügbaren Bauteile noch analysiert und verglichen werden.\nEin gutes Rennen bei den Shuntverstärkern liefert aktuell der <a href=\"https://www.analog.com/en/products/lt1999.html\">LT1999</a> von Analog ab.</p>\n\n<p>Da die Strommessung “inline” in den Motorphasen stattfindet muss der Shuntverstärker eine sehr hohe Gleichtaktunterdrückung aufweisen.\nGleichzeitig ist eine hohe Bandbreite von etwa 500 kHz bis 1 MHz gefordert um bei einer PWM-Frequenz noch brauchbare Messwerte zu liefern.\nDie Gleichtaktspannung muss bis zu 24V betragen, außerdem ist neben einem hohen Gain, welcher die Verwendung von niederohmigen Shunt-Widerständen erlaubt, ein kleines Gehäuse gewünscht.</p>\n\n<p>Folgende Shuntverstärker stehen aktuell zur Auswahl:</p>\n\n<p><a href=\"https://www.analog.com/media/en/technical-documentation/data-sheets/1999fd.pdf\"><strong>LT1999</strong></a></p>\n<ul>\n  <li>Gain: Fixed 10, 20 or 50 V/V</li>\n  <li>CMRR: <strong>&gt;80dB @ 100kHz</strong> (V_CM=0V, 7VP-P, f=100kHz); &gt;96dB @ DC</li>\n  <li>Bandwidth: 2MHz</li>\n  <li>Package: MSOP-8</li>\n</ul>\n\n<p><a href=\"https://datasheets.maximintegrated.com/en/ds/MAX40056F-MAX40056U.pdf\"><strong>MAX40056</strong></a></p>\n<ul>\n  <li>Gain: Fixed 10, 20 or 50 V/V</li>\n  <li>CMRR: <strong>typ. 70dB @ 100kHz</strong> (100mV_AC Sine, f=100kHz); &gt;120dB @ DC</li>\n  <li>Bandwidth: 300kHz</li>\n  <li>Package: 2.02mm x 1.4mm WLP-8 and 8-pin μMAX</li>\n</ul>\n\n<p><a href=\"http://www.ti.com/lit/ds/symlink/ina240.pdf\"><strong>INA240</strong></a></p>\n<ul>\n  <li>Gain: Fixed 20, 50, 100 or 200 V/V</li>\n  <li>CMRR: <strong>typ. 93dB @ 50kHz</strong> (f=50kHz); &gt;120dB @ DC</li>\n  <li>Bandwidth: 400kHz</li>\n  <li>Package: TSSOP-8</li>\n</ul>\n\n<p>In den nächsten Wochen werden Samples dieser Chips unter den beim Micro-Motor herrschenden Umgebungsbedingungen getestet und dann ausgewählt.\nSollte sich keiner der verfügbaren Inline-Shuntverstärker als brauchbar erweisen, werden wir Low-Side-Shuntverstärker evaluieren.</p>\n\n<h3 id=\"formfaktor\">Formfaktor</h3>\n\n<p>Im Gegensatz zur Version 1 wird für die zweite Version ein anderer Ansatz gewählt.\nDer integrierte Magnet-Encoder fällt weg, stattdessen gibt es einen <del>gut lötbaren</del> steckbaren Anschluss für externe Encoder<del>, sowohl einfach als auch mit differenziellen Signalen</del>.\nDa durch die kleine Bauform des Micromotors keine langen Kabel zum Encoder nötig sind, wird auf differenzielle Signale verzichtet.\nSollte ein Motor keinen integrierten Encoder haben, kann ein <a href=\"https://github.com/roboterclubaachen/magnet-motor-encoder\">externer magnetischer Encoder</a> auch über dieses Interface angeschlossen werden.</p>\n\n<p>Die Platine bekommt eine rechteckige Form und soll seitlich an den Motoren befestigt werden.\nSo lässt sich der Micro-Motor flexibler an einer Vielzahl von verschiedenen Motoren nutzen.\nDie mechanischen Dimensionen werden sich kaum ändern, angepeilt ist eine Platinenfläche von weniger als 500mm², z.B. 15x25mm².\nDazu wird auch weiterhin eine beidseitige Bestückung notwendig sein.</p>\n\n<h3 id=\"stecker\">Stecker</h3>\n\n<p>Um einen einfach Austausch der Platinen zu ermöglichen sollen keine Kabel fest auf der Platine verlötet werden.\nEs werden sechs Steckverbindungen benötigt:</p>\n<ul>\n  <li>Motor-Anschluss (Phasen U, V, W), 3-polig, &gt;=5A</li>\n  <li>Stromversorgung (20V, 6V und GND), 3-polig, &gt;= 5A</li>\n  <li>CAN Kommunikation (CAN-H, CAN-L), 2- oder 3-polig</li>\n  <li>End-/Referenz-Schalter, 2- oder 3-polig</li>\n  <li>Hall-Sensor (Hall-Phasen U, V, W; GND und 5V/3.3V), 5-polig</li>\n  <li>Encoder (A, B, I; GND und 5/3.3V), 5-polig</li>\n</ul>\n\n<p>Für die leistungsführenden Steckverbinder soll 3-polige <a href=\"https://jst.de/product-family/show/184/xh\">JST XH</a> Stecker verwenden werden.\nDiese sind bis 5A nutzbar, bei höhreren Strömen müssen die Kabel fest verlötet werden und Stecker ins Kabel integriert werden.</p>\n\n<p>Die Signalstecker sollen als 2-/3-polige und 5-polige <a href=\"https://jst.de/product-family/show/89/gh\">JST GH</a> Stecker ausgeführt werden.\nEbenso wie die Leistungsstecker mit 2.5mm Pitch sind diese die Stecker auch in SMT-Bauform erhältlich und bei einem Pitch von 1.25mm deutlich kompakter.</p>\n\n<h3 id=\"weitere-entwicklung\">Weitere Entwicklung</h3>\n\n<p>Noch mehr Probleme und Verbesserungsvorschläge der ersten Revision sind im <a href=\"https://github.com/roboterclubaachen/micro-motor/issues\">Github Issue #1</a> aufgeführt.</p>\n\n<p><em>Der Blog-Post wurde ursprünglich am 27.7.2019 verfasst und zuletzt am 18.8.2019 aktualisiert.</em></p>\n"
      },
   
      {
        "title"    : "Review of Season 2019",
        "category" : "",
        "tags"     : " saison19",
        "url"      : "/blog/2019/Season-2019.html",
        "date"     : "July 25, 2019",
        "excerpt"  : "The preparations started in October 2018, with the publication of the new rules. This years Season were mainly characterized by electrical engineering and software. Due to a stronger generation change within our team, ...",
        "content"  : "<p>This year’s topic in the Eurobot, organized by Planete Sciences from France, was Atom Factory.\nIn short, it was about manipulating ice hockypuks, the so-called atoms.\nThe tasks ranged from simply moving the atoms to grabbing, weighing and sorting them.</p>\n\n<p><img src=\"../../assets/img/blog/2019/eurobot-competition-2019.jpg\" alt=\"Eurobot competition 2019\" /></p>\n\n<p>The preparations started in October 2018, with the publication of the new rules.\nThis years Season was mainly characterized by electrical engineering and software.\nDue to a stronger generation change within our team, there was an enormous loss of knowledge about the technology of the previous years.\nIn order to become competitive again, new members were acquired and trained.\nThe resulting projects were then to flow into this year’s robot.\nTogether for example a new motor driver, our so-called Alphamotor, was developed, optimized and used.\nThe hurdles to be taken here were often not possible without hours of troubleshooting and improvements, which, however, had to be followed by a deeper examination of the matter.\nFurthermore, a completely newly developed positioning system based on ultrasound was used for the first time.\nThis was developed together with a former member of the club and then integrated into our hardware abstraction and communication framework.\nMeanwhile some of our robots software structure got a bigger rework, which seems to be not done yet</p>\n\n<p>But a lot has also changed mechanically in this season.\nThus a complex cartesian working gripper mechanism was designed and built, which can move to all positions necessary for the game with only one arm.\nThe well-proven drive concept was also replaced by an Omiwheel drivetrain for technical and practical reasons.\nThis makes it possible to drive in any direction without changing the alignment of the robot.\nThe necessary mathematical transformations as well as the implementation of these were also done in a very short time.\nThe result at the time of the competitions was a completely new construction, build by members, who compensated the loss of knowledge driven by outgoing members with the learning process during the season.\nSo the club is competitive again.</p>\n\n<p><img src=\"../../assets/img/blog/2019/eurobot-team-in-giessen.jpg\" alt=\"RCA Team im Gießen\" /></p>\n\n<p>In the now following competitions we first went to Gießen from 02.05 to 04.05 this year, where the German preliminary decision for the international competition took place.\nThere, a total of 7 teams from all over Germany competed to reach the first to third place, for which the international competition will continue.\nFortunately our robot homologated and was ready for the competition.\nMany sleepless nights and smoking heads should pay off, so our Team took the 2nd place behind TURAG from Dresden.\nThirdly, the Greenbirds team from Ludwigshafen managed to qualify for the international competition.\nAt the end of May we went from 29.05. to 01.06. to La Roche-Sur-Yon in France.\nThere the national and international competition with nearly 300 French teams took place.\nThe again best 3 teams from France were then also qualified for the international competition.\nA total of 33 teams competed in the international competition.\nIt started with five preliminary rounds in which the aim was to collect the most points.\nThe best 8 teams from these preliminary rounds were then ready to enter the final.\nUnfortunately, we had big problems with our new positioning system to reach defined points and even night-long improvements helped only little to change anything about it.\nTherefore it was only enough for us to finish as 29th Team this year. The Eurobot was won by Team PMG Robotics from Serbia.\nDespite the sobering result, the members are proud of what they achieved in the short time and motivated to give everything to win the Eurobot in the upcoming season.</p>\n\n<p><img src=\"../../assets/img/blog/2019/eurobot-team-in-france.jpg\" alt=\"RCA Team im La-Roche-sur-Yon\" /></p>\n"
      },
   
      {
        "title"    : "Alpha-Motor: Ein neues Motorboard",
        "category" : "",
        "tags"     : " elektronik, saison19",
        "url"      : "/blog/2019/alpha-motor-description.html",
        "date"     : "May 9, 2019",
        "excerpt"  : "In der Saison 2019 ist unsere Elektronik fast vollständig überarbeitet oder sogar neu entwickelt. Eine der Neuentwicklungen ist unser neues Motorcontrol-Board, genannt Alpha-Motor.",
        "content"  : "<p>In der Saison 2019 ist unsere Elektronik fast vollständig überarbeitet oder sogar neu entwickelt.\nEine der Neuentwicklungen ist unser neues Motorcontrol-Board, genannt Alpha-Motor.\nDer Name bricht mit dem Schema, das vorher verwendet wurde: Auf den <em>iMotor</em> folgte der <em>2Motor</em>, wiederum gefolgt vom <em>3Motor</em>.\nDer Alpha-Motor kann anders als sein direkter Vorgänger nur zwei DC- oder BLDC-Motoren antreiben.\nDafür wurden mehrere Features hinzugefügt, die den Roboter leistungsfähiger und besser kontrollierbar machen.\nDie wohl wichtigste Änderung betrifft die Ausgangsstufen.\nWo vorher vollintegrierte Chips verwendet wurden, sitzen nun simple Motortreiber-ICs (MIC4606), die Leistungstransistoren steuern.\nDie Leistungsabgabe kann mit diesem simpleren Design verdoppelt werden, da Abwärme besser abgestrahlt wird. Für ein proof-of-concept der neuen Bauelemente wurde ein Testboard entwickelt.</p>\n\n<p><img src=\"../../assets/img/blog/alpha-motor/AlphaMotor_Testboard.jpg\" alt=\"Alpha-Motor Testboard\" /></p>\n\n<p>Hier ist bereits zu sehen, dass die Ansteuerung nicht sehr komplex ist, da einfach ein Timer des Mikrocontrollers über drei komplementäre Ausgänge einen Motor steuern kann.\nDie Verwendung einer SPI-Verbindung oder ähnlichem um mit den Endstufen zu kommunizieren entfällt.\nEs ist jetzt noch leichter die Kontrolle zu behalten, da eine neue Strommessung für jeden Motor hinzugefügt wurde, die mit 1 MHz Abtastrate den Strom durch die Schaltbrücken begrenzen kann.\nDer Spannungsabfall über einen Shunt-Widerstand wird in einem Komparator mit der frei verstellbaren Vorgabe verglichen und das Ergebnis auf den asynchronen Break-Input des Mikrocontrollers gegeben.\nDas Ergebnis ist eine effektive Stromregelung.\nZusätzlich wird in jeweils zwei der drei Phasen die Stromstärke mit Hall-Sensoren gemessen, um eine sinusförmige Kommutierung statt einer einfacheren blöckförmigen zu ermöglichen.\nDie Hauptaufgabe der Schaltung wird jetzt also besser erfüllt, ohne auf Funktionalität verzichten zu müssen.</p>\n\n<p><img src=\"../../assets/img/blog/alpha-motor/AlphaMotor_Haupt.jpg\" alt=\"Alpha-Motor Platine\" /></p>\n\n<p>Neben der Steuerung von Motoren, ist der Alpha-Motor wie sein Vorgänger das Gehirn des Roboters.\nÜber zwei CAN-Busse werden die Befehle vom Master-Board zu den Slaves geschickt und eine serielle Schnittstelle und einen SWD-Port (Serial-Wire-Debug) kommuniziert mit unserem Debugger, über den nicht nur Events geloggt werden können, sondern der Roboter auch over-the-air neue Software erhält.\nDa weiterhin der gleiche Mikrocontroller verwendet wird, ist grundsätzlich die Verwendung zusammen mit älteren Boards möglich um im Notfall eine Ausweichmöglichkeit zu haben.</p>\n\n<p><img src=\"../../assets/img/blog/alpha-motor/AlphaMotor_Antrieb.jpg\" alt=\"Antrieb mit Alpha-Motor Platinen im Roboter &quot;Marie&quot;\" /></p>\n"
      },
   
      {
        "title"    : "µMotor: Inbetriebnahme und Debugging",
        "category" : "",
        "tags"     : " elektronik, saison19",
        "url"      : "/blog/2018/micro-motor-debugging-inbetriebnahme.html",
        "date"     : "October 6, 2018",
        "excerpt"  : "<p>Die Idee zur Entwicklung des <a href=\"/blog/2018/micro-motor-motorcontroller.html\">µMotors</a> ist schon älter.\nDamals, als die Auswahl der Komponenten noch geschah, wurde im RCA fast zeitgleich auch der größere Bruder des µMotors, der Alpha-Motor, entworfen.</p>\n",
        "content"  : "<p>Die Idee zur Entwicklung des <a href=\"/blog/2018/micro-motor-motorcontroller.html\">µMotors</a> ist schon älter.\nDamals, als die Auswahl der Komponenten noch geschah, wurde im RCA fast zeitgleich auch der größere Bruder des µMotors, der Alpha-Motor, entworfen.</p>\n\n<p>Beim Design der Leistungselektronik fiel die Wahl des MOSFET-Gatetreibers auf den <a href=\"http://ww1.microchip.com/downloads/en/DeviceDoc/20005604B.pdf\">MIC4606</a> in Kombination mit den <a href=\"https://www.vishay.com/docs/68550/sqjb40ep.pdf\">SQJB40EP</a> MOSFETs von Vishay.\n(Vielen Dank an dieser Stelle an Vishay für das unkomplizierte und schnell zur Verfügung stellen von Samples.)</p>\n\n<p>Um die Eignung der ausgewählten Komponenten zu verifizieren wurde eine Testplatine entworfen, welche außerdem eine schöne und lehrreiche Aufgabe für zwei neue, bisher nicht mit dem Platinendesign vertrauten Mitgliedern des Roboterclubs darstellte.\nDie Testplatine enthielt neben den MOSFET-Treibern und MOSFETs selbst nur Stecker, Testpunkte, die nötige passive Beschaltung aus Widerständen und Kondensatoren sowie die Spannungsversorgung.</p>\n\n<p><img src=\"../../assets/img/blog/2018/alpha-motor-testboard.jpg\" alt=\"Testplatine für MIC4606\" /></p>\n\n<p>In Kombination mit einem Entwicklungs-Board für Microcontroller, in unserem Fall das [STM32F4Discovery], wurde die Ansteuerung von DC und BLDC Motoren erfolgreich getestet.</p>\n\n<p>Dadurch wurde der MIC4606 Chip für den Alpha-Motor ausgewählt und war auch für den Micro-Motor vorgesehen.\nIm Laufe der weiteren Komponentenauswahl für den Micro-Motor stellten sich die mechanischen Dimensionen des Chips allerdings als zu groß heraus und der <a href=\"http://www.ti.com/lit/ds/symlink/drv8323.pdf\">DRV8323</a> Gate-Treiber bot einen insgesamt kleineren Footprint.\nDer Chip selbst ist größer (6x6mm² WQFN zu 4x4mm² QFN), allerdings wird deutlich weniger externe Beschaltung (u.A. keine Gate-Serienwiderstände, keine Bootstrap-Kondensatoren) benötigt und drei Strommessverstärker sind direkt integriert.</p>\n\n<p>Der DRV8323 ist zugleich auch wesentlich komplexer als des MIC4606, statt einer <a href=\"https://de.wikipedia.org/wiki/Bootstrapping_(Elektrotechnik)\">Bootstrap-Schaltung</a> zur Ansteuerung der High-Side-MOSFETs integriert der Chip eine <a href=\"https://de.wikipedia.org/wiki/Ladungspumpe\">Ladungspumpe</a> und viele Parameter wie Gate-Serienwiderstände, Überstom-Abschaltung und die integrierten Strommessverstärker lassen sich beim DRV8323 digital über ein SPI-Interface konfigurieren.</p>\n\n<p>Trotzdem wurde es nicht als nötig erachtet für den DRV8323 Chip eine simple Testplatine zu entwerfen, was sich im Verlauf als Fehlentscheidung herausstellte.</p>\n\n<p>Nervig wurde die Situation bereits beim Schreiben des <a href=\"https://github.com/modm-io/modm/pull/27\">modm.io-Treibers</a>.\nEs ist meist hilfreich mit einem Logic-Analyser oder Oszilloskop de SPI-Bus auf der Platine an Testpunkten abgreifen und beobachten zu können.\nLeider passten auf die Platine des Micro-Motors keine Testpunkte, manche der Leiterbahnen waren nicht einmal auf zugänglichen Außenlagen der Platine, sondern ausschließlich unter Chips und auf den Innenlagen geführt.\nSomit musste filigraner Fädeldraht an die kleinen Lötperlen an den Außenkanten der QFN/DFN-Pads des Chips anlöten werden um an diesem Fädeldraht dann die Signale mit Logic-Analyser und Oszilloskop ab zugreifen.</p>\n\n<p><img src=\"../../assets/img/blog/2018/micro-motor-faedeldraht.jpg\" alt=\"Makro-Aufnahme Micro-Motor Fädeldraht\" /></p>\n\n<p>Dabei wurde das erste Problem recht schnell deutlich: Die MISO-Leitung des DRV8323 ist ungewöhlicherweise als <a href=\"https://de.wikipedia.org/wiki/Open-Collector-Ausgang\">Open-Drain</a> und nicht wie üblich als <a href=\"https://de.wikipedia.org/wiki/Gegentaktendstufe\">Push-Pull-Stufe</a> ausgeführt, infolgedessen wird ein externer Pull-Up-Widerstand benötigt.\nUm diesen Widerstand einzusparen sollte der intern zuschaltbare <a href=\"https://de.wikipedia.org/wiki/Pull-up-Widerstand\">Pull-Up Widerstand</a> im STM32 Microcontroller genutzt werden.\nLeider ist der Widerstand dieses Pull-Ups (laut Datenblatt 30 Kiloohm bis 70 Kiloohm viel zu groß für die minimal konfigurierbare SPI-Frequenz (mehrere 100kHz) des STM32L433 Microcontrollers.\nFolglich musste neben dem Fädeldraht für die Messinstrumente noch ein 10 Kiloohm Pull-Up-Widerstand mit Fädeldraht nachgerüstet werden.\nDas Löten war schon fast zur Routine geworden, da sich der Fädeldraht in der Zwischenzeit mehrfach gelöst hatte.</p>\n\n<p><img src=\"../../assets/img/blog/2018/micro-motor-testaufbau.jpg\" alt=\"Micro-Motor Testaufbau mit zwei Oszilloskopen und zwei Netzteilen\" /></p>\n\n<p>In Endeffekt hat die vorhandene Hardware aber ihre Inbetriebnahme und die Software-Entwicklung unter Zusatzaufwand ermöglicht.</p>\n\n<p><img src=\"../../assets/img/blog/2018/qfn-dfn-pad.jpg\" alt=\"Makro-Aufnahme: Pad eines DFN/QFN-Chips\" /></p>\n\n<p>Bis letzte Woche ein merkwürdiges Verhalten der PWM-Waveform bei der Ansteuerung von BLDC-Motoren auftrat.\nZum lokalisieren des Fehlers wurden neben den Signalen an den Motorphasen auch die Signale der Gates vor und nach dem Gatetreiber betrachtet.\nAuch diese Signale sind nur an den seitlichen Pads von QFN-Chips ab zugreifen.\nDer Pad-Pitch beträgt hier 0,5 mm, also etwa gleich dem Durchmesser des Spitze der Oszilloskop-Probe.\nNatürlich rutschte die Spitze ab und verursachte einen Kurzschluss, welcher vom Gatetreiber mit erhöhten Stromverbrauch und Rauchentwicklung quittiert wurde.</p>\n\n<p>Schnell war die Entscheidung getroffen um weitere Zerstörung zu verhindern nun doch eine Testplatine für den DRV8323-Chip zu konstruieren.</p>\n\n<p>Da es für den verwendeten Microcontroller kein Entwicklungs-Board vom Hersteller gibt wurde dieser integriert, der Schaltplan ist daher fast identisch mit dem des Micro-Motors.\nDie Platinengröße wurde von einem Kreis mit Durchmesser von 20 mm auf ein Rechteck von 100 mm x 33 mm erweitert um Platz für die etwa 50 Testpunkte zu bieten.</p>\n\n<p><img src=\"../../assets/img/blog/2018/macro-motor-pcb.png\" alt=\"Macro-Motor Testplatine\" /></p>\n\n<p>Der Name ist entsprechend auch nicht weit von Micro-Motor entfernt gewählt: <em>Macro-Motor</em>.</p>\n\n<p>Dank der schnellen Platinenfertigung von Aisler reicht eine gute Woche Wartezeit aus, bis die neue Testplatine in unserer Werkstatt liegen wird.</p>\n"
      },
   
      {
        "title"    : "Saisonstart 2019",
        "category" : "",
        "tags"     : " eurobot, saison19",
        "url"      : "/blog/2018/saisonstart-2019.html",
        "date"     : "September 18, 2018",
        "excerpt"  : "<p>Am letzten Wochenende wurden die Regeln für die kommende Eurobot-Saison erstmals veröffentlicht.\nDas Regelwerk ist noch im Beta-Status, kann aber schon auf <a href=\"http://www.eurobot.org/eurobot/eurobot-2019/eurobot-2019-rules\">eurobot.org</a> gelesen werden.</p>\n",
        "content"  : "<p>Am letzten Wochenende wurden die Regeln für die kommende Eurobot-Saison erstmals veröffentlicht.\nDas Regelwerk ist noch im Beta-Status, kann aber schon auf <a href=\"http://www.eurobot.org/eurobot/eurobot-2019/eurobot-2019-rules\">eurobot.org</a> gelesen werden.</p>\n\n<p><img src=\"/assets/img/blog/2018/eurobot-2019-field.png\" alt=\"\" /></p>\n\n<p>Wir freuen uns schon auf die kreative Phase in den kommenden Wochen, wenn wir die Konzepte entwickeln und Anfangen Roboter zu konstruieren.</p>\n\n<h2 id=\"mitmachen\">Mitmachen</h2>\n\n<p>Die nächste Zeit ist ideal zum Einstieg für Interessenten.\nWir haben eine Menge <a href=\"http://www.roboterclub.rwth-aachen.de/mach-mit/\">Projekte</a> für die wir motivierte Studenten suchen, egal in welchem Semester oder Studiengang.</p>\n\n<p>Wenn wir dein Interesse geweckt haben, komme Dienstag abends bei unserem <a href=\"http://www.roboterclub.rwth-aachen.de/kontakt/\">wöchentlichen Meeting</a> vorbei und lerne uns kennen.</p>\n"
      },
   
      {
        "title"    : "µMotor",
        "category" : "",
        "tags"     : " elektronik, informatik, saison19",
        "url"      : "/blog/2018/micro-motor-motorcontroller.html",
        "date"     : "May 5, 2018",
        "excerpt"  : "Die Idee ist schon älter, aber nun haben wir uns an die Umsetzung gewagt:  Ein miniaturisierter Motorcontroller, welche dezentral direkt an jeden Motor verbaut wird...",
        "content"  : "<h2 id=\"idee\">Idee</h2>\n\n<p>Die Idee ist schon älter, aber nun haben wir uns an die Umsetzung gewagt:<br />\nEin miniaturisierter Motorcontroller, welche dezentral direkt an jeden Motor verbaut wird\nund nur an Strom und CAN-Bus angeschlossen werden muss.</p>\n\n<h2 id=\"anforderungen\">Anforderungen</h2>\n\n<p>Die Anforderungen haben wir in den letzten Jahren gesammelt:</p>\n<ul>\n  <li><del>2 Phasen (nur DC Motoren) oder</del> 3 Phasen (DC und BLDC Motoren)</li>\n  <li>ca. 10A pro Phase</li>\n  <li>20V Betriebsspannung (Akku) -&gt; 40V oder 60V Auslegung</li>\n  <li>Anschluss für Encoder mit AB(I)-Interface</li>\n  <li>optional Magnetencoder auf dem PCB</li>\n  <li>Anschluss für Hall-Sensor</li>\n  <li>Temperatursensor (kontaktlos auf dem PCB verlötet oder I²C)</li>\n  <li>Strommessung</li>\n  <li>LEDs für Software-Status &amp; Encoderstatus</li>\n  <li>Konfigurierbare ID (ggf. STM32-Hardware-ID)</li>\n  <li>Einfach lötbar und aufbaubar</li>\n  <li>Abmessungen: Rund, Grund-Ø 20mm (Namiki-Motoren: Ø 22mm)</li>\n</ul>\n\n<h2 id=\"komponentenauswahl\">Komponentenauswahl</h2>\n\n<p><img src=\"/assets/img/blog/micro-motor/umotor-pcb.jpg\" alt=\"Er ist uns beim Waschen leider etwas eingegangen. Funktioniert aber trotzdem noch.\" /></p>\n\n<p>Als nächsten Schritt mussten wir die Komponenten auswählen.\nDie Wahl des Mikrocontrollers fiel schnell und wenig überraschen auf einen STM32, konkret einen <a href=\"http://www.st.com/en/microcontrollers/stm32l433cc.html\">STM32L433CCU</a> im 7x7mm²-UFQFPN48 Gehäuse.\nGeeignete MOSFETs und MOSFET-Treiber auszuwählen gestaltete sich als deutlich komplizierter.\nEine große Herausforderung ist die kleine Baugröße von nur Ø 20mm.\nRecht schnell war klar, dass dies nur realisierbar ist mit Komponenten welche Reflow-Löten erfordern,\nsomit waren DFN-Gehäuse nicht mehr wie bei früheren Projekten im RCA unerwünscht.</p>\n\n<p>Das Anschluss ist ein 5-poliger Stecker mit CAN-Bus (2 Pins), Versorgungsspannung (12-40V), Logikspannung zu Versorgung des Controllers und natürlich Ground (GND).\nDie Logikspannung ist von der Versorgungsspannung getrennt, da letztere möglicherweise durch Not-Aus-Schaltkreise deaktiviert werden kann, wobei die Controller aktiv bleiben sollen.</p>\n\n<p>Schlussendlich haben wir nach wochenlanger Recherche den <a href=\"http://www.ti.com/product/drv8323\">DRV8323S</a> von Texas Intruments als MOSFET-Treiber ausgewählt.\nDie entscheidenden Merkmale neben dem kompakten 6x6mm²-40WQFN Gehäuse die geringe Anzahl der benötigten externen Widerstände und Kondensatoren sowie das SPI-Interface über welches alle Parameter konfiguriert werden können.\nEines der Parameter ist der Gate-Drive-Strom, dadurch können Widerstände in den Gate-Leitungen zu den MOSFETs entfallen.\nEin weiterer Vorteil ist die Ladungspumpe zur Ansteuerung der High-Side-MOSFETs welche 100% PWM-Dutycycle erlaubt in Kontrast zu Bootstrap-Schaltungen bei Alternativkomponenten.\nMit Shunt-Widerstände in zwei der drei Motor-Phasen, einem Shunt-Widerstand welche den Gesamtstrom misst und den drei integrierten Strom-Messverstärkern des Gatetreibers wird die Strommesssung und eine Cycle-by-Cycle Strombegrenzung realisiert.</p>\n\n<p>Die Wahl der MOSFETs fiel auf den Typ <a href=\"http://www.onsemi.com/PowerSolutions/product.do?id=FDMD8260L\">FDMD8260L</a>:</p>\n<ul>\n  <li>Zwei n-Channel MOSFETs im 3.3x5mm²-DFN12 Gehäuse</li>\n  <li>V_DS 60V, R_DSon 5.8 mΩ</li>\n  <li>I_D 40A (continuous max.)</li>\n</ul>\n\n<p>Aus der Rückseite befindet sich der Magnetencoder <a href=\"https://ams.com/AS5045\">AS5045B</a> von AMS,\nden wir vorher schon alleinstehend verwendet haben.\nFalls der Motor einen Encoder mitbringt kann dieser Chip nicht bestückt werden und stattdessen der Motorencoder über Lötpads unterhalb des Magnetencoder-Footprints angelötet werden.\nFür externe Motorencoder wurde zus#tzlich ein ansonsten nicht benötigter 5V-Spannungsregler vorgesehen.</p>\n\n<p>Daneben sind auf der Platine nur ein CAN-Bus-Transceiver (<a href=\"http://www.ti.com/product/tcan332\">TCAN332</a>) und Spannungsregler verbaut,\nwelche aufgrund der kleinen Bauform ausgewählt wurden.</p>\n\n<h2 id=\"schaltplan-und-layout\">Schaltplan und Layout</h2>\n\n<p><img src=\"/assets/img/blog/micro-motor/schematic-overview-screenshot.jpg\" alt=\"Schaltplanübersicht micro-motor (µMotor) in KiCad\" />\n<img src=\"/assets/img/blog/micro-motor/pcb-layout-screenshot.jpg\" alt=\"PCB Layout micro-motor (µMotor) in KiCad\" /></p>\n\n<p>Aus den Anforderungen und Überlegungen sind in den vergangenen Monaten Schaltpläne und ein kompaktes Platinenlayout entstanden.\nDas Platinenlayout ist 4-lagig ausgeführt, anders wäre die geforderte Bauform nicht umsetzbar gewesen.</p>\n\n<h2 id=\"aufbau-und-inbetriebnahme\">Aufbau und Inbetriebnahme</h2>\n\n<p>Der erste Aufbau mit Reflow-Ofen und die Inbetriebnahme gestalten sich als nicht trivial,\nweil es auf der winzigen Platine kaum möglich ist elektrische oder Software- Probleme mit Multimeter, Oszilloskop oder Logicanalyser zu debuggen.\nEinige Leitungen sind nur unter Bauteilen und auf den inneren Lagen geführt.</p>\n\n<p><img src=\"/assets/img/blog/micro-motor/pcb-assembled-before-reflow-onecent.jpg\" alt=\"micro-motor (µMotor) vor dem Reflow-Löten. Ein-Cent-Münze zum Größenvergleich.\" />\n<img src=\"/assets/img/blog/micro-motor/reflow-ofen.jpg\" alt=\"micro-motor (µMotor) im Reflow Ofen\" /></p>\n\n<p>Der erste und einzige aufgebaute Prototyp funktioniert weitgehend.\nder bisher einzige Hardwarefehler konnte mit Hilfe von Fädeldraht und einem zusätzlichen Widerstand behoben werden.</p>\n\n<h2 id=\"software\">Software</h2>\n\n<p>Die Software auf dem Mikrocontroller wird mit <a href=\"http://modm.io/\">modm</a> entwickelt.\nBisher sind die Hardware-Abstraktion (Board-Support-Package) und einige Testprogramme für die Inbetriebnahme der Hardware fertiggestellt.</p>\n\n<p>Die Hauptsoftware fehlt noch.</p>\n\n<p>Auf dem Microcontroller sollen frei konfigurierbare Pid-Regler und ggf. auch “Motor-mit-Endschalter”-Komponenten,\nwelche den Aktor parametrierbar initialisieren und verfahren können, das Interface nach außen bilden.</p>\n\n<p>Programiert werden muss der Micro-Motor über den 3D-gedruckten Programieradapter mit Federkontaktstiften.\nDer Adapter verfügt außerdem über eine Pin zum abgreifen der UART-Ausgabe zu Debug-Zwecken.</p>\n\n<p><img src=\"/assets/img/blog/micro-motor/swd-adapter.jpg\" alt=\"Programieradapter für den micro-motor (µMotor)\" /></p>\n\n<h2 id=\"ausblick\">Ausblick</h2>\n\n<p>In den nächsten Wochen werden wir die Hardware vollstandig testen, Software implementieren, Messungen vornehmen und Dokumentation schreiben.</p>\n\n<p>Zeitnah werden wir den Quellcode, Schaltplan, Platinenlayout und mechanische CAD-Modelle unter einer OpenSource Lizenz veröffentlichen.</p>\n\n<p>To be continued…</p>\n"
      },
   
      {
        "title"    : "Saisonstart 2018",
        "category" : "",
        "tags"     : " eurobot, saison18",
        "url"      : "/blog/2017/saisonstart-2018.html",
        "date"     : "October 23, 2017",
        "excerpt"  : "<p>Die Entwicklungsphase für die Saison 2018 ist gestartet.\nDieses Jahr steht der Eurobot unter dem Motto “Robot Cities”.</p>\n",
        "content"  : "<p>Die Entwicklungsphase für die Saison 2018 ist gestartet.\nDieses Jahr steht der Eurobot unter dem Motto “Robot Cities”.</p>\n\n<p><img src=\"/assets/img/blog/robo_antrieb.jpg\" alt=\"\" /></p>\n\n<p>Wir haben schonmal einen neuen Allradantrieb konstruiert, hilf uns mit ihn zu bauen.</p>\n"
      },
   
      {
        "title"    : "We are German champion 2017",
        "category" : "",
        "tags"     : " eurobot, saison17",
        "url"      : "/blog/2017/we-are-german-champion-2017.html",
        "date"     : "May 1, 2017",
        "excerpt"  : "<p>We are qualified for the international contest in France!</p>\n",
        "content"  : "<p>We are qualified for the international contest in France!</p>\n\n<p><img src=\"/assets/img/blog/2017/PR_Eurobot2017_Siegerfoto_Dresden.jpg\" alt=\"Eurobot 2017 Siegerfoto Dresden\" /></p>\n\n<p>Our robots, Juri and Siggi, won nearly every game at the German Eurobot contest 2018 in Dresden.\nThe competition was well organized by TURAG. Thank you for the great time!</p>\n\n<p><img src=\"/assets/img/blog/2017/Juri_Siggi_Rooftop_Back.jpg\" alt=\"Juri Siggi Rooftop Back\" /></p>\n\n<p>We would like to thank our sponsors and supporters for their generous backing.</p>\n\n<p><img src=\"/assets/img/blog/2017/Juri_Siggi_Rooftop_Front.jpg\" alt=\"Juri Siggi Rooftop Front\" /></p>\n"
      },
   
      {
        "title"    : "We are German champion 2016",
        "category" : "",
        "tags"     : " eurobot, saison17",
        "url"      : "/blog/2016/we-are-german-champion-2016.html",
        "date"     : "May 3, 2016",
        "excerpt"  : "<p>We are qualified for the international contest in France!\nOur robots, Hassel and Hoff, won every game at the German Eurobot contest 2016 in Stuttgart.</p>\n",
        "content"  : "<p>We are qualified for the international contest in France!\nOur robots, Hassel and Hoff, won every game at the German Eurobot contest 2016 in Stuttgart.</p>\n\n<p>The competition was well organized by VtAS. Thank you for the great time!</p>\n\n<p>We would like to thank our sponsors for their generous support.</p>\n\n<p><img src=\"/assets/img/blog/2016/Foto2016StuttgartCropped.jpg\" alt=\"RCA in Stuttgart 2016\" /></p>\n\n<p><img src=\"/assets/img/blog/2016/2016HasselHoff.jpg\" alt=\"Roboter Hassel und Hoff\" /></p>\n"
      },
   
      {
        "title"    : "The Rules for Eurobot 2016 are published",
        "category" : "",
        "tags"     : " eurobot, saison16",
        "url"      : "/blog/2015/rules-eurobot-2016.html",
        "date"     : "October 20, 2015",
        "excerpt"  : "<p>The new theme for Eurobot 2016 is “The Beach Bots”. There are many actions for the Robots to do and many parts to move. We are already brainstorming and looking forward to exiting games.</p>\n",
        "content"  : "<p>The new theme for Eurobot 2016 is “The Beach Bots”. There are many actions for the Robots to do and many parts to move. We are already brainstorming and looking forward to exiting games.</p>\n\n<p><img src=\"/assets/img/blog/2016/phobos_in_castle.jpg\" alt=\"Phobos in castle\" /></p>\n"
      },
   
   
   
     {
       
          "title"    : "Projekt: 3D-Drucker Octoprint",
          "category" : "Projekt",
          "tags"     : " software, 3d-druck",
          "url"      : "/projekt/3d-drucker-octoprint.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Einrichten und konfigurieren der Software Octoprint zum Betrieb des 3D-Druckers.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Der 3D-Drucker soll an einen Raspberry Pi angeschlossen werden, welcher mit der Software Octoprint [1] als Server fungiert und darüber den 3D-Drucker steuern kann.</p>\n\n<p>Primär soll das Drucken von den CAD-Workstations mit wenigen Klicks zu starten sein, ebenfalls ist es wünschenswert von jedem beliebigen PC oder Laptop Druckaufträge zu erteilen und zu überwachen.</p>\n\n<p>Weitere optional umsetzbare Features sind ein Touch-Display direkt am Drucker, eine Kamera-Überwachung im Druckergehäuse sowie eine gut sichtbare LED-Statusanzeige am Drucker.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Raspberry Pi</li>\n  <li>Linux</li>\n  <li>3D-Druck</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: 3dDrive",
          "category" : "Projekt",
          "tags"     : " mechanik",
          "url"      : "/projekt/3d-drive.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "3dDrive ist neues Konzept für ein Roboterfahrwerk, das in beliebige Richtung mit optimaler Beschleunigung fahren kann.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Der Differentialantrieb [1] ist der etablierte Stand der Technik im Eurobot.</p>\n\n<p>Beim Differentialantrieb werden zwei Räder auf gleicher Achse mit zwei Motoren separat angetrieben. Das Steuerprinzip ähnelt dem eines Panzers.\nNeben einfacher Steuerung und stabilem Fahrverhalten zeichnet sich der Differentialantrieb durch eine kompakte (abgeschlossene) Bauweise und die Möglichkeit, Odometrie für die Lokalisierung zu benutzen, aus.</p>\n\n<p>Da wir zur Zeit ein globales Positionierungssystem entwickeln, können auch Konzepte für neuartige Fahrwerke erprobt werden, z.B. 3dDrive. Bei dieser Antriebsart soll der Roboter drei Räder haben, die (ähnlich wie bei einem Einkaufswagen) frei verdreht werden können und angetrieben sind. Dadurch werden eine hohe Antriebsleistung und Manövrierfähigkeit erreicht.</p>\n\n<p>In Rahmen dieses Projektes soll das Konzept verfeinert und erforscht werden. Es sollen mögliche Wirkprinzipien und Implementierungen bewertet werden. Ein Prototyp soll konstruiert und aufgebaut werden.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>3 Motoren (2 Lenkung, 1 Antrieb)</li>\n  <li>Beschleunigung über 1g und Geschwindigkeiten bis 2.5 m/s</li>\n  <li>Modulare Bauweise</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>CAD Entwicklung und Konstruktion</li>\n  <li>CAM</li>\n  <li>Auslegung mechanischer, elektrischer und evtl. pneumatischer Komponenten</li>\n  <li>Entwicklung getriebetechnischer Komponenten für die Lenkung mit 2 Motoren</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Aktorik für Spielelemente",
          "category" : "Projekt",
          "tags"     : " mechanik",
          "url"      : "/projekt/aktorik.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Erfindung, Konstruktion und Fertigung von Greif-, Transport- und Lagersystemen für die Spielelemente der Saison 2019.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Im Eurobot-Wettbewerb müssen die Roboter regelmäßig verschiedene Objekte greifen, transportieren und nach bestimmten\nKriterien anordnen. Dazu sind kreative mechanische Lösungen notwendig, um die Aufgaben mit möglichst hoher\nGeschwindigkeit und Zuverlässigkeit innerhalb des eingeschränkten Bauraums der Roboter zu erledigen.</p>\n\n<p>Die Spielelemente waren in der Vergangenheit z.B. lackierte Holzbauklötze, Kunststoff-Zylinder, Bälle in verschiedenen\nGrößen und Materialien, Puks, CDs, Becher, Textilien, Flaschen  und ähnliches. Ähnlich zu industriellen\nAutomatisieungsaufgaben mussten diese innerhalb der 100 Sekunden eines Spiels oft an einer Stelle des Spielfeldes\neingesammelt und an einer  anderen wieder abgelegt werden und dabei z.B. nach Größe oder Farbe sortiert, geschossen\noder gestapelt werden. Dabei ist es oft erstrebenswert, möglichst viele der Elemente in den Roboter zu laden und\ngemeinsam zu transportieren. Zum Handling können z.B. aktive oder passive Greifer, Walzen, Bänder, Ketten- oder\nSchienensysteme, Gebläse, Saugnäpfe, usw. verbaut werden.</p>\n\n<p>Die Spezifikationen der Spielelemente und die damit zu lösenden Aufgaben werden mit Veröffentlichung der Regeln der\nneuen Wettbewerbssaison im September 2018 bekannt.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Erfinden von kreativen mechanischen Konzepten</li>\n  <li>„Basteln“ von Prototypen aus Holz (und Heißkleber)</li>\n  <li>CAD-Konstruktion mit SolidWorks</li>\n  <li>Fertigung von Aluminium- (mit CNC-Fräse) oder 3D-Druck-Teilen</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Alpha-Motor",
          "category" : "Projekt",
          "tags"     : " elektronik, pcb",
          "url"      : "/projekt/alpha-motor.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Alpha-Motor ist eine Platine zur Ansteuerung von zwei Antriebsmotoren und momentan die Hauptplatine des Roboters.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Der Alpha-Motor erfüllt mehrere Funktionen gleichzeitig: Ansteuern von ein oder zwei Motoren, etwa den Antriebsmotoren des Roboters, Odometrie und das Ausführen der Robotersoftware.</p>\n\n<p>Jede Platine verfügt dazu über ein Setup, das sowohl ein oder zwei DC-Motoren als auch ein oder zwei dreiphasige Brushless-DC Motoren unterstützt.\nBenötigt werden also sechs H-Brücken aus jeweils vier Leistungstransistoren, die von drei Brückentreibern kontrolliert werden.\nDas Herzstück ist dann der Mikrocontroller.\nDieser steuert nicht nur die genannten Brückentreiber, sondern liest Motorencoder aus und kommuniziert über verschiedene Schnittstellen (vor allem CAN) mit dem Rest des Roboters.\nZusätzlich wird durch den Mikrocontroller auf zwei Wegen der Strom in den Motoren überwacht:\nEine grobe Strommessung über jeweils einen Shunt-Widerstand pro Motor und eine genauere, die von Hall-Sensoren in einem eigenen Bauteil durchgeführt wird.\nZu guter Letzt dürfen Ausgänge und LEDs zu Debug-Zwecken auch nicht fehlen.</p>\n\n<p>Auf dem Microcontroller befindet sich neben den Motor-Reglern auch der Code, der den restlichen Roboter steuert. Die Befehle werden über CAN an die Peripherie (zum Beispiel die Motortreiberplatinen “Micro-Motor” oder andere Alpha-Motor-Platinen) weitergeleitet, aber andersherum können auch Sensordaten oder die Kommunikation mit dem Display hierüber ablaufen.</p>\n\n<p>In Version zwei ist die Software deutlich eingeschränkt, da nun ein dedizierter Industrie-PC mit ros2 die Steuerung des Roboters übernimmt. Dafür wird die Hardware leistungsfähiger, durch den Einsatz eines neuen Mikrocontrollers und vor allem neuer Chips zur Strommessung. Tests der ersten Version hatten gezeigt, dass die Strombegrenzung erst ab 800 mA greift und die Strommessung starkes Rauschen aufweist (verursacht durch die mangelnde Gleichtaktunterdrückung der verwendeten Chips).</p>\n\n<h3 id=\"technische-daten-v2\">Technische Daten V2</h3>\n<ul>\n  <li>3 Phasen (DC und Brushless-DC Motoren)</li>\n  <li>ca. 20A pro Phase in der Spitze</li>\n  <li>20V Betriebsspannung (Akku) -&gt; 40V Auslegung</li>\n  <li>Mikrocontroller <del>STM32F407</del> STM32G474</li>\n  <li>2x CAN-Bus mit 4 Steckern, 1 UART, <del>1 SPI/I2C</del></li>\n  <li>Anschlüsse für <del>4</del> 2 AB-Encoder <del>inklusive UART 1-Wire</del></li>\n  <li>Anschlüsse für 2 Hall-Sensoren</li>\n  <li>Strommessung und Strombegrenzung</li>\n  <li>LEDs für Software-Status &amp; Encoderstatus</li>\n  <li><del>Konfigurierbare ID</del></li>\n  <li>Einfach lötbar und aufbaubar</li>\n  <li>Abmessungen: ca 50 x 80 mm²</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>PCB Design 4-Layer (mit KiCAD)\n    <ul>\n      <li>EMV-gerechtes Design</li>\n    </ul>\n  </li>\n  <li>STM32-Peripherie: Timer, ADC, DAC, Komparator</li>\n  <li>Recherche und Auslegung Leistungs-MOSFETs und MOSFET-Treiber</li>\n  <li>Software Low-Level Hardware-Ansteuerung</li>\n  <li>Software Hardwareabstraktion</li>\n  <li>Reflow-Löten</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Automotive Ethernet",
          "category" : "Projekt",
          "tags"     : " elektronik, software, pcb",
          "url"      : "/projekt/automotive-ethernet.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "In den letzten Jahren ist Automotive Ethernet (100Base-T1) verfügbar geworden. Möglicherweise ist ein Einsatz als leistungsfähiger Ersatz für CAN in Robotern möglich.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Aus der von Broadcom vor mehreren Jahren entwickelten <em>BroadR-Reach</em>-Technologie ist inzwischen der Standard <em>100Base-T1</em> (IEEE 802.3bw [1]) geworden.\nÜber ein ungeschirmtes einfaches Twisted-Pair-Kabel können 100 MBit/s im Voll-duplex-Modus übertragen werden. Es werden keine großen induktiven Übertrager wie bei herkömmlichen 1000Base-T Ethernet benötigt, sodass Baugröße und Komplexität in Vergleich zum CAN-Bus nicht ändern.</p>\n\n<p>Eine höhere Datenübertragungsrate zwischen Hauptsteuerung und Motorreglern und Sensoren wird in Robotern für bessere Regelungen und bequemeres Analysieren und Debuggen benötigt.\nMöglicherweise ist <em>100Base-T1</em> Ethernet hier die Lösung.</p>\n\n<p>Inzwischen (2019) sind PHYs [2] von mehreren Herstellern kommerziell verfügbar, ebenso wie einzelne Switching-ICs.</p>\n\n<p>Nach einer eingehenden Studie der Literatur, Erstellung und Bewertung eines Kommunikationssystems basierend auf <em>100Base-T1</em> könnte ein Prototypenaufbau erfolgen, sowie später eine Integration in die bestehenden und neuen Elektronik-Komponenten.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>Ethernet mit 100Mbit/s (Vollduplex)</li>\n  <li>Netzwerk-Struktur: Stern, Point-to-Point oder Bus</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Marktrecherche</li>\n  <li>Konzeptionierung des Kommunikationssystems</li>\n  <li>Netzwerkdesign und Auslegung</li>\n  <li>Prototypenaufbau</li>\n  <li>Softwareintegration</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Bachelor/Master Thesis: Lokalisierung mit Ultraschall und IMU",
          "category" : "Projekt",
          "tags"     : " software, elektronik",
          "url"      : "/projekt/locatisation-ultrasonic-and-imu.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Kooperative Lokalisierung mit Ultraschall und Inertial Measurement Unit (IMU) für kompetitive mobile Robotik.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Im der kommenden Saison setzt der RCA ein neues System zu Lokalisierung und der Roboter auf dem Spielfeld ein. Das Lokalisierungssystem basiert zur Zeit auf Ultraschallsignalen die von festen Ankerknoten (Baken) ausgestrahlt werden.\nDie Zeitsynchronisierung erfolgt mit Hilfe von Funksignalen.\nZusätlich können die mobilen Knoten des Systems drahtlos ihre jeweiligen Messdaten austauschen,\nso dass eine kooperative Lokalisierung ermöglicht wird. Dies ermöglicht eine Verbesserung der Zuverlässigkeit.\nDas grundlegen technische Konzept wurde in den letzten Jahren bereits entwicket und erfolgreich getestet.</p>\n\n<p>In dieser Masterarbeit sollen die mobilen Knoten des System um jeweils eine inertial measurement unit (IMU) erweitert werden.\nDabei geht es vor allem um die Implementierung und Leistungsanalyse von Sensorfusionsalgorithmen.</p>\n\n<h3 id=\"ziel\">Ziel</h3>\n\n<p>Theoretische Analyse und dazugehöriger experimenteller Aufbau eines kooperativen Lokalisierungssystems am Spielfeldrand und auf den mobilen Robotereinheiten.</p>\n\n<h3 id=\"requirements\">Requirements</h3>\n\n<ul>\n  <li>Verständnis von Signalverarbeitung</li>\n  <li>Erfahrung mit C++ Programmierung</li>\n  <li>Erfahrung mit Mikrocontrollerprogrammierung (Embedded Software Entwicklung)</li>\n  <li>Python or Matlab</li>\n</ul>\n\n<p><strong>Beneficial</strong></p>\n\n<ul>\n  <li>Soldering skills</li>\n  <li>PCB design</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Battery Management System",
          "category" : "Projekt",
          "tags"     : " elektronik, pcb",
          "url"      : "/projekt/batterie-management-system.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Neuentwurf des BMS (Battery Management System), das im Roboter die zentrale Komponente für Stromversorgung und Verteilung darstellt",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Der Roboter wird von zwei möglich Stromquellen – einem externen Netzteil oder dem austauschbaren LiFe-Akku mit 6 Zellen – versorgt.\nDie ausgewählte Spannung wird entweder direkt weitergeleitet, oder zunächst umgewandelt.\nMaßgeblich ist die erzeugte 12V Spannung. Diese ist sowohl die Versorgungsspannungen für einen zu versorgenden Industrie PC,\nals auch die Zwischenspannung aus der 5-7V Logikspannung und die benötigten On-Board Spannungen generiert werden.</p>\n\n<p>Als Features werden Kurzschlussschutz und eine Spannungsüberwachung an allen Ausgängen implementiert.\nAuch die Batterie wird natürlich beobachtet.\nHier soll eine State of Charge Abschätzung mittels <em>Coulomb Counting</em> durchgeführt werden und Unterspannungen erkannt werden.\nWichtige Informationen aus dem Betrieb sollen auf dem CAN Bus ausgegeben werden.</p>\n\n<h2 id=\"geplante-kenndaten\">Geplante Kenndaten</h2>\n<ul>\n  <li>20V Motorspannung bis zu 20A</li>\n  <li>12V Gerätepannung bis zu 10A</li>\n  <li>7V Logikspannung bis zu  5A</li>\n  <li>On-Board Spannung, herausgeführt</li>\n  <li>Kurzschlussschutz</li>\n  <li>Über/Unterspannungsschutz</li>\n  <li>Akku Überwachung</li>\n  <li>CAN-Interface</li>\n  <li>Not-Aus Schalter nicht im Strompfad</li>\n</ul>\n\n<h2 id=\"mögliche-verbesserungen\">Mögliche Verbesserungen</h2>\n<ul>\n  <li>Rekuperation aus dem Motorstrompfad</li>\n  <li>Visueller Batteriestandindikator</li>\n  <li>Stromversorgung für USB</li>\n  <li>Fortgeschrittene SoC und SoH Abschätzung</li>\n</ul>\n\n<h2 id=\"herausforderungen\">Herausforderungen</h2>\n<p>Das BMS soll dafür sorgen, dass alle gewünschten Geräte ohne weitere Maßnahmen angeschlossen und gleichzeitig betrieben werden können.\nIm worst case Szenario sollen daher 700W Dauerleistung bereitgestellt werden. Dies möglichst kostengünstig, auf geringem Raum und mit guter\nWärmeabfuhr zu realisieren erfordert eine treffende Vorhersage der realen Lastprofile.</p>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Biegebank",
          "category" : "Projekt",
          "tags"     : " mechanik, werkzeug",
          "url"      : "/projekt/biegebank.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Konstruktion und Fertigung einer Biegebank.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Der Roboterclub befindet sich im Besitz einer gut ausgerüsteten Werkstatt, um mechanische Teile für die Roboter zu fertigen. Dazu gehören z.B. eine CNC-Fräse und ein 3D-Drucker.</p>\n\n<p>Jedoch müssen gebogene bzw. gekantete Bleche, die eine hervorragende Stabilität, Freiformbarkeit und ein geringes Gewicht besitzen, mit Schraubstock, Hammer, Holz und anderen improvisierten Werkzeugen gefertigt werden. Dabei sind die Biegewinkel und die Kantenlängen stark begrenzt.</p>\n\n<p>Um die Fertigung gebogener Teile zu ermöglichen, soll eine Biegebank konstruiert und aufgebaut werden.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>Maximale Breite der Teile: 350mm</li>\n  <li>Mobil, z.B. durch eine einfache Klemmung am Tisch oder im Schraubstock</li>\n  <li>Ggf. verstellbare Blechdicke und Biegeradius</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>CAD-Konstruktion mit SolidWorks</li>\n  <li>Ggf. Rapid Prototyping mit 3D Drucker</li>\n  <li>Fertigung von Aluminium mit CNC-Fräse</li>\n  <li>Ggf. werkstofftechnische Auslegung.</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: CAN to X",
          "category" : "Projekt",
          "tags"     : " elektronik, pcb",
          "url"      : "/projekt/can-to-X.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Eine universale Platine, mit der verschiedenste Sensoren an den CAN-Bus angebunden werden können.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Viele Sensoren, die wir in den verschiedenen Robotern benötigen können ohne größeren Aufwand nicht direkt an den Roboter-CAN-Bus angeschlossen werden. Die CAN-to-X-Platine soll eine Anbindung vereinfachen. Das Herz der Platine wird ein STM32F303-Microcontroller, gepaart mit einem CAN-Transceiver. Zahlreiche Steckverbinder ermöglichen den Anschluss von Sensoren und anderer Peripherie.</p>\n\n<p>Hauptsächlich muss bei diesem Projekt flexible Software für den Microcontroller geschrieben werden, um z.B. I2C- oder aber SPI-Sensoren einfach anzubinden. Auch soll die Funkkommunikation mittels NRF24L01-Chipsatz mit dieser Platine möglich sein.</p>\n\n<h3 id=\"technische-daten\">Technische Daten:</h3>\n<ul>\n  <li>SPI</li>\n  <li>I2C</li>\n  <li>UART</li>\n  <li>CAN (Roboterclub-CAN)</li>\n  <li>Endschalter</li>\n  <li>LEDs</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Schaltplan-Entwurf</li>\n  <li>Platinendesign in KiCAD, Eagle oder Altium</li>\n  <li>SMD-Löttechnik</li>\n  <li>Software in C++, basierend auf modm.io</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: CI für unsere eingebettete Software",
          "category" : "Projekt",
          "tags"     : " software, webentwicklung, werkzeug",
          "url"      : "/projekt/continous-integration.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Konzipieren und Programmieren eines CI-Service in GitLab für unsere Softwareprojekte und Anzeige auf einem Dashboard.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Der Roboterclub hat viele eingebettete Softwareprojekte, deren Qualitäts-Zustand wir gerne im Blick behalten möchten.\nDazu brauchen wir einen sinnvollen und einfach zu benutzenden Continous Integration Service, der unsere Projekte in GitLab\nmindestens kompiliert und optional Unittests auswertet.\nEs sollen Docker Images gebaut werden um in GitLab Pipelines [1] verwendet zu werden.</p>\n\n<p>Dies ist besonders wertvoll, wenn der gesamte Setup mobil sein kann, sodass wir eine kleine Version dieses CIs zu Wettkämpfen \nmitnehmen können, bei denen es evtl. kein (oder sehr langsames) Internet gibt (*<em>hust</em>* in Frankreich *<em>hust</em>*).</p>\n\n<p>Es wäre schön, zusätzlich ein kleines Dashboard zu haben, was auf einen Blick anzeigt, wie der Zustand unserer Softwareprojekte ist.\nDieses Dashboard darf auch sehr gerne physikalisch sein (Ampel, LED Streifen oder so).</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n\n<ul>\n  <li>GitLab CI Pipelines</li>\n  <li>Dashboard Programmierung</li>\n  <li>Docker Images</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: CNC Fräse Aufarbeiten",
          "category" : "Projekt",
          "tags"     : " werkzeug, mechanik",
          "url"      : "/projekt/fraese-aufarbeiten.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Die CNC-Fräse wird samt Umhausung und Kühlschmiermittelkreislauf überholt.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Der Roboterclub ist im Besitz einer CNC-Fräse vom Typ Haase Cut 2500M [1] aus dem Jahr 2008.\nHiermit fräsen wir den Großteil der Bauteile für unsere Roboter aus Aluminium, Kunststoffen oder selten auch Holz.</p>\n\n<p>Die Umhausung der Fräse weist einige Probleme auf, welche behoben werden sollen, um in Zukunft bequemes und sicheres Fräsen mit hochqualitativen Ergebnissen zu ermöglichen.</p>\n\n<p>Desweiteren gibt es viele kleine Aufgaben:</p>\n<ul>\n  <li>Die Elektrik der Fräse soll in einen bereitliegenden Schaltschrank eingebaut werden</li>\n  <li>Für die Fräse liegt eine Werkzeuglängensensor bereit, welcher eingebaut und in der Software passend konfiguriert werden muss.</li>\n  <li>Der Filter im Kühlschmiermittelkreislauf ist schwer zugänglich, daher schwer zu leeren und zu klein. Daher soll der Kühlschmiermittelkreislauf konzeptionell überarbeitet werden und neu aufgebaut werden, wobei der Kühlschmiermittel-Durchfluss erhöht wird.</li>\n  <li>Ein Spritzschutz um den Fräser herum soll konstruiert und gebaut werden.</li>\n  <li>Das Gehäuse soll von innen vollständig mit 2K-EP-Harz abgedichtet werden.</li>\n  <li>Der Endschalter der X-Achse ist defekt und muss ersetzt werden.</li>\n  <li>Verbesserung der Aufspannvorrichtung für Platten.</li>\n  <li>Beschaffung oder Konstruktion und Bau eines Schraubstocks für kleine Bauteile.</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Holz- und Metallbearbeitung</li>\n  <li>LinuxCNC</li>\n  <li>Einweisung zur Bedienung der Fräse</li>\n  <li>Schaltschrank aufbauen</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Debugserver – Hardware",
          "category" : "Projekt",
          "tags"     : " elektronik, pcb",
          "url"      : "/projekt/debugserver-hardware.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Der Debugserver ist ein integrierter Raspberry Pi, um darüber kabellos die Roboter zu programmieren, zu debuggen, fernzusteuern und die Log-Ausgaben zu betrachten.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Ein den speziellen Anforderungen (s.u.) gerechtes Erweiterungsboard für einen RaspberryPi (“Pi HAT”) oder mit einem RaspberryPi Compute Module (CM3) [1] soll entworfen, geplant und aufgebaut werden.</p>\n\n<p>Der primäre Einsatzzweck ist der Debugserver, allerdings ist es auch denkbar, dass die Hardware für die Hauptsteuerung des Roboters genutzt wird.\nIn beiden Fällen ist absolute Zuverlässigkeit unerlässlich.</p>\n\n<p>Da die Anforderungen an mögliche Interfaces sich schnell ändern kann, wenn z.B. in Zukunft ein Laserscanner oder eine Kamera genutzt werden soll, sind viele universelle Anschlüsse am Board wünschenswert.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant):</h3>\n<ul>\n  <li>Raspberry Pi\n    <ul>\n      <li>Compute Module (CM3), Model 3 B+, Zero oder Zero W [2]</li>\n    </ul>\n  </li>\n  <li>WLAN 2.4GHz und 5GHz\n    <ul>\n      <li>Zwischen Client- und AccessPoint-Modus umschaltbar</li>\n    </ul>\n  </li>\n  <li>STM32-Microcontroller über SWD programmieren (z.B. per openOCD)</li>\n  <li>CAN-Interface (2x) mit MCP2515 (Linux Treiber)</li>\n  <li>UART-Interface (min. 1x; RX only) zum Empfangen der Logs vom Mikrocontroller</li>\n  <li>Echtzeituhr (RTC) für Linux-Systemzeit</li>\n  <li>Batterie-Backup\n    <ul>\n      <li>Verzögertes, kontrolliertes Herunterfahren</li>\n      <li>LiFe-Akku</li>\n      <li>Automatisches Akku-Laden über Roboter-Spannungsversorgung</li>\n    </ul>\n  </li>\n  <li>Minimales, intuitives Userinterface (LEDs, Schalter/Taster)</li>\n  <li>Kleine Baugröße</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>PCB Design (mit KiCAD)\n    <ul>\n      <li>EMV-gerechtes Design</li>\n    </ul>\n  </li>\n  <li>Recherche und Auslegung LiFe-Charger</li>\n  <li>Raspberry Pi und BCM2837</li>\n  <li>Reflow-Löten</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Debugserver – Softwarestack",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/debugserver-softwarestack.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Aufsetzten des Betriebssystems für den Raspberry Pi.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Der Debugserver (siehe Projekt “Debugserver Hardware”) basiert auf einem Raspberry Pi.\nAuf dem Raspberry Pi läuft ein Debian-basiertes Linux-System, dieses soll mittels <code class=\"highlighter-rouge\">debootstrap</code> [1],\nähnlich des Image-Builders [2] aufgesetzt werden um Reproduzierbarkeit zu gewährleisten.</p>\n\n<p>Zusätzlich werden diverse Dienste auf dem Debugserver benötigt,\neine CAN-to-Network Brücke oder die Überwachung des Roboterzustandes anhand welcher der Debugserver ggf. heruntergefahren wird.\nJe nach Einsatz der zentralen Hardwareplattform wird ggf.  OpenOCD zum Programmieren des Mikrocontrollers benötigt.\nDiese Dienste müssen konfiguriert, beim Hochfahren automatisch gestartet und teilweise zuvor noch implementiert werden.\nEbenso muss die Netzwerkkonfiguaration mit der Möglichkeit zum Umschalten zwischen Client- und Accesspoint- Betrieb zuverlässig eingerichtet werden.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant):</h3>\n<ul>\n  <li>Debian Stretch (10) oder Fedora\n    <ul>\n      <li>ARMv7 (<em>armhf</em>) oder ARMv8 (<em>aarch64</em>)</li>\n    </ul>\n  </li>\n  <li>Reproduzierbarkeit der Betriebssystem-Images durch Nutzung von Debootstrap und Skripten zur Installation und Konfiguration der Software</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Linux: Debian (oder Fedora?)</li>\n  <li>Systemd</li>\n  <li>Debootstrap</li>\n  <li>Systemadministration</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Debugserver – Webmonitor",
          "category" : "Projekt",
          "tags"     : " software, webentwicklung",
          "url"      : "/projekt/debugserver-webmonitor.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Entwicklung einer Web-Oberfläche zur aufbereiteten Anzeige des Debug-Logs des Roboters.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Zum einfachen Debugging unserer Roboter-Software können im Programmcode der Microcontroller Log-Nachrichten erzeugt\nwerden, die per UART (serieller Schnittstelle) ausgegeben werden. Damit diese auch bei Testspielen ohne nervige Kabel\nzum Roboter verfolgt werden können, befindet sich auf den Robotern ein RaspberryPi Pi (der „Debugserver“), der unter\nanderem mit dem UART der Hauptplatine verbunden ist. Über eine Web-Anwendung soll der Log per WLAN anderen Computern mit\nWebbrowser zugänglich gemacht werden, wobei die Nachrichten in Echtzeit angezeigt und dabei grafisch aufbereitet\nwerden sollen.</p>\n\n<h3 id=\"geplante-features\">Geplante Features:</h3>\n<ul>\n  <li>Echtzeit-Anzeige der Log-Nachrichten (per Websocket oder AJAX-Polling)</li>\n  <li>Grafische Aufbereitung der Log-Nachrichten nach bestimmten Mustern (z.B. angegebene Softwarekomponente)</li>\n  <li>Modulare und dokumentierte Software zur einfachen Wartung und Erweiterung</li>\n  <li>Ggf. Filtern des Logs nach bestimmten Mustern (z.B. Zeitpunkt, Softwarekomponente, RegEx)</li>\n  <li>Aufzeichnung des Logs in eine Datei und Abruf alter Logs aus bestehenden Dateien</li>\n  <li>Ggf. Framework zur inhaltlichen Interpretation und übersichtlichen Darstellung bestimmter Nachrichtenformate,\nz.B. Übergänge in Zustandsautomaten, Plots von aufgezeichneten Werten, …</li>\n  <li>Ggf. Überwachung des Verbindungsstatus Browser → Debugserver, Debugserver → Microcontroller</li>\n  <li>Ggf. Funktionen wie Neustart, Programmieren des Microcontroller</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Dynamische Web-Entwicklung mit einfachem Server in Python oder Ruby oder NodeJS</li>\n  <li>Entwicklung einer komplexen Singlepage-Anwendung in Javascript/ECMA-Script</li>\n  <li>Kommunikation per SocketIO-Library o.ä.</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Driver",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/driver.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Entwicklung einer Softwarekomponente zur geregelten Ausführung von Fahrmanövern.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Damit sich unsere Roboter kontrolliert auf dem Spielfeld bewegen können, sind Software-Routinen nötig, die verschiedene\nFahrmanöver ausführen und regeln können. Daher soll es eine Software-Komponente geben, die solche Routinen enthält und\nvon anderen Komponenten über eine definierte Schnittstelle mit Fahrmanövern beauftragt werden kann. Dabei kann es\nsich um die Rotation auf einen bestimmten Winkel, des Verfolgens einer Gerade oder eines Kreisbogens, die\ngeradlinige Anfahrt auf einen definierten Punkt, usw. handeln. Je nach Bewegungsart sind dazu unterschiedliche\ngeometrische Berechnungen, Regelungskonzepte und Sicherheitsfunktionen nötig.</p>\n\n<h3 id=\"geplante-features\">Geplante Features:</h3>\n<ul>\n  <li>Einheitliches Interface für verschiedene Fahrmanöver und Rückmeldung über Status und Fehler</li>\n  <li>Einfaches Interface zum Abfahren von Routen (Sequenzen von Fahrmanövern)</li>\n  <li>Einfache Fahrmanöver: Punkt anfahren, Gerade folgen, Kreisbogen folgen, Rotation</li>\n  <li>Komplexere Fahrmanöver: Nach Abstandssensor fahren, …</li>\n  <li>Modulare Software (DRY – Don’t Repeat Yourself), Dokumentation der Konzepte und Schnittstellen</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Entwurf eines Software-Interfaces (in Abstimmung mit Entwicklern anderer Komponenten)</li>\n  <li>Entwicklung von Geometrieberechnungen und Positionsreglern</li>\n  <li>Softwareentwicklung in C++ oder Python mit ROS2</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Eurobot Wettbewerb gewinnen",
          "category" : "Projekt",
          "tags"     : " eurobot",
          "url"      : "/projekt/win-the-eurobot.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Selbstverständlich ist das oberste Ziel natürlich den Eurobot sowohl in Deutschland, mindestens einem weiteren Land als Gast und auf dem internationalen Finale in Frankreich zu gewinnen.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Einfach™ alles™ richtig™ machen™.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>Platzierung: 1. Platz</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Gewinnen</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Eurobot Wettbewerbsspielfeld aufbauen",
          "category" : "Projekt",
          "tags"     : " eurobot, mechanik",
          "url"      : "/projekt/spielfeld.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Um unserem eigene Roboter zu testen benötigen wir das Eurobot Spielfeld.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Das Spielfeld muss gemäß der Eurobot-Regeln aufgebaut werden, die Spielelemente müssen beschafft und angepasst werden.\nÜberwiegend muss sich dabei mir der Holzbearbeitung und Lackierung beschaftigt werden.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Holzbearbeitung</li>\n  <li>Konstruktion</li>\n  <li>Lackieren</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: FPGA Controller",
          "category" : "Projekt",
          "tags"     : " software, hardware, elektronik",
          "url"      : "/projekt/fpgas.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Eigene Implementierung von Logik-Peripherie im FPGA z.B. für Motor-Steuerung",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>FPGAs bieten die Möglichkeit Logik-Komponenten z.B. zur Ansteuerung von Motoren diskret und nach den eigenen Ansprüchen zu entwerfen und zu implementieren.</p>\n\n<p>Es gibt z.B. unter [1] bereits einige implementierte Komponenten, die zum Einstieg verwendet werden können.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>zunächst Möglichkeiten evaluieren\n    <ul>\n      <li>CAN Controller integrieren, der einen begrenzten Satz an Nachrichten verarbeiten kann\n        <ul>\n          <li>Motor-PWM setzen</li>\n          <li>Encoder zurückschicken</li>\n          <li>ggf. innersten Regler hier implementieren</li>\n          <li>Strommessung</li>\n        </ul>\n      </li>\n    </ul>\n  </li>\n  <li>Komplexere PWM-Generierung implementieren, testen\n    <ul>\n      <li>PWM Dithering (Erhöhung der PWM-Ausflösung)</li>\n      <li>Spread Spectrum PWM (geringe EMV-Störung)</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Implementierung von diskreter Logik in VHDL oder Verilog</li>\n  <li>Integration, Verifikation fertiger offener Implementierungen</li>\n  <li>Aufbauen von Test-Setups für Kommunikations-Interfaces, Tests mit Motor-Treiber</li>\n  <li>PCB-Design neuer Motor-Treiber</li>\n  <li>Beschaffen weiterer Eval-Boards</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Fahrplanung in ROS2",
          "category" : "Projekt",
          "tags"     : " eurobot",
          "url"      : "/projekt/Fahrplanung_in_ROS2.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Da wir in den kommenden Jahren ROS2 verwenden, muss eine neue Fahrplanung geschrieben werden. Diese Fahrplanung kann z.B. auf den ROS2 Navigation Stack aufgebaut werden. ",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Da wir in den kommenden Jahren ROS2 verwenden, muss eine neue Fahrplanung geschrieben werden.\nDiese Fahrplanung kann z.B. auf den ROS2 Navigation Stack aufgebaut werden.</p>\n\n<p>Der ROS2 Navigation Stack kann automatisch Maps z.B. aus RVIZ einbinden und darin eine Trajektorie für einen Roboter generieren.\nDie Routenplanung sollte eine aktuelle Karte mit statischen und dynamischen Hindernissen berücksichtigen.\nUm aktuelle Hinderniskarten nutzen zu können sollten der Map Server aus dem Navigation Stack verwendet werden.</p>\n\n<p>https://github.com/ros-planning/navigation2</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>C++ / Python Programmierung</li>\n  <li>Einarbeitung in den ROS2 Navigation Stack</li>\n  <li>Arbeiten mit dem Map Server des Navigation Stack</li>\n  <li>Kollisionsfreie Routenplanung</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Fahrplattform Little",
          "category" : "Projekt",
          "tags"     : " mechanik",
          "url"      : "/projekt/fahrplattform-little.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Konstruktion und Fertigung der Fahrplattform des kleinen Roboters für die neue Saison (2019).",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Für unsere neuen Roboter für den Eurobot-Wettbewerb 2019 müssen Grundstruktur und Antrieb konstruiert und gefertigt\nwerden. Der kleine Roboter („Little“) soll mit einem Omnidrive-Antrieb [1] ausgerüstet werden. Durch diesen kann der\nRoboter sich in alle Richtungen bewegen. Die Grundkonstruktion wird aus einer gefrästen Aluminium-Bodenplatte bestehen,\nauf der die Lagerung der drei Omniwheels, die drei Antriebsmotoren, sowie der Aufbau des Roboters montiert werden.</p>\n\n<p>Im Gegensatz zu anderen Fahrplattformen sind keine Odometrieräder zur Positionsbestimmung vorgesehen. Stattdessen sollen\nUltraschall-Baken und ggf. eine IMU [2] zur Orientierung verwendet werden.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>Geschwindigkeit 2 m/s</li>\n  <li>Kraft 50 N</li>\n  <li>Leistung 100 Watt</li>\n  <li>Motoren: 3x Maxon EC-max 30, Getriebe: 1:4,8</li>\n  <li>soll über Kanten von 3 mm fahren können</li>\n  <li>Räder Ø 50 mm</li>\n  <li>Bodenplatte Dicke ca. 10 mm\n    <ul>\n      <li>Motoren darin teilweise versenkt</li>\n    </ul>\n  </li>\n  <li>Umfang (nach Regeln 2018)\n    <ul>\n      <li>Startumfang        850 mm</li>\n      <li>Dynamischer Umfang 1050 mm</li>\n    </ul>\n  </li>\n  <li>Omnidrive (3 Räder)</li>\n  <li>IMU (inertial measurement unit) / Beschleunigungs- und Lagesensor [2]</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>CAD-Konstruktion mit SolidWorks</li>\n  <li>3D-Druck zum Prototyping</li>\n  <li>Fertigung von Aluminium mit CNC-Fräse</li>\n  <li>Simulation der Fahrdynamik (z.B. mit Matlab Simulink)</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Fernsteuerungs-GUI",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/python-gui.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Entwicklung einer Python/Qt-GUI-Anwendung zur Fernsteuerung und Diagnose unserer Roboter.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Zum Testen der Software- und Hardware-Komponenten unserer Roboter soll eine GUI-Anwendung für den Computer entwickelt\nwerden, die über Netzwerk und CAN-Bus mit der Steuerung der Roboter kommuniziert und einzelne Funktionalitäten gezielt\naufrufen kann. Ebenso soll sie verschiedene Zustände und Signale des Roboters zur Überwachung anzeigen und grafisch\naufbereiten.</p>\n\n<p>Dazu muss zunächst eine Python-Anbindung an unser Roboter-internes Kommunikations-Protokoll XPCC implementiert und die\nstrukturierte Beschreibung der Nachrichtenformate auf ein Python-Typensystem abgebildet werden. Dann können\nGUI-Anwendungen geschrieben werden: einerseits solche, die unabhängig von konkreten Problemstellungen dynamisch aus\nder strukturierten Beschreibung der Software-Komponenten erzeugt werden. Diese dienen dazu, ohne weiteren Aufwand neue\nFunktionalitäten der Robotersoftware zu testen und können auch bei anderen XPCC-basierten Projekten eingesetzt werden.</p>\n\n<p>Andererseits soll es Anwendungen mit auf bestimmte Aufgaben spezialisierten Userinterfaces geben, z.B. zur Fernsteuerung\ndes Roboterantriebs und anderer Motoren, zur Anzeige von gemessenen Sensorwerten, zum Konfigurieren der Strategie und\nStarten von Spielen, zur grafischen Anzeige der gemessenen Positionen eigener und gegnerischer Roboter auf dem\nSpielfeld, usw.</p>\n\n<h3 id=\"technische-datenfeatures\">Technische Daten/Features:</h3>\n<ul>\n  <li>Software in (pure) Python 3.x ohne Codegenerierung oder eigene native Bibliotheken</li>\n  <li>Modulare Struktur und gute Dokumentation zur einfachen Entwicklung von Fernsteueranwendungen oder anderen\nSoftware-Komponenten</li>\n  <li>Kommunikation mit den Robotern über XPCC-Protokoll via ZeroMQ</li>\n  <li>Dynamische erzeugte generische Benutzeroberfläche zur Steuerung und Diagnose beliebiger Software-Komponenten mit\nbeliebigen Parameter-/Datentypen</li>\n  <li>Komfortable Editoren für bestimmte Nachrichtenformate, z.B. Positionen auf dem Spielfeld</li>\n  <li>Framework zum einfachen Anlegen Saison-/Aufgabenspezifischer Oberflächen</li>\n  <li>Grafische Oberfläche zur Fernsteuerung der Roboterantriebe und zusätzlicher Motoren</li>\n  <li>Grafische Oberfläche zum Start des Roboters und zur Überwachung des Spielverlaufs</li>\n  <li>Grafische Oberfläche zum Debuggen und Kalibrieren der Odometrie</li>\n  <li>Grafischer Busmonitor zum Anzeigen aller oder bestimmter Bus-Nachrichten, als Rohdaten und interpretierte Werte\n(Vorbild: Wireshark)</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Anwendungs-Entwicklung in Python 3.x</li>\n  <li>Entwicklung Grafischer Userinterfaces mit PyQt/Qt5</li>\n  <li>Auseinandersetzung mit den Software-Komponenten und der Kommunikation des Roboters</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Fiducial marker: RUNE",
          "category" : "Projekt",
          "tags"     : " pcb, software",
          "url"      : "/projekt/rune-tags.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Optische RUNE Tags sollen genutzt werden um unsere eigenen Roboter sowie gegnerische Roboter zu lokalisieren.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Die Position und Orientierung der Roboter auf dem Eurobot-Spielfeld soll mittels Bilderkennung und Fiducial Markern bestimmt werden.</p>\n\n<p>Aufgrund der Anforderungen des Eurobot-Wettbewerbs wurden die RUNE-Tags hierzu ausgewählt deren Detektion vergleichweise wenig Rechenaufwand bedeutet.\nDie RUNE-Tags bestehen aus 129 in drei konzentrischen Kreisen angeordneten Punkten.\nVerschiedene Tags können durch spezielle Muster, bei denen einzelne Punkte fehlen, codiert werden.</p>\n\n<p>Um eine bessere Störfestigkeit zu erreichen sollen die Punkte der RUNE-Tags mit LEDs realisiert werden.\nDurch Syncronisation mit dem Kamera-System mittels Gold-Code moduliertem Infrarot-Licht können die LEDs syncron zum Kamera-Shutter leuchten.\nDies führt zu weniger Blendung der Zuschauer und spart Energie.</p>\n\n<p>Die Auswertung des Kamera-Bilds soll mittels OpenCV geschehen und die erkannten Positionen als ROS2-Topic bereit gestellt werden.</p>\n\n<p>Bonus: Auf den 129 LEDs pro RUNE-Tag kann man auch noch weitere Informationen darstellen.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>Millimetergenaue Lokalisierung von eigenem und gegnerischem Roboter</li>\n  <li>Robuste Funktion auch bei schwierigen Lichverhältnissen</li>\n  <li>Syncronisation mit Kamera-System</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Schaltungs- &amp; PCB- Design</li>\n  <li>Software für Microcontroller mit modm.io</li>\n  <li>Bildererkennung (OpenCV)</li>\n  <li>ROS2</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Funk-Kommunikation XPCC-Backend",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/funk-komm-xpcc-backend.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Allgemeines und Standartisiertes XPCC-Backend über eine Funk-Schnittstelle.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Für die grundlegende Kommunikation innerhalb der RCA-Roboter wird ein CAN-Bus verwendet.\nUm weitere Komponenten –\nwie etwa einen zweiten Roboter oder Positionierungsbaken des Gegners –\neinzubinden, muss eine Funk-Schnittstelle verwendet werden.\nEine bestehende Lösung ist bislang beschränkt auf zwei Roboter als Kommunikations-Teilnehmer, die darüber nur grundlegende Informationen für ihre Spielstrategie austauschen.</p>\n\n<p>In diesem Projekt soll das XPCC-Protokoll, das zur CAN-Kommunikation verwendet wird,\num ein allgemeines Backend für eine Funk-Schnittstelle erweitert werden.\nDamit sollen beliebige externe Komponenten (zweiter Roboter, Gegnerbaken, externe Bildverarbeitung, etc.) eingebunden werden und ohne Mehraufwand komplexe Anwendungsdaten übertragen können.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Implementation der Funk-Kommunikation\n    <ul>\n      <li>Phy-Layer: NRF24L01</li>\n      <li>Data-Link-Layer: MAC-Layer mit R2MAC (teil von XPCC)</li>\n    </ul>\n  </li>\n  <li>Softwareentwicklung in C++ mit modm.io und XPCC für Microcontroller</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Funkkommunikation",
          "category" : "Projekt",
          "tags"     : " elektronik, pcb",
          "url"      : "/projekt/funkkommunikation.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Da in der kommenden Saison das erste mal ein X86 Rechner die Steuerungsplattform werden soll muss eine alternative Funkkommunikation auf ggf. WLAN standards entwickelt werden.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Es soll eine Funkkommunikation für unsere neuen X86-Plattformen entwickelt werden. Hierbei kommt erschwerend dazu, dass der identische noch zu wählende Standard auch auf unseren kleineren STM32 basierten Boards\nzum Einsatz kommen soll. Hier sollen passende ICs gefunden werden, Kompatibilität mit kaufbaren USB-Adaptern untersucht werden und am Ende eine funktionierende Lösung stehen.</p>\n\n<h3 id=\"technische-daten\">Technische Daten:</h3>\n<ul>\n  <li>müssen noch definiert werden</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Systementwicklung</li>\n  <li>Funkkommunikation</li>\n  <li>Schaltplan-Entwurf</li>\n  <li>Platinendesign in KiCAD</li>\n  <li>SMD-Löttechnik</li>\n  <li>Software in C++, basierend auf modm.io</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Intelligente Motor-Kommutierung",
          "category" : "Projekt",
          "tags"     : " elektronik, software",
          "url"      : "/projekt/motor-commutation.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Entwicklung einer intelligenten Kommutierungsmethode für Bürstenlose Gleichstrommotoren.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Bei den zumeist verwendeten Motoren handelt es sich um Bürstenlose Gleichstrommotoren (BLDC), welche von einem externen Steuergerät angesteuert werden müssen.</p>\n\n<p>Dieses Steuergerät enthält neben der Leistungselektronik auch noch Logik welche das vom Motor benötigte rotierende Magnetfeld erzeugt.</p>\n\n<p>Die einfachste und derzeit im RCA genutzte sogenannte Kommutierungsmethode ist die Block-Kommutierung.\nEs gibt Alternativen zur Block-Kommutierung, die u.a. Vorteile in den Punkten Kraft und Laufruhe bringen. Der Blog-Post [1] liefert hier ein erste Übersicht.</p>\n\n<p>Ziel diese Projektes ist die Evaluierung der Möglichkeiten sowie die Erstellung einer an die Bedürfnisse des RCA angepasste Simulation und idealerweise anschließende reale Implementation einer intelligenten Kommutierungslogik.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Software mit Echtzeit-Anforderung (Microcontroller)</li>\n  <li>STM32-Peripherie: Timer</li>\n  <li>Recherche und Dokumentation</li>\n  <li>Simulation mit geeigneter Toolchain</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Laserscanner-Positionierung",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/laserscanner-positioning.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Entwicklung einer Software-Komponente zur Bestimmung der Roboterposition mit einem SICK-Laserscanner.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Wir besitzen einen SICK TIM 551 Laserscanner, der mittels eines Infrarotlasers radial Distanzen misst. In der richtigen\nHöhe in einen unserer Roboter eingebaut, wäre es damit prinzipiell möglich, die Roboterposition anhand der\nbeobachteten Entfernungen zum Spielfeldrand zu berechnen. Probleme machen dabei jedoch die Ausreißer durch im Lichtweg\nbefindliche Spielelemente, das Messrauschen, die zeitliche Latenz der Verarbeitung und die Verzerrung der Messungen bei\nBewegung des Roboters.</p>\n\n<p>Daher soll eine Software-Komponente entwickelt und in die Robotersoftware integriert werden, die die per Ethernet/UDP\nausgegebenen Daten des Laserscanners verarbeitet, daraus seine Position und Ausrichtung auf dem Spielfeld schätzt und\ndiese an die Robotersoftware übermittelt. Dort soll eine weitere Komponente die Positionsdaten entgegennehmen und unter\nbestimmten Voraussetzungen und Ausgleich der Zeitverzögerung die bekannte Roboterposition und -ausrichtung damit\nkorrigieren.</p>\n\n<p>Da für den Laserscanner bereits ein Treiber im Software-Framework ROS existiert, bietet es sich an, die Software zur\nPositionsberechnung ebenfalls in ROS zu entwickeln und die Daten anschließend über das XPCC-Protokoll an den\nMicrocontroller des Roboters zu senden.</p>\n\n<h3 id=\"geplante-features\">Geplante Features:</h3>\n<ul>\n  <li>Filterung der Messwerte (Tiefpass?)</li>\n  <li>Ausreißer-Elimination (z.B. RANSAC-Verfahren)</li>\n  <li>Überwachung der Roboterbewegung; Korrektur nur bei stehendem Roboter oder Entzerrung der Messung</li>\n  <li>Plausibilitätsprüfung der Positionen/Ausrichtungen vor Korrektur</li>\n  <li>Visualisierung der berechneten Daten zur Validierung des Verfahrens</li>\n  <li>Entwicklung als ROS-Node; zusätzliche Nodes zur Kommunikation mit dem Roboter</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Herleitung von Geometrische Berechnungen und Algorithmen</li>\n  <li>Entwicklung von Algorithmen zur Signalverarbeitung (Filterung, Ausreißeranalyse)</li>\n  <li>Software-Entwicklung für ROS in Python und/oder C++</li>\n  <li>Software für Microcontroller in C++ mit modm.io</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Liteplacer Pick and Place",
          "category" : "Projekt",
          "tags"     : " elektronik, pcb",
          "url"      : "/projekt/liteplacer.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Der Roboterclub hat als Dauerleihgabe einen Liteplacer Bestückungsautomaten zur Verfügung gestellt bekommen. Diesen für uns lauffähig zu bekommen ist hier die Hauptaufgabe.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n<p>Es soll ein uns zur Verfügung gestellter Liteplacer für die Bestückung von diversen Platinen eingesetzt werden. Hier gilt es herauszufinden, ob die Maschine im Istzustand einsetzbar ist oder\ndafür noch modifiziert werden muss. Die Maschine muss noch bei unserem Sponsor abgeholt werden und bei uns wieder aufgebaut werden. Die vorhandene Hardware (Mechanik und Elektronik) muss gesichtet werden und \ndie Software OpenPNP inkl. installiert und konfiguriert werden. Je nachdem wie zuverlässig die Maschine dann arbeiten wird, kann die Aufgabe z.B. um das Anfertigen von Automatikfeedern erweitert werden.</p>\n\n<h3 id=\"technische-daten\">Technische Daten:</h3>\n<ul>\n  <li>Liteplacer-Mechanik</li>\n  <li>3D-Druck Feeder für größere Mengen (Reels)</li>\n  <li>Full Vision-System für bessere Bauteilplatzierungen</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>3D Druck</li>\n  <li>OpenPNP Software</li>\n  <li>SMT Produktion</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Micro-Motor",
          "category" : "Projekt",
          "tags"     : " elektronik, pcb",
          "url"      : "/projekt/micro-motor.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Micro-Motor ist eine Platine zum Anschluss an CAN-Bus welche einen Motor ansteuern kann.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>In den Aktoren verbaute Motoren müssen angesteuert werden, dazu verfolgt der Micro-Motor das Konzept von verteilten Ansteuerungen.</p>\n\n<p>An jedem Motor wird unmittelbar eine kompakte Micro-Motor Platine montiert, welche gleichzeitig auch einen Magnet-Encoder [1] optional beinhaltet.\nDiese Platine wird über einen einzigen Stecker mit Strom und CAN-Bus versorgt und kann eigenständig den Motor ansteuern.\nZusätzlich kann ein Endschalter ausgelesen werden und die Temperatur des Motors überwacht werden.</p>\n\n<p>Auf dem Microcontroller sollen frei konfigurierbare PID-Regler und ggf. auch “Motor-mit-Endschalter”-Komponenten, welche den Aktor parametrierbar initialisieren und verfahren können, das Interface nach außen bilden.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>3 Phasen (DC und BLDC Motoren)</li>\n  <li>ca. 10A pro Phase</li>\n  <li>20V Betriebsspannung (Akku) -&gt; 40V oder 60V Auslegung</li>\n  <li>Anschluss für AB-Encoder</li>\n  <li>optional Magnet-Encoder [1] auf dem PCB</li>\n  <li>Anschluss für Hall-Sensor</li>\n  <li>Temperatursensor (kontaktlos auf dem PCB verlötet oder I²C)</li>\n  <li>Strommessung</li>\n  <li>LEDs für Software-Status &amp; Encoderstatus</li>\n  <li>Konfigurierbare ID (ggf. STM32-Hardware-ID)</li>\n  <li>Einfach lötbar und aufbaubar</li>\n  <li>Abmessungen: Rund, Grund-Ø 20mm (Namiki-Motoren: Ø 22mm)</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>PCB Design 4-Layer (mit KiCAD)\n    <ul>\n      <li>EMV-gerechtes Design</li>\n    </ul>\n  </li>\n  <li>STM32-Peripherie: Timer, ADC, DAC, Komparator</li>\n  <li>Recherche und Auslegung Leistungs-MOSFETs und MOSFET-Treiber</li>\n  <li>Software Low-Level Hardware-Ansteuerung</li>\n  <li>Software Hardwareabstraktion</li>\n  <li>Reflow-Löten</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Odometrie",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/odometrie.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Implementierung von odometrischer Positionsbestimmung und einer Kalibrierungs-Routine",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Die Roboter des Roboterclubs benutzen bislang Odometrie zur eigenen Lokalisierung auf dem Spielfeld. Dabei wird\nkontinuierlich aus der Drehbewegung zweier Räder die Robotergeschwindigkeit berechnet und damit die Position\nnachgeführt.</p>\n\n<p>In Rahmen dieses Projektes soll zunächst der Code für die Positionsbestimmung per Odometrie neu entworfen und\nprogrammiert werden und anschließend eine Routine zur einfachen Kalibrierung der Odometrie-Parameter entwickelt werden.\nDie neue Software-Struktur soll die Integration weiterer Positionierungsmethoden vorsehen, etwa die Ultraschall-basierte\nabsolute Positionierung (vgl. Projekt Ultraschall Lokalisierung) oder eine Inertiale Messeinheit (IMU).</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Einarbeitung in die Roboterkinematik</li>\n  <li>Entwurf von Algorithmen zur Positionierung und Kalibrierung</li>\n  <li>Programmierung für eingebettete Systeme in C++ mit XPCC/modm Framework</li>\n  <li>Programmierung einer grafischen Anwendung in Python3/PyQt5</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Odometrie mit optischer Sensorik",
          "category" : "Projekt",
          "tags"     : " elektronik, software, mechanik",
          "url"      : "/projekt/odometrie-maussensoren.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Entwicklung eines optische Odometriesystems [1] für Roboterantriebe.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Für den sich in Entwicklung befindenden Antrieb des kleinen Roboters – basierend auf einem Omnidrive-Antrieb (siehe separate Projektbeschreibung) – kann keine konventionelle Odometrie mit zwei zusätzlichen nicht angetriebenen Rädern zur Positionsbestimmung genutzt werden.</p>\n\n<p>Ein vielversprechendes Konzept ist die Nutzung von Sensoren aus optischen Mäusen.</p>\n\n<p>Es gab im RCA bereits Versuche mit dem – inzwischen abgekündigten und nur noch schwer erhältlichen – Sensor ADNS9800 [2] von Avago.</p>\n\n<p>Idealerweise werden im Rahmen diese Projekts ein oder mehrere geeigneter Nachfolger ausfindig gemacht, die nötige Hardware aufgebaut, Software geschrieben und die Zuverlässig unter den Bedingungen des Eurobot-Wettbewerbs erprobt.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>Latenz &lt;5ms</li>\n  <li>Auflösung X und Y: &lt;1mm</li>\n  <li>Auflösung Rotation: &lt;1° (ggf. mit mehreren Sensoren)</li>\n  <li>Kleine Bauform</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Recherche verfügbare Sensoren</li>\n  <li>Software</li>\n  <li>Testbench aufbauen</li>\n  <li>ggf. PCB Design</li>\n  <li>Datenanalyse und Aufbereitung</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Roboter-Caddy",
          "category" : "Projekt",
          "tags"     : " mechanik, elektronik, software",
          "url"      : "/projekt/roboter-caddy.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Um die Roboter mit Zubehör, Baken, etc. bei den Wettbewerben zum Spielfeld zu transportieren wollen wir einen coolen Roboter-Caddy bauen.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Bei Wettbewerben sind teils längere Distanzen zwischen Team-Bereich und Spielfeld mit dem Roboter und nötigem Zubehör zu überwinden. Ein Transportfahrzeug wäre als hilfreich.\nLangweilige Implementierungen dieser Idee kann man bei anderen Teams beobachten, wo die Roboter in Bollerwägen, Kisten oder Kinderwagen transportiert werden.</p>\n\n<p>Wir wollen das natürlich weniger langweilig haben, also mit einem Antrieb und Steuerung, welche den Roboter-Caddy im besten Fall autonom einer Person folgen lässt oder Fernsteuerung ermöglicht.</p>\n\n<h3 id=\"anforderungen\">Anforderungen</h3>\n<ul>\n  <li>Kompakte Bauform, leicht zu Wettbewerben zu transportieren\n    <ul>\n      <li>in Roboterkiste integriert</li>\n      <li>zusammenklappbar</li>\n      <li>o.ä.</li>\n    </ul>\n  </li>\n  <li>Robustes Fahrwerk für unebene Böden auf Wettbewerben</li>\n  <li>Leistungsstarker Antrieb</li>\n  <li>ggf. Fernsteuerung</li>\n  <li>ggf. Autonome Navigation</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Mechanik</li>\n  <li>Elektronik</li>\n  <li>Software</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Robotersoftware Besseres Dokumentationsformat",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/Dokumentation%20Roboter%20Software%20ROS2",
          "date"     : "October 28, 2019",
          "excerpt"  : "Dokutool für neue Robotersoftware basierend auf ROS2",
          "content"  : "## Zusammenfassung\n\nROS2 ist relativ gut dokumentiert.\nDie Robotersoftware und die darunter liegenden Konzepte müssen jedoch weiterhin dokumentiert werden.\nDazu gilt es ein Konzept zu entwickeln, mit allen relevanten Stakeholdern zu testen und danach Vereinsweit zu deployen. \n\n## Tätigkeitsfelder und Technologien\n* ROS2 \n* Python und C++\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Routing-Algorithmus",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/routing.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Entwicklung und Implementierung eines Routenfindungs-Algorithmus für die Roboter.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n<p>Zur Navigation unserer Roboter auf dem Spielfeld soll ein Routing-Algorithmus entwickelt werden, mit dem jeder Roboter\nautonom die optimale Route zu einem Zielpunkt auf dem Spielfeld berechnen kann. Dabei sollen Hindernisse auf dem\nSpielfeld und nach Möglichkeit die aktuellen Positionen der anderen Roboter auf dem Feld mit Bezug auf die bekannten\nAußenmaße des Roboters berücksichtigt werden. Weiterhin sollte der Algorithmus die Einschränkungen des Antriebssystems\n(Bewegungs-Freiheitsgrade, max. Beschleunigung, etc.) berücksichtigen.\nDer Algorithmus soll dann in das neu entstehende ROS System eingeglieder werden.</p>\n\n<h3 id=\"featuresideen\">Features/Ideen:</h3>\n<ul>\n  <li>A*-Algorithmus auf einem kartesischen Raster auf dem Spielfeld mit ca. 30mm Auflösung, je 8 Ausrichtungen,\n8 Bewegungsrichtungen pro Feld</li>\n  <li>Dynamischer Import von Informationen zu Hindernissen über das ROS System / aus Kameradaten</li>\n  <li>Einbezug der vorhanden Informationen zu Spielfeld und Roboterform</li>\n  <li>Automatische Optimierung (Postprocessing) der Route durch Kurven und Geraden in beliebigen Winkeln</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Entwicklung von Routing- und Geometrieverarbeitungs-Algorithmen</li>\n  <li>Ggf. Implementierung und Validierung von Algorithmus-Prototypen in Python o.ä.</li>\n  <li>Softwareentwicklung in C++</li>\n  <li>Einarbeitung in ROS</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: SCARA",
          "category" : "Projekt",
          "tags"     : " mechanik, elektronik, software",
          "url"      : "/projekt/scara.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Der SCARA ist ein Roboterarm, der sich besonders für planare Pick-And-Place-Handhabungen eignet",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Der SCARA ist während der Saison 2018 enstanden und sollte zum Aufsammeln und Stapeln von Bauklötzen eingesetzt werden. Für die Handhabung ist momentan ein Saugnapf montiert.</p>\n\n<p>Angetrieben wird der Arm über insgesamt vier Motoren. Die Z-Achse wird über eine Spindel verfahren, die restlichen Motoren sind direkt mit den jeweiligen Achsen verbunden. Mit den Motorencodern werden die aktuelle Positionen erfasst, dabei ist beim Einschalten eine Referenzfahrt nötig, um die Nullpunkte der Z-Achse und Armwinkel zu ermitteln.Die gewünschte Position wird vom Anwender in kartesischen Koordinaten vorgegeben. Innerhalb der Software werden daraus die einzelnen Sollwinkel errechnet und validiert. Die Positionregelung erfolgt bislang für jeden Motor durch einen einzelnen PID-Reglern. Bei Vorgabe eines Punkts fahren alle Motoren den jeweiligen gewünschte Winkel an, wobei der langsamste Motor die Zeitdauer bestimmt. Ebenso ist der abgefahrene Weg eine Kurve, die von Anfangs- Endposition und der SCARA-Kinematik abhängt. Eine kontrollierte Fahrt entlang einer Linie ist angedacht.\nDie Mechanik ist weitgehend Spielfrei und sehr robust konstruiert. Mit geeignetem Werkzeug kann man auch Bäume ausreißen.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Mechanik: CAD, Fräsen, Berechnung von Kinematik und Dynamik</li>\n  <li>Elektrik: Ansteuerung der Motoren, Auswertung der Encoder, Verkabelung</li>\n  <li>Software: Anwenderschnittstelle, Regelung und Berechnungen zur Positionierung</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Sensorfusion",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/sensorfusion.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Verbesserung der Roboter-Ortung durch Fusion mehrerer Systeme.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Die Präszision der Ortung unserer Roboter hat einen großen Einfluss auf die Performance im Wettbewerb.\nMomentan haben die eingesetzten Ultraschallbaken Probleme mit Rotationen und die Odometrie [2] wird über die Antriebsräder durchgeführt,\ndie aufgrund von (unregelmäßigem) Schlupf einen wahrnehmbaren Fehler erzeugen.</p>\n\n<p>Zwei Ansätze sind geplant, um dem Abhilfe zu schaffen:\nIMUs (Inertial measurement unit) auf Ultraschall-Baken und RUNE-Tags [3] auf den Robotern, die von einer Kamera erkannt werden.\nDamit tatsächlich eine Verbesserung der Ortung erreicht werden kann, reicht es nicht diese Systeme einzuführen und die alten zu ersetzen.\nIntelligente Software ist nötig, um die verschiedenen Ortungsdaten zu vereinen.\nDa unsere Software mit ROS2 geschrieben wird wird muss ein dazu kompatibles System in Python und/oder C++ entwickelt werden.</p>\n\n<h3 id=\"geplante-features\">Geplante Features:</h3>\n<ul>\n  <li>Filterung der Messwerte</li>\n  <li>Ausreißer-Elimination (z.B. RANSAC-Verfahren)</li>\n  <li>Überwachung der Roboterbewegung; Präferenz für Systeme je nach Eignung in der jeweiligen Situation</li>\n  <li>Plausibilitätsprüfung der Positionen/Ausrichtungen vor Korrektur</li>\n  <li>Visualisierung der berechneten Daten zur Validierung des Verfahrens</li>\n  <li>Entwicklung als ROS2-Node</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Herleitung von Geometrische Berechnungen und Algorithmen</li>\n  <li>Entwicklung von Algorithmen zur Signalverarbeitung (Filterung, Ausreißeranalyse)</li>\n  <li>Software-Entwicklung für ROS2 in Python und/oder C++</li>\n  <li>Software für Microcontroller in C++ mit modm.io</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Sensorik zur Gewichtsmessung",
          "category" : "Projekt",
          "tags"     : " elektronik, pcb, software, mechanik",
          "url"      : "/projekt/gewichtsmessung.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Aufbau eines Prototypen zur Gewichtsmessung von Spielelementen mit Roboterarmen.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Bei der Ankündigung des Eurobot-Mottos für 2019 “Atom Factory” [1] wurde erwähnt, dass die Roboter Spielelemente wiegen sollen.\nAuch für einige andere Aktorik ist die Technologie hilfreich.</p>\n\n<p>Das Ziel des Projekts ist einen Prototyp einer Sensorik zur Gewichtsmessung für einen Roboterarm zu implementieren.</p>\n\n<p>Die verschiedenen möglichen Methoden zur Gewichtsmessung soll verglichen und für den Einsatz im Roboter bewertet werden.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>Mögliche Methoden\n    <ul>\n      <li>Strommessung Elektromotor</li>\n      <li>Dehnungsmessstreifen [2]</li>\n      <li>Mechanisch mit Feder und Taster</li>\n      <li>Weitere [3]</li>\n    </ul>\n  </li>\n  <li>Präzision je nach Anforderungen</li>\n  <li>Kraft/Gewicht je nach Anforderungen</li>\n  <li>Platine zum Anschluss an CAN</li>\n  <li>Kompakte Baugröße</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Analoges Schaltungsdesign</li>\n  <li>PCB Design</li>\n  <li>STM32</li>\n  <li>Software Mikrocontroller</li>\n  <li>Ggf. Mechanik</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Silikon-Räder",
          "category" : "Projekt",
          "tags"     : " mechanik, werkzeug",
          "url"      : "/projekt/silikon-raeder.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Silikon hat für die Antriebsräder sehr geeignete Eigenschaften.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Die Roboter des Roboterclubs werden von Motoren angetrieben welche ihre Kraft mit Hilfe von Rädern auf den Untergrund bringen.</p>\n\n<p>Dabei spielen die Räder eine entscheidenden Faktor wie präzise und schnell der Roboter fahren, beschleunigen und bremsen kann.\nJe größer die Haftung der Räder auf dem Untergrund ist, umso besser kann Kraft übertragen werden.</p>\n\n<p>Historisch wurden im RCA modifizierte Inline-Skater-Räder oder Modellbau-Räder verwendet, in letzter Zeit hat uns die Firma TYP AG / TGW GmbH mit nach unseren Vorgaben individuell angefertigten Rädern mit vulkanisiertem Gummi unterstützt.</p>\n\n<p>Für den kleiner Roboter der Saison 2016 wurden bereits Experimente mit Silikonrädern durchgeführt, der Ergebnis war ein voller Erfolg.</p>\n\n<p>Im Rahmen dieses Projektes soll die Technologie zum Gießen von Silikon im RCA erarbeitet und dokumentiert werden und in Folge dessen für mindestens einen der Roboter Antriebs-Räder aus Silikon hergestellt werden.</p>\n\n<p>Neben den Antriebsrädern gibt es noch viele weitere Anwendungen für gegossene Silikon-Teile, beispielsweise bei Greifern.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>CAD-Konstruktion mit SolidWorks</li>\n  <li>Fertigung von Formen mit CNC-Fräse und/oder 3D-Drucker</li>\n  <li>Ggf. Kooperation mit einem Institut bzw. Silikonhersteller</li>\n  <li>Gießen von Silikon</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Simulator",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/simulator.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Im Simulator können die Roboter virtuell getestet werden, dazu wird die Roboterhardware emuliert und das Spielfeld mit Spielelementen sowie Gegnerroboter simuliert.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Für das Testen von unserer Eurobot Spielstrategie wollen wir einen Simulator entwickeln,\nder den Roboter auf dem Spielfeld mit Spielelementen in 2 bis 2,5 Dimensionen simuliert,\nmit vereinfachten oder ideellen physikalischen Berechnungen.</p>\n\n<p>Dieser Simulator soll auch genutzt werden, um verschiedene Subsyteme des Roboters (zB. Regelungsschleifen, Sensorauswertungen mit Rauschen)\nwährend der Entwicklungsphase schnell zu testen, ohne auf einen funktionierenden Roboter angewiesen zu sein.\nInsbesondere zum Evaluieren unserer Spielstrategie ist es sinnvoll auch schneller als Echtzeit simulieren zu können.</p>\n\n<p>Desweiteren soll eine Anbindung an Matlab oder Numpy bereitstellt werden, sodass komplexere Simulationen von physikalischen \nEigenschaften als Plugin hinzugeschaltet werden können.\nDie Saison spezifischen Daten für das Spielfeld und Roboter können aus den Eurobot Shared Resources eingelesen werden [1].</p>\n\n<p>Der Zeitraum zwischen der Bekanntgabe der Eurobot-Regeln und den Wettbewerben ist mit einem halben Jahr recht kurz,\ndaher soll die Software-Entwicklung parallel zur Konstruktion und Bau der Mechanik erfolgen.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n\n<ul>\n  <li>Softwareentwicklung in Python oder C++ mit Qt5</li>\n  <li>Simulation von Robotern, Spielfeld und Spielelementen</li>\n  <li>Datenverarbeitung und Replay</li>\n  <li>Sensoren (Distanz, Laserscanner, Farbe, etc.)</li>\n  <li>Interface mit Matlab für Regelungen modellieren</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Software auf modm portieren",
          "category" : "Projekt",
          "tags"     : " software, werkzeug",
          "url"      : "/projekt/rca-projekte-auf-modm-portieren.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Erstellung einer Skripte-Sammlung, die das Portieren unserer Software Projekte vom xpcc.io Framework zur modm.io Library (halb-)automatisch ermöglicht.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Wir nutzen seit 2009 das xpcc.io Framework [1] als Basis für all unsere eingebettete Software.\nVon 2016 bis 2018 haben die zwei Hauptmaintainer Fabian und Niklas H. dieses generalüberholt\nund tiefgreifende Änderungen in der Code-Generierung und teilweise der Struktur/API gemacht,\num den Code modularer und insbesondere unabhängig vom Build System zu machen.</p>\n\n<p>Der Nachfolger von xpcc heißt jetzt modm [2]. \nxpcc wird noch bis Ende 2018 maintained und danach als deprecated markiert.\nBis dahin werden alle Änderungen von xpcc nach modm von Niklas H. portiert.</p>\n\n<p>Ein oder mehrere Skripte sollen entwickelt werden, die den Hauptteil der Änderungen\nvollautomatisch, oder zumindest mit wenigen manuellen Eingriffen, anwenden.\nZusätzlich soll ein Porting Guide von xpcc auf modm für die Webseite geschrieben,\nsodass auch externe Anwender auf modm upgraden können.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>C++17, Regex, Python3, SCons</li>\n  <li>Verständnis der Änderungen zwischen xpcc und modm</li>\n  <li>Code Generierung</li>\n  <li>Versionsverwaltung und CI</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Spielzeit Uhr",
          "category" : "Projekt",
          "tags"     : " software, elektronik",
          "url"      : "/projekt/eurobot-spielzeit-uhr.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Anzeige der Spielzeit eines 100s Eurobot Spiels.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Eurobot Spiele sind 100s lang, das passt gerade noch so in zwei 7-Segment Anzeigen.\nWir haben eine große LED-Anzeige ergattert, die 6x 7-Segment Anzeigen hat (2x blau, 4x rot)\nund gut hackbar ist. Die einzelnen LED Anzeigen werden jeweils via SPI mit einem\n16-bit Constant Current LED Driver (FD9802) gesteuert.</p>\n\n<p>Wir wollen den obskuren (8-bit?) Prozessor auf dem Board ersetzen durch einen\nSTM32 (Nucleo-32 passt gut) und das Board per Funk mittels NRF24 in unsere\nRoboterfunk Verbindung einbinden, sodass das Display den Spielstart automatisch\nmitbekommt, ohne speziell konfiguriert werden zu müssen.</p>\n\n<p>Auf dem Blauen LEDs sollen die verbleibende Spielzeit angezeigt werden, und auf den\nrestlichen Anzeigen evtl. die Punkte, die unser Roboter schätzt gemacht zu haben.\nCreative Animationen mit den wenigen LEDs sind gern gesehen.</p>\n\n<h3 id=\"anforderungen\">Anforderungen</h3>\n\n<ul>\n  <li>Neue Hardware ist klein genug um im original Gehäuse zu bleiben</li>\n  <li>Leicht zu Wettbewerben mitnehmbar</li>\n  <li>Stromsparend wenn nicht in Benutzung</li>\n  <li>Automatische Erkennung von Spielstart und Punkten via Funk</li>\n  <li>Animation für Spielende</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n\n<ul>\n  <li>PCB Reverse Engineering</li>\n  <li>Funkkommunikation mit NRF24L01</li>\n  <li>Eingebettete Software mit modm.io [1]</li>\n  <li>7-Segment LED Anzeigen</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Ultraschall Lokalisierung (Baken)",
          "category" : "Projekt",
          "tags"     : " software, elektronik",
          "url"      : "/projekt/ultraschall-baken.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Unsere Roboter sollen sich mittels eines Ultraschall-Baken-Systems auf dem Spielfeld orientieren können.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Wir wollen beim kommenden Wettbewerb ein neues System zu Lokalisierung und unserer eigenen sowie der Gegner-Roboter einsetzen.</p>\n\n<p>Das technische Konzept das Ultraschall-Lokalisierung wurde in den letzten Jahren bereits entwickelt und getestet, eine gute Übersicht liefert die Veröffentlichung [1].</p>\n\n<p>Dieses System muss nun in unsere Roboter und Gegner-Baken integriert, angepasst und getestet werden.</p>\n\n<h3 id=\"technische-daten-geplant\">Technische Daten (geplant)</h3>\n<ul>\n  <li>Drei feste Baken am Spielfeldrand</li>\n  <li>Mobile Baken in den eigenen Robotern und in den Gegnerbaken</li>\n  <li>Geringe Latenz &lt;10ms</li>\n  <li>Genauigkeit &lt;5mm</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Implementation der Funk-Kommunikation mit R2MAC/NRF24L01+</li>\n  <li>Software\n    <ul>\n      <li>Portieren der Software zum modm-Framework</li>\n    </ul>\n  </li>\n  <li>ggf. PCB Design</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: Vision-2-Win",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/camera-vision.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Das Vision System erkennt Spielelemente und ihre Position mithilfe von Kameras am Spielfeldrand und Roboter.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Mithilfe von Kameras an den stationären Barken um das Spielfeld sowie auf dem Roboter wollen wir in Zukunft Spielelemente und eigene und gegnerische Roboterposition erkennen.</p>\n\n<p>Eine Standard Library zur Bildverarbeitung, die wir dazu nutzen, ist OpenCV [1].\nZum Tracking der Roboterposition eigenen sich z.B. diverse Fiducial Marker Systeme [3,4,5].\nDiese können wir durch LED Marker etc. weiterentwickeln.</p>\n\n<p>Spielelemente können wir mithilfe diverser Matching und Detection Verfahren in OpenCV erkennen, oder sogar trainierte Object Detection Classifier [6] verwenden.\nEine weitere Möglichkeit der Positionserkennung von Spielelementen können in Zukunft Kameras unseres Sponsors Cognex sein, die auf dem Roboter montiert werden [7].</p>\n\n<h2 id=\"arbeitspakete-für-die-saison-2020\">Arbeitspakete für die Saison 2020</h2>\n\n<ol>\n  <li>Aufbau eines Kamerasystems und Hardware Plattform (z.B. Cognex Kameras, GigE Kameras, Intel NUC oder NVIDIA Jetson)</li>\n  <li>Kontinuierliche Erkennung der Roboterposition mithilfe von Markern</li>\n  <li>Erkennen von Spielelementen entsprechend neuem Regelwerk für 2020</li>\n  <li>Visualisierung der erkannten Spielelemente in RVIZ [8] oder GAZEBO [2]</li>\n</ol>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: librobots: Open Source Veröffentlichung",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/librobots-open-source.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Vervollständigung und Veröffentlichung unserer internen librobots Bibliothek auf GitHub.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Es existiert recht viel Code, der jede Saison weiter benutzt wird, aber nicht \ngenerisch genug ist um in modm.io zu landen.\nDeshalb wurde angedacht, diesen Code in librobots zu überführen und dort als\neigenständiges Projekt zu warten und somit duplizierten Code zu vermeiden.\nDieses Projekt soll den Kern unserer modularen Robotersoftware werden, ähnlich\nwie xpcc bzw. modm der Kern unserer eingebetteten Software ist.\nDemzufolge soll auch die entstehende Architektur dokumentiert werden.</p>\n\n<p>Dieses Projekt ist als “Ausbildung” zum Open Source Maintainer gedacht, und ist\nsomit als Langzeitprojekt konzipiert.\nDie librobot soll zunächst im internen GitLab für die Veröffentlichung vorbereitet\nwerden und dann unter der RCA GitHub Organisation [1] als Open Source Projekt \ngeführt werden.\nDie Prozesse (Issue Tracking, Code Review, CI, Dokumentation) sollen wenn möglich\nähnlich zu modm.io gehalten werden.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>Open Source Library Maintenance</li>\n  <li>Issue Tracking and Code Review</li>\n  <li>Architecture Design</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: modm: Besseres Dokumentationsformat",
          "category" : "Projekt",
          "tags"     : " software, webentwicklung, werkzeug",
          "url"      : "/projekt/modm-dokumentation.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Programmieren eines Dokutools mit Doxygen und lbuild Anbindung und Automatisierung von Doku-Qualitätkontrollen.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Sowohl xpcc als auch modm [1] sind relativ gut <em>im Code</em> mittels Doxygen dokumentiert.\nFür xpcc haben wir somit einfach den generierten Doxygenoutput online gestellt [2].\nDoxygen eignet sich allerdings nicht besonders gut für Konzeptdokumentation und Beispielcode.</p>\n\n<p>Mit <code class=\"highlighter-rouge\">lbuild</code> [3] ist modm in mehrere Module aufgeteilt, die jeweils nur eine überschaubare Anzahl an Klassen verwalten.\nDiese Module können separat in Markdown dokumentiert werden und erlauben detailierte Konzeptdokumentation [4].\nDie Doxygendokumentation des Codes kann als XML ausgegeben und per Python3 eingelesen werden [5], momentan, werden\nallerdings nur die wichtigsten Objektnamen angezeigt [6].</p>\n\n<p>Es soll ein Konzept erarbeitet werden, wie am Besten die Doxygendokumentation in die Moduldokumentation eingebunden werden kann,\nsodass es einfach ist komplexe Dokumentation zu schreiben und mit der Implementation zu verlinken.\nDesweiteren sollen Beispiele in der Moduldokumentation kompilierbar sein, und wenn möglich weitere Überprüfungen (zB. valide Objektnamen im Fließtext) als Teil des CIs implementiert werden.\nDamit soll die Dokumentation synchron zur Implementierung gehalten werden.\nAbschließend soll diese Dokumentation visuell ansprechendend, durchsuchbar und gut navigierbar unter docs.modm.io automatisch\ndeployed werden.</p>\n\n<p>In Zukunft soll dieses Tool auch für librobots und evtl. andere RCA Projekte verwendet werden.\nAls Vorbild für Design und Vollständigkeit gilt die Qt5 Dokumentation [7].</p>\n\n<p><em>Es ist explizit nicht erforderlich, Dokumentation für modm zu schreiben!</em>\nEs geht hier um die automatische Erstellung und Pflege der Dokumentation, nicht unbedingt den Inhalt.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n\n<ul>\n  <li>Doxygen XML Auswertung für Assembly, C, C++</li>\n  <li>Python3 und Jinja2 für Datenumwandlung und Dokumentationsgeneration</li>\n  <li>Editieren Technischer Dokumentation</li>\n  <li>Automatische Compilierung von Beispielcode</li>\n  <li>Automatisches Deployment der Dokumentation</li>\n  <li>Webdevelopment und -design, evtl. mit vorhandener Doku-Engine</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: modm: Einheitensystem und Festkomma-Arithmetik",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/modm-units-and-fixed-point.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Implementation eines Einheitensystem mit user-defined literals und in Kombination mit Festkomma-Arithmetik für das open-source C++-Microcontroller-Framework modm.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Für alle physikalischen Berechnungen in unserer Robotersoftware wollen wir Einheiten nutzen können, dies sorgt für übersichtlicheren und besser selbst-dokumentierenden Code.</p>\n\n<p>Beispiel:</p>\n<div class=\"highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>using namespace modm::units;\nlength_t distance = 300_mm;\ntime_t   time     = 1500_ms;\nvelocity_t speed  = distance / time;\nfloat foo         = distance + time; // compiler error: Units are not compatible.\n</code></pre></div></div>\n\n<p>Da es auf Microcontrollern aus verschiedenen Gründen nicht erstrebenswert mit Gleitkommazahlen zu rechnen ist, bietet es sich an gleichzeitig Festkomma-Arithmetik [1] im modm [2] zu implementieren.</p>\n\n<h3 id=\"diskussion--features\">Diskussion &amp; Features</h3>\n<ul>\n  <li>Fehlerabschätzung Multiplikation und Division</li>\n  <li>Unittests</li>\n  <li>Portieren und Anpassen bestehender Klassen</li>\n</ul>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>C++</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: modm: Hardware Unittests",
          "category" : "Projekt",
          "tags"     : " software, webentwicklung, elektronik, werkzeug",
          "url"      : "/projekt/modm-hwut.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Automatisches Ausführen von Unit- und Integrationstests auf Arm Cortex-M Mikrocontrollern.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>modm [1] enthält eine große Anzahl an Unittests [2], die auch in unserem CI automatisch auf x86 ausgeführt werden.\nDiese Unittests können auch direkt auf dem Mikrocontroller ausgeführt werden, allerdings nur manuell und mit diversen Einschränkungen [3].\nDieser Prozess soll automatisiert werden, und die Ergebnisse als Teil des modm CIs für alle öffentlichen Pull Requests auf GitHub zur Verfügung gestellt werden.\nDazu stellen wir eine große Anzahl an diversen STM32 Discovery und Nucleo Development Boards.</p>\n\n<p>Da die modm Unittests recht begrenzt sind in ihrer Funktionalität, wäre es evtl. sinnvoll ein vollständigeres Unittest Framework wie Metal.Test zu nutzen [4].\nTracing und Performance könnte zusätzlich mit der Arm Cortex-M Debughardware erfasst werden [5].</p>\n\n<p>Zusätzlich zu in sich geschlossenen Unittests sollen auch Hardware Integrationstests erforscht werden.\nDazu gibt es Überlegungen, während eines Testes die Input/Output Werte des Mikrocontrollers mit Hilfe vom SigRok [6] zu erfassen und gegen diverse Eigenschaften und Testcases zu überprüfen.\nHier sollen verschiedene komplexe Tests gefahren und ausgewertet werden können [7], evtl. mit FPGA als IO-Multiplexer und Logikanalyzer.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n\n<ul>\n  <li>Testing mit Hardware-in-Loop</li>\n  <li>Anzeige als GitHub Continuous Integration Service</li>\n  <li>Debugging mit GDB auf Arm Cortex-M</li>\n  <li>Arm Cortex-M Debug-Hardware</li>\n  <li>Erstellen von Logikwaveformtests</li>\n  <li>Automatisierte Auswertung von Logikprotokollanalysen</li>\n  <li>PCB Design mit FPGAs</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: modm: Konzept und Umsetzung einer DMA Schnittstelle",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/modm-dma.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Erstellen eines Modells flexiblen und einfachen Nutzung von DMA (Direct Memory Access) in User-Code und anderen modm-Modulen.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Die meisten Mikrocontroller haben eine DMA-Einheit, welche unabhängig von der CPU auf Speicher zugreifen kann und Daten kopieren kann.\nDurch die Nutzung von DMA kann beispielsweise Peripherie wie SPI mit Daten zum senden versorgt und die empfangenen Daten gespeichert werden ohne dass die CPU hierbei belastet wird,\nwovon in modm [2] bisher kein Nutzen gemacht wird.</p>\n\n<p>Einige sehr zeitkritische Anwendungen können ohne DMA gar nicht implementiert werden,\nbeispielsweise eine Ansteuerung von WS2812-LEDs mit Bitmustern aus SPI.</p>\n\n<p>Im Rahmen dieses Projekts soll ein API für Abstraktion von DMA-Einheiten entwickelt werden welches sowohl flexibel im Bezug auf mögliche DMA-Einheiten ist,\nals auch universell in modm-Modulen wie Gerätetreibern und im User-Code einsetzbar ist.\nDie Abstraktion sollte mindestens für STM32 Mikrocontroller implementiert werden,\nweitere Implementierungen könnten später erfolgen.</p>\n\n<p>Anschließend können die vorhandene Treiber für STM32-Peripherie (SPI, UART, …) für DMA erweitert oder angepasst werden.</p>\n\n<p>Aus dem Vorgängerprojekt vom modm, xpcc, existiert eine DMA-API [1], die sich allerdings als suboptimal herausgestellt hat.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>C++17</li>\n  <li>STM32 Speicherarchitektur, sowie weitere mögliche weitere Architekturen</li>\n  <li>STM32 Peripherie: DMA, Timer, SPI, UART, …</li>\n  <li>Low-level Programming in modm.io</li>\n</ul>\n"
       
     } ,
   
     {
       
          "title"    : "Projekt: modm: Nebenläufigkeits Modelle erforschen (Concurrency)",
          "category" : "Projekt",
          "tags"     : " software",
          "url"      : "/projekt/modm-concurrency-modelle.html",
          "date"     : "October 28, 2019",
          "excerpt"  : "Erstellen eines Modells zur einfachen und sicheren Beschreibung von Nebenläufigkeiten (Concurrency) für eingebettete Systeme.",
          "content"  : "<h2 id=\"zusammenfassung\">Zusammenfassung</h2>\n\n<p>Um die Nebenläufigkeiten im Robotercode zu beschreiben nutzen wir Protothreads [1], Resumable Functions [2] und Activities [3].\nDiese basieren auf sog. stackless cooperative scheduling, die simpelste Form der Nebenläufigkeit.\nDesweiteren ist das XPCC Protokoll als Event-Loop implementiert und ruft die Empfänger mittels diesen\nMechanismen auf [4].</p>\n\n<p>Diese Architektur ist sehr speichereffizient und funktioniert somit auch noch auf sehr speicherlimitierten\nMikrocontrollern wie die AVRs. Für unsere Zwecke ist sie aber zu effizient, sodass es mühsam und teilweise \nunintuitiv ist, komplexere Nebenläufigkeiten abzubilden. Desweiteren nutzen wir keine AVRs mehr, sondern\nARM Cortex-M Systeme, die genügend Speicher mitbringen.</p>\n\n<p>Wir möchten mehrere Concurrency Modelle erforschen und bewerten, wie gut sie sich auf\nunser Problem anwenden lassen und wie man sie effizient auf AVR und ARM Cortex-M\nimplementiert.</p>\n\n<p>Das Resultat soll dann in modm.io [5] implementiert werden und der Prozess ordentlich\ndokumentiert werden, sodass es auch extern genutzt werden kann.</p>\n\n<h2 id=\"tätigkeitsfelder-und-technologien\">Tätigkeitsfelder und Technologien</h2>\n<ul>\n  <li>C++17, C11, AVR/ARMv6/v7-M Assembly</li>\n  <li>Concurrency Modelle: Actors, Threading, Coroutines, Event-Loops</li>\n  <li>AVR und ARM Cortex-M Architektur</li>\n  <li>Low-level Programming in modm.io</li>\n</ul>\n"
       
     } 
   
  
]
